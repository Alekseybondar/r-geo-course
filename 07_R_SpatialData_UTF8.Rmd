# Чтение и визуализация пространственных данных {#spatial_data}

Данный модуль посвящен введению в работу с пространственными данными в R. Рассматривается чтение растровых и векторных данных, их визуализация стандартными средствами библотеки `sp()`.Благодаря библиотекам `sp`, `rgdal`, `raster` и `maptools` в __R__ возможно работать с пространственными данными. При этом работа с атрибутивными таблицами идентична работе с данными типа data.frame, а построение карт производится аналогично построению графиков с помощью функции `plot()`

## Введение

__Пространственные данные__ --- это данные о пространственных объектах и их наборах. В свою очередь, пространственный объект определяется как цифровая модель материального или абстрактного объекта реального или виртуального мира с указанием его идентификатора, координатных и атрибутивных данных ^[ГОСТ Р 52438-2005 <<Географические информационные системы. Термины и определения>>. В стандарте поясняется, что объектом может быть неподвижный или движущийся простой или сложный объект, явление, событие, процесс и ситуация. Моделируемый объект может относиться к территории, акватории, недрам и воздушному пространству Земли, околоземному космическому пространству, другим космическим телам и небесной сфере. В широком смысле под пространственным объектом в геоинформатике понимается как сам объект, так и адекватная ему цифровая модель].

Если говорить по сути, то пространственные данные можно определить как _данные о географических объектах или явлениях, фиксирующие их местоположение и/или распределение в системе координат, привязанной к телу Земли или любого другого небесного тела_. Таким образом, отличительной особенностью пространственных данных перед непространственными является координатное описание местоположения. Важно знать отличия между векторной и растровой моделью пространственных данных. 

__Векторная модель__ пространственных данных включает описание координатных данных пространственных объектов и, возможно, топологических отношений между ними. Векторные данные фиксируют местоположение и форму объектов в виде геометрических примитивов, таких как точки, линии, полигоны, объемные тела. Выбор модели объекта (например, представить город точкой или полигоном) зависит от масштаба анализа и целей исследования. Векторная модель данных является объектно-ориентированной. 

__Растровая модель__ описывает не объекты, а пространственное распределение некоторой (выбранной исследователем) характеристики. Пространство разбивается регулярной сеткой ячеек, в каждой ячейке фиксируется значение исследуемого параметра (путем статистического осреднения, семплирования в центре ячейки и т.п.). Растровые данные могут быть как количественными (например, поле температуры), так и качественными (например, растр классифицированного снимка, каждая ячейка которого фиксирует принадлежность к тому или иному типу объекта). Таким образом, растровая модель является пространственно-ориентированной (или феномен-ориентированной).

В настоящей лекции мы познакомимся с чтением и виузализацией пространственных данных на примере растров температуры и векторных данных общегеографичекой основы. Для этого нам понадобится несколько вспомогательных пакетов:

* __sp__ --- пакет, обеспечивающий поддержку векторных и растровых данных в R
* __raster__ --- пакет, предоставляющий удобный интерфейс для чтения и визуализации растровых данных в R
* __rgdal__ --- пакет, предоставляющий средства для чтения множества форматов пространственных данных. Является интерфейсом популярной библиотеки [GDAL](http://www.gdal.org).

```{r, collapse=TRUE, eval=-6}
library(sp) # sp — пакет, предоставляющий классы пространственных данных
library(rgdal) # rgdal — пакет для чтения и записи различных форматов данных 
library(raster) # raster — пакет для чтения растровых данных
library(scales) # дополнительные инструменты классификации
library(Cairo) # экспорт в PDF

setwd("/Volumes/Dropbox/Dropbox/R/Lectures/Scripts/RMarkdown/data/7_R_Spatial")
```

## Растровые данные

Чтение растровых данных может производиться как с помощью `rgdal`, так и с помощью `raster()`. Второй способ удобнее

```{r, collapse = TRUE}
# Прочитаем растровый файл
temp <- raster("tmean_1.tif")

# Проверим, какой он имеет класс:
class(temp)

# попробуем вывести растр на экран:
plot(temp)
# видно, что растр хранит температуры, умноженные на 10, нужно привести их к истинным значениям:
temp <- temp/10
# визуализируем график.
plot(temp)
```

Чтобы изображение стало больше похоже на карту температур, необходимо задать цветовую шкалу, соответствующую отображаемому диапазону температур, а также классифицировать растр, то есть разбить его на равные интервалы температур и отобразить каждый интервал своим цветом, выбранным из палитры.

Чтобы классифицировать растр методом равных интервалов с заданным шагом, нужно для начала определить минимальную и максимальную температуры. Для этого можно воспользоваться функцией `cellStats()` из пакета `raster`.

```{r}
# создадим цветовую палитру в синих тонах
pal <- colorRampPalette(c("dodgerblue4","dodgerblue1"))

# вычислим минимум и маскимум температуры
min <- cellStats(temp, "min")
max <- cellStats(temp, "max")

# определим ширину интервала температур равной 2.5 градусам
step <- 2.5

# вычислим границы равных интервалов, используя функцию fullseq() из пакета scales
levels <- fullseq(c(min, max), step)

# определим количество полученных интервалов
nclasses <- length(levels)-1

# визуализируем данные
plot(temp, 
     breaks = levels, # в breaks подставляем границы интервалов
     col = pal(nclasses))
```

Теперь посмотрим на задачу визуализации в более широком ракурсе. В нашем распоряжении имеется 12 месяцев, и мы хотим построить серию карт среднемесячных температур в единой шкале, чтобы карты можно было сравнивать друг с другом. Для этого нам необходимо:

1. Предложить цветовую палитру, которая покрывает теплые и холодные месяцы года.
2. Вычислить интервалы, покрывающие полный размах температур --- от самой холодной до самой теплой точки года.

Шкалу выберем стандартную от синего к белому в области отрицательных температур и от белого к оранжевому в области положительных температур.

```{r, collapse = TRUE}
colors <- c("dodgerblue4","white","orange","firebrick")
pal <- colorRampPalette(colors)

# Можно, кстати, визуализировать полученные цвета как пиксельное изображение:
ncolors <- length(colors)
image(x = 1:ncolors,
      y = 1,
      z = as.matrix(1:ncolors),
      col = colors)
```

Чтобы интервалы охватывали все месяцы года, необходимо просмотреть все 12 файлов и найти минимум и максимум температуры. Вообще, задачу поиска минимума или максимума в неупорядоченном множестве из N элементов можно решить следующим образом:

1. Принимается, что минимум (максимум) равен первому элементу
2. Организуется цикл от 2-го до N-ного элемента.
3. На каждой итерации цикла выполняется проверка: если текущий элемент меньше (больше), чем минимум (максимум), то приравнять минимум (максимум) текущему элементу.

По завершению выполнения цикла будет найден минимальный (максимальный) элемент множества.

В нашем случае элементами являются файлы температур по месяцам, текущее значение будет вычисляться как минимум или максимум во всем пикселам текущего растра.

```{r, collapse = TRUE}
# Примем условно, что минимум и максимум содержатся в первом файле
min <- cellStats(temp, "min")
max <- cellStats(temp, "max")

# Создадим список для растров, чтобы прочитать их единожды и далее использовать во всех циклах
rasters <- vector(mode = "list", length = 12)

# Запишем первый растр в список
rasters[[1]] = temp

# Пройдемся по остальным файлам и сравним их минимумы и максимумы с текущим
for (i in 2:12){
  # сформируем имя файла
  file <- paste("tmean_", i, ".tif", sep="")
  
  # прочитаем файл
  temp <- raster(file)/10
  
  # Запишем текущий растр в список
  rasters[[i]] <- temp
  
  # вычислим текущий минимум и максимум
  vmin <- cellStats(temp, "min")
  vmax <- cellStats(temp, "max")
  
  # выясним, не меньше ли текущее значение, чем тот минимум, что мы храним
  if(vmin < min){
    min <- vmin # если да, то заменим минимум на текущее значение
  }
  
  # аналогично для максимума
  if(vmax > max){
    max <- vmax
  }
}

paste("Минимальная температура - ", min)
paste("Максимальная температура - ", max)

# Если предположить, что температуры будут визуализироваться
# с шагом 2.5 градуса, то шкалу сечения можно посчитать автоматически

# Рассчитаем границы классов, покрывающие диапазон данных, 
# используя удобную функцию fullseq() из пакета scales
levels <- fullseq(c(min, max), step)

# Количество интервалов в шкале равно количеству граничных значений -1
nclasses <- length(levels)-1

# Выведем теперь данные на экран
plot(temp, 
     breaks = levels, 
     col = pal(nclasses))

# легенду можно сделать и покрасивее. За ширину шкалы отвечает параметр
# legend.width, а за ее растяжение по высоте — legend.shrink.
# Если legend.shrink = 1, то легенда будет по высоте такой же как и карта:

plot(temp, 
     breaks = levels, 
     col = pal(nclasses), 
     legend.shrink = 1, 
     legend.width = 1.5)

# вы также можете более тонко настроить параметры легенды растрового слоя, используя
# аргументы legend.args и axis.args. Оба параметра являются списками

# legend.args  отвечает за заголовок легенды,
# axis.args отвечает за шкалу подписей.

legendargs <- list(text='°С', 
                   side=3, 
                   font=2, 
                   line=0.3, 
                   cex=0.8)

axisargs <- list(cex.axis=0.7)

# сделаем поля поуже:
par(mar=c(6,3,5,1)+0.1)
# и по 2 графика на строку
par(mfrow = c(1,2))

months<-c("Январь","Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь")

for (i in 1:12){
  plot(rasters[[i]], 
       breaks = levels, 
       col = pal(nclasses), 
       legend.mar = 4.5, 
       legend.shrink = 1, 
       legend.width = 1.5, 
       legend.args = legendargs, 
       axis.args = axisargs,
       main = months[i]
  )
}

```

## Векторные данные

Чтение векторных данных производится с помощью функции `readOGR()` из библиотеки `rgdal`. Ее первый параметр --- это директория, в которой хранятся данные, а второй параметр --- имя файла, который нужно прочитать. Если директория совпадает с директорией, установленной с помощью функции `setwd()`, то можно написать просто точку `"."`:
```{r, collapse=TRUE}
regions <- readOGR(".", "Regions")
rivers <- readOGR(".", "Rivers")
lakes <- readOGR(".", "Lakes")
cities <- readOGR(".", "Cities", encoding="UTF-8")

# При этом также автоматически распознается информация о проекции данных:
proj4string(regions)

# Узнать тип объекта можно как и прежде с помощью функции class()
class(regions)
class(rivers)
class(cities)
```

Визуализация векторных данных ничем не отличается от построения графиков. Более того, она даже проще, поскольку достаточно указать лишь набор данных, а __R__ автоматически подбирает способ изображения (ареал, линию, точку) в зависимости от класса пространственных объектов.

> ВНИМАНИЕ: для того чтобы новые слои рисовались поверх существующих, в функции `plot()` необходимо задать параметр `add = TRUE`.

```{r basetemp, collapse = TRUE}
par(mfrow = c(1,1))
plot(temp, 
     breaks = levels, 
     col = pal(nclasses), 
     legend.mar = 4.5, 
     legend.shrink = 1, 
     legend.width = 1.5, 
     legend.args = legendargs, 
     axis.args = axisargs
)
plot(regions, border = "black", add = TRUE, lwd = 0.3)
plot(rivers, col = "midnightblue", add = TRUE, lwd = 1)
plot(lakes, col = "steelblue1", add = TRUE, lwd = 0.5)
plot(cities, add = TRUE, pch = 20)
```

## Подписи

Подписи объектов на графиках и картах размещаются с помощью функции `text()`. Этой функции необходимо передать координаты точек размещения подписей, а также сами подписи. Все три аргумента должны быть векторами. 

Чтобы нанести подписи населенных пунктов, просмотрим сначала состав атрибутивной таблицы:
```{r, collapse = TRUE}
View(cities)
```
```{r, echo = FALSE, purl=FALSE}
datatable(cities@data, options = list(pageLength = 5, scrollX = TRUE))
```
```{r, collapse = TRUE}
# Извлечем координаты городов
pts<-coordinates(cities)

# Посмотрим, что они из себя представляют
View(pts)
```
```{r, echo = FALSE, purl=FALSE}
datatable(pts, options = list(pageLength = 5, scrollX = TRUE))
```

Координаты $X$ хранятся в первом столбце, $Y$ --- во втором, а подписи мы возьмем из столбца `name_2` исходной таблицы `cities`. Такж укажем дополнительные параметры `cex=` и `pos=`, отвечающие за размер подписей и их расположение относительно точки:
```{r text, collapse = TRUE, eval = FALSE}
text(pts[,1], pts[,2], labels = cities$name_2, cex = 0.8, pos = 3)
```
```{r, ref.label=c("basetemp", "text"), echo = FALSE}
```

## Координатая сетка и оси

Координатная сетка и оси могут формироваться как вручную, так и автоматически. Чтобы автоматически нанести координатную сетку, как и в случае с обычным графиком, достаточно вызвать функцию `grid()`:
```{r grid, collapse = TRUE, eval = FALSE}
grid()
```
```{r, ref.label=c("basetemp", "text", "grid"), echo = FALSE}
```

В то же время, вы можете управлять и шагом сетки и теми подписями координат, которые располагаются у выходов сетки вдоль осей. При ручном создании сетки и подписей осей необходимо при вызове первой инструкции `plot()` добавить параметр `axes = FALSE`.

## Экспорт изображения в графический файл

Для экспорта изображения в графический файл существует ряд функций типа `<format>(filename, width, height,...)`, где вместо `<format>` может быть один из форматов __pdf__, __png__, __jpg__, __tiff__, __bmp__. Растровые графические форматы __png__, __jpg__, __tiff__, __bmp__ удобны для экспорта единичных изображений. Если же необходимо эксопртировать серию изображений, то лучше остановить свой выбор на файлах формата PDF. Помимо этого, формат PDF необходим, если необходимо сохранить векторное представление соответствующих слоев данных.

Каждый раз, когда вы вызываете одну из вышеперечисленных функций, графическая подсистема R открывает новое "устройство" вывода, каким и является указанный в параметрах графический файл. После этого вы можете вызывать инструкции построения графиков и карт. 

> Чтобы завершить рисование в файл, необходимо вызвать функцию `dev.off()`, которая закрывает нестандартное устройство.

> Важно: при выводе в файл функцию par(), устанавливающую графические параметры, необходимо вызывать _после_ открытия устройства вывода. В противном случае параметры окажут свое влияние на стандартное устройство вывода

### Одностраничные файлы PNG

Например, чтобы экспортировать изображение размером $500 \times 500$ за март в файл __PNG__, можно написать следующий код:

```{r, collapse = TRUE}
png("October.png", width = 500, height = 500)
plot(rasters[[10]], 
       breaks = levels, 
       col = pal(nclasses), 
       legend.mar = 4.5, 
       legend.shrink = 1, 
       legend.width = 1.5, 
       legend.args = legendargs, 
       axis.args = axisargs,
       main = months[10]
  )
dev.off() # Важно: завершаем рисование в файл
```
```{r, purl=FALSE, echo = FALSE}
par(pin = c(5,5))
par(mar=c(2,5,2,5))
plot(rasters[[10]], 
       breaks = levels, 
       col = pal(nclasses), 
       legend.mar = 4.5, 
       legend.shrink = 1, 
       legend.width = 1.5, 
       legend.args = legendargs, 
       axis.args = axisargs,
       main = months[10]
  )
```

Или, например, экспортировать все изображения в один большой постер размером 30 на 40 сантиметров с разрешением 300 точек на дюйм:

```{r, collapse = TRUE}
png("Allmonths.png", width = 40, height = 30, units = "cm", res = 300)
par(mar=c(5,4,5,6))
par(mfrow = c(3,4))
for (i in 1:12){
  plot(rasters[[i]], 
       breaks = levels, 
       col = pal(nclasses), 
       legend.mar = 4.5, 
       legend.shrink = 1, 
       legend.width = 1.5, 
       legend.args = legendargs, 
       axis.args = axisargs,
       main = months[i]
  )
}
dev.off() # Важно: завершаем рисование в файл
```
```{r, collapse = TRUE, echo = FALSE, purl = FALSE}
par(pin = c(24,32))
par(mar = c(2,6,2,6))
par(mfrow = c(4,3))
for (i in 1:12){
  plot(rasters[[i]], 
       breaks = levels, 
       col = pal(nclasses), 
       legend.mar = 4.5, 
       legend.shrink = 1, 
       legend.width = 1.5, 
       legend.args = legendargs, 
       axis.args = axisargs,
       main = months[i]
  )
}
```

### Многостраничные файлы PDF

С файлами __PDF__ имеются некоторые нюансы, cвязанные с тем, что стандартное устройство `pdf()` может испытывать сложности с трансляцией кириллического текста. Зато таких сложностей не испытывает пакет Cairo, которым мы и воспользуемся. Работает __Cairo__ точно так же, как и другие функции экспорта:

```{r, collapse=TRUE, fig.width = 10, fig.height = 10}
# по умолчанию ширина и высота задаются в дюймах
CairoPDF("Results.pdf", width = 10, height = 10) 
par(mfrow=c(2,2))
par(mar=c(5,4,5,6))

for(i in 1:12){
  plot(rasters[[i]], 
       breaks = levels, 
       col=pal(nclasses), 
       legend.mar=4.5, 
       legend.shrink = 1, 
       legend.width = 1.5, 
       legend.args = legendargs, 
       axis.args = axisargs,
       axes = FALSE
  )
  
  # Далее повторим инструкции по выводу остальных слоев и подписей:
  plot(regions, border="black", add=TRUE, lwd=0.3)
  plot(rivers, col="midnightblue", add=TRUE, lwd=1)
  plot(lakes, col="steelblue1", add=TRUE, lwd=0.5)
  plot(cities, add=TRUE, pch=20)
  text(pts[,1], pts[,2], labels = cities$name_2, cex = 0.8, pos = 3)
  
  # Сделаем шаг по оси X равным 5 градусов, а по Y — 4 градуса
  xseq=seq(30,55,by=5)
  yseq=seq(46,60,by=4)
  
  # Сформируем подписи координат, включающие значок градуса:
  xlabels <- paste(xseq, "°", sep="")
  ylabels <- paste(yseq, "°", sep="")
  
  # Выведем на экран ось X и Y
  axis(1, at = xseq, labels = xlabels)
  axis(2, at = yseq, labels = ylabels)
  
  # Нанесем сетку вручную, используя функцию abline():
  
  abline(h=yseq, lty=3, col= "grey20")
  abline(v=xseq, lty=3, col= "grey20")
  
  # Нанесем заголовок карты
  title(main=months[i], sub="Среднемесячная температура")
  
  # Нанесем 
  box("plot", lwd=2)
}
dev.off() # Важно: завершаем рисование в файл
```

> Если вам необходимо построить географическую сетку непрямоугольного вида (для карт мира или континентов), то вам следует изучить возможности функции `gridlines()`

