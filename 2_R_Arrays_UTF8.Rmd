---
title: "Векторы и действия с ними"
abstract: "В это модуле мы познакомимся с векторами --- упорядоченными последовательностями объектов одного типа. Вектор является простейшей и одновременно базовой структурой данных в R. Понимание принципов работы с векторами необходимо для дальнейшего знакомства с более сложными структурами данных, такими как матрицы, таблицы, списки и массивы."
author: Тимофей Самсонов
date: "`r format(Sys.time(), '%d %B %Y')`"
tags: [R, типы данных, операции с данными, векторы]
version: 1.0
output: 
  html_document:
    toc: true
    toc_float: true
    theme: lumen
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Создание вектора

Вектор представляет собой упорядоченную последовательность объектов одного типа. То есть, вектор может состоять _только_ из чисел, _только_ из строк, _только_ из дат или _только_ из логических значений. Числовой вектор легко представить себе в виде набора цифр, выстроенных в ряд и пронумерованных согласно порядку их расстановки.

Существует множество способов создания векторов. Среди них наиболее употребительны:

1. Явное перечисление элементов
2. Создание пустого вектора ("болванки"), состоящего из заданного числа элементов
3. Генерация последовательности значений 

Для создания вектора путем __перечисления__ элементов используется функция `c()`:
```{r, collapse=TRUE}
# вектор из строк — цвета некоторых веток Московского метро
colors <- c("Красная", "Зеленая", "Синяя", "Коричневая", "Оранжевая")
colors
```

```{r, collapse=TRUE}
# вектор из чисел — длина веток в километрах (в той же последовательности)
lengths <- c(28, 40, 45, 19, 38)
lengths
```

```{r, collapse=TRUE}
# вектор из булевых переменных — наличие  открытых наземных участков (в той же последовательности)
opens <- c(FALSE, TRUE, TRUE, FALSE, FALSE)
opens
```

Помимо этого, распространены сценарии, когда вам нужно создать вектор, но заполнять его значениями вы будете по ходу выполнения программы --- скажем, при последовательной обработке строк таблицы. В этом случае вам известно только предполагаемое количество элементов вектора и их тип. Здесь лучше всего подойдет __создание пустого вектора__, которое выполняется функцией `vector()`. Функция принимает 2 параметра:

* `mode` отвечает за тип данных и может принимать значения равные `"logical"`, `"integer"`, `"numeric"` (или `"double"`), `"complex"`, `"character"` и `"raw"`
* `length` отвечает за количество элементов

Например:
```{r, collapse=TRUE}
# Вектор из 5 элементов, который предполагается заполнить целыми числами
intvalues <- vector(mode = "integer", length = 5)
intvalues # по умолчанию заполнен нулями

# Вектор из 10 элементов, который предполагается заполнить символьными данными (строками)
charvalues <- vector("character", 10)
charvalues # по умолчанию заполнен пустыми строками
```

Обратите внимание на то, что в первом случае подстановка параметров произведена в виде `параметр = значение`, а во втором указаны только значения. В данном примере оба способа эквивалентны. Однако первый способ безопаснее и понятнее. Если вы указываете только значения параметров, нужно помнить, что интерпретатор будет подставлять их именно в том порядке, в котором они перечислены в описании функции. 

> Описание функции можно посмотреть, набрав ее название в консоли ее название со знаком вопроса в качестве префикса. Например, для вышеуказанной функции надо набрать `?vector`

Наконец, третий распространенный способ создания векторов --- это __генерация последовательности__. Чтобы сформировать вектор из натуральных чисел от `M` до `N`, можно воспользоваться специальной конструкцией: `M:N`:
```{r, collapse=TRUE}
index <- 1:5 # эквивалентно c(1,2,3,4,5)
index
index <- 2:4 # эквивалентно c(2,3,4)
index
```

Существует и более общий способ создания последовательности --- функция `seq()`, которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом:
```{r, collapse=TRUE}
seq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы
seq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится)
seq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2
```

Как видно, параметры функции `seq()` можно комбинировать различными способами и указывать в произвольном порядке (при условии, что вы используете полную форму (`параметр = значение`). Главное, чтобы их совокупность _однозначно описывала последовательность_. Хотя, скажем, последний пример  убывающей последовательности нельзя признать удачным с точки зрения наглядности.

Аналогичным образом можно создавать _последовательности дат_:
```{r, collapse=TRUE}
seq(from = as.Date('2016/09/01'), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года

seq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня
```

## Работа с элементами вектора

К отдельным __элементам вектора__ можно обращаться по их индексам:
```{r, collapse=TRUE}
colors[1] # первый элемент вектора
colors[3] # третий элемент
```

__Количество элементов (длину) вектора__ можно узнать с помощью функции `length()`:
```{r, collapse=TRUE}
length(colors)
```

Последний элемент вектора можно извлечь, если мы знаем его длину:
```{r, collapse=TRUE}
n <- length(colors)
colors[n]
```

Последовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем:
```{r, collapse=TRUE}
lengths[1:4]
```

Индексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе:
```{r, collapse=TRUE}
m <- 1
n <- 4
index <- m:n
lengths[index]
```

Обратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например:
```{r, collapse=TRUE}
index <- c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка
lengths[index]

index <- c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке
lengths[index]
```

## Анализ и преобразования векторов

К числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда --- минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма:
```{r, collapse=TRUE}
min(lengths) # минимум
max(lengths) # максимум
range(lengths) # размах вариации = максимум - минимум
mean(lengths) # среднее арифметическое
median(lengths) # медиана
var(lengths) # дисперсия (по английски - вариация, variation)
sd(lengths) # среднеквадратическое отклонение (standard deviation)
sum(lengths) # сумма
```

Одной из мощнейших особенностей R является то что он не проводит различий между числами и векторами чисел. Поскольку R является матричным языком, каждое число представляется как вектор длиной 1 (или матрица $1х1$). Это означает, что любая математическая функция, применимая к числу, будет применима и к вектору:
```{r, collapse=TRUE}
lengths * 1000 # преобразуем длины линий в метры
sqrt(lengths) # квадратный корень из длины каждого элемента

stations <- c(20, 21, 22, 12, 24) # количество станций

dens <- stations / lengths # плотность станций по веткам метро = кол-во станций / длина 
dens
```

## Поиск и сортировка элементов

К важнейшим преобразованиям векторов относится их __сортировка__:
```{r, collapse=TRUE}
lengths2 <- sort(lengths) # сортировка по возрастанию значений
lengths2 # отсортированный вектор
lengths # сравним с исходным

lengths2 <- sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing
lengths2 # отсортированный вектор
lengths # сравним с исходным
```

Другая распространенная задача --- это __поиск индекса__ элемента по его значению. Например, вы хотите узнать, какая ветка Московского метро (среди рассматриваемых) является самой длинной. Вы, конечно, легко найдете ее длину с помощью функции `max(lengths)`. Однако это не поможет вам узнать ее название, поскольку оно находится в другом векторе, и его индекс в массиве неизвестен. Поскольку векторы упорядочены одинаково, нам достаточно узнать, под каким индексом в массиве `lengths` располагается максимальный элемент, и затем извлечь цвет линии метро под тем же самым индексом. Дл поиска индекса элемента используется функция `match()`:
```{r, collapse=TRUE}
l <- max(lengths) # находим максимальное значение
idx <- match(l, lengths) # находим индекс элемента, равного l, в списке lengths
color <- colors[idx] # извлекаем цвет ветки метро
color
```

Здесь непохо бы лишний раз потренироваться в конкатенации строк, чтобы вывести результат красиво!
```{r, collapse=TRUE}
s <- paste(color, "ветка Московского метро — самая длинная. Ее протяженность составляет", l, "км")
s
```

Ну и напоследок пример "матрешки"" из функций --- как найти название самой плотной линии одним выражением:
```{r, collapse=TRUE}
colors[match(max(dens),dens)]
```