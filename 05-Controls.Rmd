# Управление выполнением и векторизованные вычисления {#controls}

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
library(DT)
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_knit$set(root.dir = "data/")
```

[Программный код главы](https://github.com/tsamsonov/r-geo-course/blob/master/code/05-Controls.R)

Данный модуль посвящен введению в работу с управлением выполнением команд в R, а также методами их пакетного выполнения в виде векторизованных вычислений. Мы рассмотрим такие полезные конструкции как циклы, условия, функции, функции семейства `apply`. Вместе они представляют собой мощное средство для организации сложных технологических схем обработки данных, требующих повторения идентичных операций над каждым элементом множества входных данных, ветвления алгоритма в зависимости от значений переменных, а также структурирования программного кода на автономные блоки команд, выполняющие специфичный набор операций.

Мы рассмотрим управление командами на примере построения графиков.

## Циклы {#cycles}

Цикл --- это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В R циклы наиболее часто используются для пакетной обработки данных, ввода и вывода. Типичными примерами использования циклов являются чтение множества файлов входных данных, а также построение серий графиков и карт одного типа по различным данным. При этом обработка множества строк таблиц в R обычно организуется не средствами циклов, а средствами функций семейства [`lapply`](http://stat.ethz.ch/R-manual/R-devel/library/base/html/lapply.html), о которых мы поговорим отдельно.

В R, как и во многих других языках программирования, существует несколько вариантов циклов. Первый вид циклов — это конструкция __for__ с синтаксисом `for (x in X) statement`. Она означает, что:

- переменная `x` должна пробежать по всем элементам последовательности `X`. В качестве последовательности может выступать любой вектор или список.
- каждый раз, когда `x` будет присвоено значение очередного элемента из `X`, будет выполнено выражение `statement`, которое называют _телом цикла_. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности `X`. 

> Выполнение тела цикла на каждом проходе называют _итерацией_.

Например, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки:
```{r, collapse = TRUE}
## ЦИКЛЫ

for (i in 1:10) print(i)
```
Если тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки, иначе выполнится только первое выражение, а оставшиеся будут запущены один раз после выхода из цикла:

```{r, collapse = TRUE}
for (i in 1:10) {
  a <- factorial(i) # факториал i
  b <- exp(i) # e в степени i
  print(a/b) # факториал растет быстрее экспоненты
}
```
Другой вариант цикла организуется с помощью конструкции `while`, имеющей синтаксис `while (condition) statement`. Такая конструкция означает, что тело цикла будет выполняться, пока значение выражения `condition` (условия) равно `TRUE`. Как правило, в теле цикла обновляется некоторая переменная, которая участвует в проверке условия, и предполагается, что рано или поздно оно станет равным `FALSE`, что приведет к выходу из цикла. Например, вышеприведенный цикл, печатающий числа от 1 до 10, можно переписать на `while` следуюшим образом:
```{r, collapse = TRUE}
i <- 0
while(i < 10) {
  i <- i+1
  print(i)
}
```
Обратите внимание на то, что мы внутри цикла обновляем значение переменной i.

> Увеличение значения переменной цикла называется _инкрементом_, а уменьшение --- _декрементом_

Одной из самых распространенных ошибок программистов (особенно начинающих, но и професионалы ее не избегают) является забытая инструкция инкремента (или деккремента) переменной цикла, в результате чего цикл становится бесконечным. В этом плане конструкция `for` более надежна.

Перейдем теперь от искусственных примеров к реальной практике. В качестве исходных данных используем знакомую нам таблицу Росстата по доходам и расходам граждан:
```{r, collapse = TRUE}
library(openxlsx)

# Чтение данных

tab <- read.xlsx("IncomeConsumption.xlsx", 1)
filter <- grep("федеральный округ", tab$Регион)
okr <- tab[filter, ]

names <- sub("федеральный округ", "", okr$Регион)

filter<-grepl("федеральный округ|Федерация|числе", tab$Регион)
sub <- tab[!filter, ]
```

Например, посмотрим как можно построить столбчатые диаграммы по каждому столбцу таблицы `okr`:
```{r, collapse = TRUE}
# Пакетное рисование графиков
for(var in colnames(okr)[-1]) {
  par(mar = c(5,9,4,2))
  barplot(okr[,var], 
          names.arg = names, 
          horiz = TRUE, 
          las = 1, 
          main = var,
          col = "steelblue")
}
```

А теперь усложним тело цикла, добавив рисование гистограммы распределения по тому же показателю, но взятому из таблицы `sub`:
```{r, collapse = TRUE}
# Пакетное рисование графиков
par(mfrow = c(1,2))
options(scipen = 999) # запрещаем использовать экспоненциальную форму записи больших чисел

for(var in colnames(okr)[-1]) {
  par(mar = c(5,9,4,3)) # устанавливаем поля для столбчатой диаграммы
  barplot(okr[,var], 
          names.arg = names, 
          horiz = TRUE, 
          las = 1, 
          main = var, 
          xlab = "По федеральным округам",
          col = "steelblue")
  par(mar = c(5,3,4,1)) # устанавливаем поля для гистограммы
  hist(sub[,var], breaks = 12, col="green", main = var, xlab = "По субъектам")
}
```

## Условия {#ifelse}

Проверка условий позволяет осуществлять так называемое ветвление в программе. Ветвление означает, что при определенных условиях (значениях переменных) будет выполнен один программный код, а при других условиях --- другой. В R для проверки условий используется условный оператор __if --- else if --- else__ следующего вида:
```
if (condition) {
  statement1
} else if (condition) {
  statement2
} else {
  statement3
}
```

Сначала проверяется условие в выражении `if (condition)`, и если оно истинно, то выполнится вложенный в фигурные скобки программный код `statement1`, после чего оставшиеся условия не будут проверяться. Если первое условие ложно, программа перейдет к проверке следующего условия `else if (condition)`. Далее, если оно истинно, то выполнится вложенный код `statement2`, если нет --- проверка переключится на следующее условие и так далее. Заключительный код `statement3`, следующий за словом `else`, выполнится только если ложными окажутся все предыдущие условия. 

> Конструкций `else if` может быть произвольное количество, конструкции `if` и `else` могут встречаться в условном операторе только один раз, в начале и конце соответственно. При этом условный оператор может состоять только из конструкции `if`, а `else if` и `else` не являются обязательными.

Например, используя вышеприведенный код с вычислением экспоненты и факториала, можно вывести на экран информацию о том, больше ли экспонента чем факториал на данной итерации цикла:

```{r, collapse = TRUE}
## УСЛОВИЯ

for (i in 1:10){
  a <- factorial(i) # факториал i
  b <- exp(i) # e в степени i
  ratio <- a/b # вычисляем отношение экспоненты и факториала
  
  if (ratio < 1){ # если экспонента больше, то...
    cat(i,'! < exp(', i, ')\n', sep = '')
  } else { # в противном случае
    cat(i,'! > exp(', i, ')\n', sep = '')
  }
}
```

Теперь рассмотрим более практическую задачу. В нашем распоряжении имеются данные по среднеклиматическим (за последние 50 лет) температурам на территории юга Европейской части России с разрешением $30''$ (около 1 км), полученные с портала [WorldClim](http://www.worldclim.org). Необходимо построить гистограммы распределения температур по месяцам года, раскрасив их в различные цвета соответственно среднему значению температуры:

- Если средняя температура ниже $0^\circ C$, то цвет гистограммы синий
- Если средняя температура от $0^\circ C$ до $10^\circ C$, то цвет гистограммы желтый
- Если средняя температура выше $10^\circ C$, то цвет гистограммы оранжевый


```{r, collapse = TRUE}
# ПАКЕТНОЕ ЧТЕНИЕ ДАННЫХ

library(foreign) # для чтения dbf необходима библиотека foreign

files <- list.files("dbf") # прочитаем список файлов в директории dbf

files <- files[grep(".dbf", files, fixed = TRUE)] # отфильтруем файлы с расширением .dbf

names <- sub(".dbf","",files) # получим названия месяцев, избавившись от расширений

i <- 1 # Создадим дополнительно переменную цикла, чтобы выбирать i-е название месяца

for (file in files){ # пройдемся по всем файлам
  
  temp <- read.dbf(paste("dbf/", file, sep='')) # прочитаем текущий файл
  
  tmean <- mean(temp$Temp) # вычислим среднюю температуру из столбца Temp
  
  hist.col <- "white" # иницилизируем переменную цвета за пределами условия 
  
  # Проверим наше условие
  if (tmean < 0){ 
    hist.col <- "steelblue"
  } else if (tmean < 10){
    hist.col <- "yellow"
  } else {
    hist.col <- "orange"
  }
  
  # Построим гистограмму
  hist(temp$Temp, 
       col = hist.col, 
       main = names[i]) # Вот здесь нам нужна дополнительная переменная цикла
  
  # Нанесем линию среднего значения
  abline(v = tmean, 
         lwd = 2, 
         col = "red") 
  
  # Подпишем среднюю температуру
  text(tmean, 
       1000, 
       labels = round(tmean,1), 
       pos = 4, 
       col = "red")
  
  i <- i + 1 # Не забудем сделать инкремент переменной цикла
}

```

## Функции {#functions}

Функции в R можно использовать для структурирования кода на логически завершенные, автономные фрагменты кода, каждый из которых выполняет конкретную задачу. Чем сильнее разрастается ваш программный код, тем больше проявляется потребность в наличии функций. Функции позволяют использовать один и тот же код в разных местах программы, не повторяя его.

Синтаксис функции выглядит следующим образом:
```
functionName <- function(parameter1, parameter2, ...){
  ...
  return(result)
}
```

Функция создается c помощью ключевого слова `function`, за которым в круглых скобках заключается произвольное количество параметров (столько, сколько вам нужно: от нуля и более). С помощью этих параметров вы сможете передавать внутрь функции значения переменных. Созданной функции необходимо дать имя, используя оператор присвоения `<-`. После того как выполнится код внутри функции, результат можно вернуть, используя ключевого слово `return`.

> __R__ не поддерживает возврат множественных результатов. Если вам необходимо вернуть несколько объектов (переменных, векторов, таблиц и т.д.), создайте список (list), включите в него все возвращаемые объекты и верните из функции этот список.  

В вышеприведенном примере мы использовали проверку условия для того чтобы вычислить рекомендуемый цвет гистограммы. С одной стороны, это некая вспомогательная процедура, не имеющая непосредственного отношения к построению гистограммы. С другой стороны, это полезная процедура, которой мы захотим воспользоваться в дальнейшем --- всегда приятно, когда программа тебе с выбором стилей оформления данных^[в картографии это называется "smart mapping", что переводят как "умное картографирование", хотя это и не самый удачный вариант перевода].

Оформим выбор цвета в виде функции, которая принимает в каестве параметра число (температуру), а возвращает название цвета.

```{r, collapse = TRUE}
## ФУНКЦИИ

# Создадим функцию, возвращающую цвет в зависимости от температуры
selectColor <- function(value) { 
  hist.col <- "white"
  if (tmean < 0){
    hist.col <- "steelblue"
  } else if (tmean < 10){
    hist.col <- "yellow"
  } else {
    hist.col <- "orange"
  }
  return(hist.col)
}

i <- 1
par(mfrow = c(2,2))

for (file in files) {
  temp <-  read.dbf(file)
  tmean <-  mean(temp$Temp)
  
  # выберем цвет с помощью нашей функции
  hist.col <- selectColor(tmean)
  
  # построим гистограмму
  hist(temp$Temp, 
       col = hist.col, 
       main = names[i])
  
  # добавим линию среднего
  abline(v = tmean, 
         lwd = 2, 
         col = "red")
  
  # подпишем среднее
  text(tmean, 
       1000, 
       labels = round(tmean,1), 
       pos = 4, 
       col = "red")
  i <- i+1
}
```

Усложним задачу, чтобы показать, как работать с несколькими аргументами функции. Например, мы хотим не одноцветные диаграммы, а чтобы цвет менялся плавным градиентом от первого столбика гистограммы до последнего. Соответственно, количество возвращаемых цветов должно быть равно количеству столбиков в гистограмме. Нашей функции не важно, столбики это или нет, но ей надо знать, сколько цветов надо вернуть. Для этого добавим в нее второй параметр `ncolors`. Это позволит пользователю при желании не задвать этот параметр, если необходим только один цвет.
```{r, collapse = TRUE}
# ГИСТОГРАММЫ С ГРАДИЕНТОМ

selectColor2 <- function(value, ncolors){ # передаем в качестве дополнительного параметра количество цветов
  hist.col <- "white"
  # генерируем ncolors цветов из соответствующей палитры
  if (tmean < 0){
    hist.col <- colorRampPalette(c("darkslateblue", "steelblue1"))(ncolors)  
  } else if (tmean < 10){
    hist.col <- colorRampPalette(c("steelblue1", "yellow"))(ncolors)
  } else {
    hist.col <- colorRampPalette(c("yellow", "red"))(ncolors)
  }
  return(hist.col)
}

i <- 1

par(mfrow = c(2,2))

ncells <- 25 # установим фиксированное количество столбцов гистограммы

for (file in files){
  temp <- read.dbf(file)
  tmean <- mean(temp$Temp)
  
  # получим для раскраски требуемое количество цветов
  hist.col <- selectColor2(tmean, ncells)
  
  # построим гистограмму
  hist(temp$Temp, 
       col = hist.col, 
       main = names[i], 
       breaks = ncells)
  
  # добавим линию среднего
  abline(v = tmean, 
         lwd = 2, 
         col = "red")
  
  # подпишем среднее
  text(tmean, 1000, 
       labels = round(tmean,1), 
       pos = 4, 
       col = "red")
  
  i <- i+1
}
```

## Векторизованые вычисления {#vectorized}

Данные (в том числе географические) практически всегда носят множественный характер и организованы в определенные структуры (см. главу 2). Эта особенность данных выдвигает логичное желание иметь процедуры, которые можно применять к полному набору данных, а не к его отдельным компонентам. Это и есть процедуры векторизованных высчислений. 

Предположим, вам необходимо что-то вычислить для каждой строки таблицы, при этом порядок вычисления зависит от содержимого ячеек данной строки. Вы можете организовать подобные вычисления с помощью циклов, однако в __R__ существуют специальные функции семейста `apply`, которые позволяют решать подобные задачи более элегантно и с высокой скоростью. Это достигается за счет того, что функции `apply` написаны на языке __C__ (как и многие другие функции __R__), в то время как при организации цикла ваши данные будут обрабатываться стандартными средствами языка.

 Функция | Назначение  
---------|--------------------------------------------------------------
`apply()`   | применить функцию ко всем строкам или столбцам матрицы
`lapply()`  | применить функцию к каждому компоненту вектора или списка и получить результат также в виде списка (_l --- list_)
`sapply()`  | применить функцию к каждому компоненту вектора или списка и получить результат в виде вектора (_s --- simplify_)
`vapply()`  | аналогична vapply, но требует явного задания типа данных возвращаемого вектора, за счет чего работает быстрее (_v --- velocity_)
`mapply()`  | применить функцию к каждому компоненту нескольких векторов или списков и вернуть результат в виде списка (_m --- multivariate_)
`rapply()`  | применить функцию рекурсивно ко всем элементам переданного списка и вернуть результат в аналогичной структур (_r --- recursive_)
`tapply()`  | применить функцию ко всем компонентам вектора или списка, сгруппировав их по значению переданного фактора

> Функции семейства `apply`, принимающие на вход списки, могут работать и с фреймами данных. В этом случае фрейм внутри функции будет преобразован с помощью функции `as.list()` в список, элементами которого являются столбцы (переменные) входного фрейма данных. Данные при этом не потеряются, их типы тоже не изменятся.

Базовая функция `apply()` имеет следующие аргументы:

- `X` --- массив любой размерности (включая вектор)
- `MARGIN` --- измерения по которым необходимо вести вычисления. Для матрицы `1` означает строку, `2` означает столбец, `c(1, 2)` будет означать, что вычисления производятся по всем комбинациям строк и столбцов
- `FUN` --- функция, которая будет применяться к каждому элементу указанных измерений

Рассмотрим, как можно вычислять значения по строкам. У нас есть подготовленная таблица Росстата [Выбросы в атмосферу загрязняющих веществ, отходящих от стационарных источников, по видам экономической деятельности](http://www.gks.ru/free_doc/new_site/oxrana/tabl/oxr_vibr3.xls). Рассчитаем, какой тип источника занимает максимальное и минимальное место среди газообразных и жидких. Обратите внимание, что в первом случае используется заранее созданнаф функция, а во втором мы определяем анонимную функцию непосредственно при вызове `apply()`:
```{r, collapse=TRUE}
## ВЕКТОРИЗОВАННЫЕ ВЫЧИСЛЕНИЯ 

library(dplyr)
df <- read.csv2("atm_emissions.csv")
head(df)

find.max <- function(x) {
  return(names(x)[which.max(x)])
}

df$MAXSRC <- apply(df[5:9], 1, find.max)
df$MINSRC <- apply(df[5:9], 1, function(x) names(x)[which.min(x)])

print(df)
```

Другие функции семейства `apply` в приложении к фреймам данных будут работать со столбцами (переменными), интерпретируя их как элементы списка. Наиболее часто из них используются `lapply()`, `sapply()` и `vapply()`.В отличие от `apply()`, они уже не принимаеют номера измерений и работают только с элементами переданного списка. Например, мы можем посчитать среднее значение экономического показателя по каждой переменной в таблице округов. Поскольку функция среднего уже есть в составе базовых средств `R`, достаточно указать ее при вызове `sapply()`:
```{r, collapse = TRUE}
sapply(okr, mean)
```
В данном случае для первого столбца было возвращено значение `NA`, что логично, поскольку он имеет строковый тип.

В качестве альтернативы функциям `apply` можно также воспользоваться вычислениями посредством функций семейства `map` из пакета `purrr` (еще один пакет из [tidyverse](https://www.tidyverse.org/packages/)). Эти функции работают аналогично `lapply()` и поддерживают последовательности с помощью пайп-оператора:

- `map()` возвращает список.
- `map_lgl()` возвращает вектор логических значений.
- `map_int()` возвращает вектор целочисленных значений.
- `map_dbl()` возвращает вектор чисел с плавающей точкой.
- `map_chr()` возвращает вектор строк.

Например, предыдущая задача с помощью `purrr` решались бы так:
```{r, collapse=TRUE}
library(purrr)
map_dbl(okr, mean)
```

## Контрольные вопросы и задачи {#questions_tasks_controls}

1. Что такое цикл и для каких сценариев обработки данных могут быть полезны циклы?
1. Перечислите несколько способов организации циклов в __R__, необходимые ключевые слова и параметры.
1. Что такое инкремент и декремент?
1. Какое ключевое слово позволяет прервать цикл и выйти из него принудительно?
1. Какое ключевое слово позволяет прекратить текущую итерацию цикла и перейти сразу к новой итерации?
1. Являются ли необходимыми фигурные скобки в случае когда цикл или условный оператор содержит только одно выражение? Что говорит об этом стиль программирования на __R__?
1. Что такое условный оператор и для каких сценариев обработки данных необходимы условные операторы?
1. Перечислите ключевые слова, которые могут быть использованы для организации условных операторов
1. Что такое функция и для каких сценариев обработки данных могут быть полезны функции?
1. Может ли функция возвращать более одного значения? Что необходимо сделать, чтобы реализовать такую возможность?
1. Что такое векторизованные вычисления?
1. Перечислите функции семейства `apply` и задачи, которые они позволяют решить.
1. Какая функция семейства `apply` позволяет выполнять вычисления не только по столбцам, но и по строкам?
1. Можно ли передавать в функции семейства `apply` фреймы данных? Если да, то как интерпретируются такие данные? 
1. Какой пакет __R__ позволяет выполнять векторизованные вычисления в более простой и быстрой форме, чем функции семейства `apply`? Можно ли с помощью него выполнять вычисления по строкам?

### Вопросы {#questions_controls}

### Задачи {#tasks_controls}

----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----
