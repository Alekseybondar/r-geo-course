# Пространственный анализ 1. Векторные методы {#vector_analysis}

Данный модуль посвящен пространственному анализу в R. Несмотря на то, что пространственный анализ — чрезвычайно широкая и многогранная область геоинформатики, все методы, которые объединяются под этим заголовком, базируются на ограниченном числе базовых операций, таких как вычисление расстояний, оценка плотности распределения, построение буферных зон и выполнение пространственных запросов. В настоящем модуле мы рассмотрим, как одно и то же множество пространственных объектов можно анализировать в различных контекстах, используя базовые методы пространственного анализа

## Введение

Пространственный анализ связан с оценкой _размещения_ объектов и _распределения_ величин в географическом пространстве. В геоинформатике для этих целей используется два подхода: геометрический и статистический. Эти подходы образуют две ступени пространственного анализа: как правило, данные геометрического анализа представляют собой входную информацию для анализа статистического.

Геометрический подход связан с вычислением расстояний между географическими локациями, а также агрегированием объектов/интегрированием показателей в пределах заданных областей, вдоль линий или в окрестности точек. Поиск входной информации для агрегирования решается путем выполнения _пространственных запросов_.

## Пространственные запросы

__Пространственные запросы__ связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве пространственных отношений. В свою очередь, пространственные отношения бывают трех типов: _дирекционные_ (направления), _метрические_ (расстояния) и _топологические_ (взаимное размещение). Примеры пространственных запросов знакомы любому географу:

* Найти все объекты внутри административного района (топологические отношения)
* Найти все объекты не далее 100 метров от дороги (метрические отношения)
* Найти все объекты, расположенные к северу от точки (дирекционные отношения) 

Пространственные запросы могут объединять несколько условий. Можно найти объекты, удовлетворящие одновременно _всем_ (_логическое И_) вышеперечисленным условиям: внутри района, не далее 100 м от дороги и к северу от выбранной точки; или _хотя бы одному_ (_логическое ИЛИ_) из вышеперечисленных условий. Результат выполнения такого комплексного запроса будет являться, соотвественно, пересечением множеств объектов, полученных каждым из запросов, или их объединением.

Наконец, пространственные запросы можно объединять с _атрибутивными_ и _временными_. Атрибутивные запросы связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве характеристик объектов. Временные запросы определены на множестве шкалы времени. Например, можно найти все населенные пункты населением свыше 10 000 человек (атрибутивный запрос), находящиеся в пределах выбранного административного района (пространственный запрос, основанный на топологических отношениях), время движения от которых до районного центра не превышает 90 минут (временной запрос).

### Контекстные и целевые объекты

При выполнении пространственного анализа, в общем случае, имееются множества объектов двух типов:

* __контекстные__ --- объекты, относительно которых будет оцениваться размещение других объектов, то есть, определяющие _контекст анализа_
* __целевые__ --- объекты, размещение которых анализируется по отношению к контекстным объектам, что является _целью_ анализа

Эти множества, разумеется, могут совпадать. Скажем, мы можем проанализировать размещение магазинов относительно других магазинов.

### Зоны окружения объектов

Весьма часто в качестве контекстного множества используются не реальные пространственные объекты, а набор абстрактных геометрических объектов, каждый из которых является производным от оригинального пространственного объекта. Как правило, такие геометрии представляют из себя _зоны окружения_ объектов, построенные по некоторому формальному признаку.

Методы построения зон окружения можно разделить по двум критериям: учету взаимного размещения объектов (абсолютные и конкурентные зоны) и пространству признаков, в котором эти зоны строятся.

Если зоны окружения строятся без учета взаимного размещения объектов, то есть, независимо для каждого объекта, то мы будем называть их абсолютными. Абсолютные зоны окружения строятся путем фиксации порогового расстояния либо времени движения относительно исходного объекта. Такие зоны носят название буферных зон (по расстоянию) или зон доступности (по времени). Границей абсолютной зоны окружения является изолиния, построенная по соответствующему показателю. В случае времени это будет _изохрона_. Примеры абсолютных зон окружения:

* Водоохранная зона реки 200 метров (буферная зона)
* Площадь городской территории, в любую точку которой вы можете доехать из дома на машине в течение 30 минут (зона доступности)

Если же при построении зон окружения учитывается взаимное размещение объектов, то в данном случае зоны доступности строятся не исходя из порогового значения показателя (хотя оно может использоваться дополнительно), а исходя из того, какой объект является ближайшим. Конкурентные зоны окружения представляют собой [разбиение](https://ru.wikipedia.org/wiki/Разбиение_множества) пространства на неперекрывающиеся участки без дыр, каждый из которых является зоной окружения соответствующего пространственного объекта. При этом любая точка внутри зоны окружения объекта ближе к этому объекту по выбранному признаку (времени или расстоянию), нежели к любому другому объекту. Конкурентные зоны окружения, построенные по расстоянию, можно реализовать средствами [диаграммы Вороного](https://ru.wikipedia.org/wiki/Диаграмма_Вороного).

## Постановка задач и изучение данных

В настоящем моделе мы рассмотрим вышеперечисленные методы на примере анализа размещения пунктов общественного питания --- кафе, ресторанов и т.д. Используя методы пространственного анализа в среде R, мы ответим на следующие вопросы:

* Какие улицы являются местами наибольшей концентрации заведений общественного питания?
* Как распределены заведения общественного питания по районам центра Москвы?
* Какие заведения общественного питания находятся вблизи метро и на берегу реки?
* В какие заведения общественного питания можно доехать от выбранной точки в течение 5 минут?
* Каков оптимальный маршрут между вашим местоположением и заведением, в котором вы хотите пообедать?

В качестве источника данных используем [OpenStreetMap](http://www.openstreetmap.org) --- краудсорсинговый интернет-проект по созданию бесплатных и открытых пространственных данных глобального охвата. Данные OpenStreetMap в удобном для использования в ГИС виде доступны на [портале GIS-Lab](http://beryllium.gis-lab.info/project/osmshp/).

Для решения задач настоящего модуля нам понадобятся следующие дополнительные пакеты, которые мы не использовали ранее:

* [rgeos](https://cran.r-project.org/web/packages/rgeos/index.html) --- пространственные запросы и геометрические операции, в том числе построение буферных зон.
* [deldir](https://cran.r-project.org/web/packages/deldir/index.html) --- построение триангуляции Делоне и диаграммы Вороного.
* [osrm](https://cran.r-project.org/web/packages/osrm/index.html) --- построение зон доступности, маршрутов и матриц корреспонденции онлайн на основе данных OpenStreetMap и [OSRM API](http://project-osrm.org).
* [cartography](https://cran.r-project.org/web/packages/cartography/index.html) --- пакет, облегчающий построение тематических карт и легенд средствами стандартной функции `plot()`.

Начнем наше исследование с визуального анализа исходных данных
```{r, message = FALSE, results = "hide", collapse=TRUE}
library(sp)
library(rgdal)
library(classInt)
library(rgeos) # Геометрические операции
library(osrm) # Использование онлайн-сервиса маршрутизации OSRM
library(cartography) # Удобное построение карт средствами plot()
library(deldir) # Триангуляция Делоне и диаграмма Вороного

# Устанавливаем рабочую директорию
setwd("/Volumes/Dropbox/Dropbox/R/Lectures/Scripts/RMarkdown/data/9_R_SpatialAnalysis")

# Чтение данных
roads <- readOGR(".", "roads") # Дороги
poi <- readOGR(".", "poi_point") # Точки интереса
rayons <- readOGR(".", "boundary_polygon") # Границы районов
stations <- readOGR(".", "metro_stations") # Станции метро
water <- readOGR(".", "water_polygon") # Водные объекты

# Прочитаем текущие параметры компоновки
def <- par(no.readonly = TRUE)

# Уберем поля, чтобы карта занимала весь экран
par(mar = c(0,0,0,0))

# Получим ограничивающий прямоугольник слоя дорог в качестве общего охвата карты
frame <- gEnvelope(roads)

# Визуализируем входные данные
plot(frame)
plot(water, 
     col = "lightskyblue1",
     border = "lightskyblue3",
     add = TRUE)
plot(roads,
     col = "gray70", 
     add = TRUE)
plot(poi, 
     col = "deepskyblue4", 
     pch = 20, 
     cex = 0.2, 
     add = TRUE)
```

Теперь приступим к изучению данных, хранящихся в слое `poi` (от англ. POI --- Point Of Interest). Данный слой содержит все точечные маркеры OSM, которыми были отмечены на карте объекты, представляющие (по мнению создателей данных) интерес для пользователей. В POI включаются самые разнообразные объекты, такие как: объекты сферы услуг (amenity), места для отдыха (leisure), офисные здания (office), магазины и торговые центры (shop), туристические достопримечательности (tourism), спортивные объекты (sport), примечательные инженерные сооружения (man_made). В наших данных информация разнесена по соответствующим полям, каждый объект снабжен уникальным идентификатором:
```{r, collapse = TRUE, eval=FALSE}
View(poi)
```
```{r, echo = FALSE, purl = FALSE}
datatable(poi@data, options = list(pageLength = 10, scrollX = TRUE))
```

Заведения общественного питания по классификатору OSM относятся к классу amenity. Поскольку данный классификатор представляет собой множество номинальных (категориальных) данных, можно начать изучение состава данных с помощью таблицы частот, которая строится средствами функции `table()`:
```{r, collapse = TRUE}
stats <- data.frame(table(poi$AMENITY))
View(stats)
```
```{r, echo = FALSE, purl = FALSE}
datatable(stats, options = list(pageLength = 10, scrollX = TRUE))
```

Для дальнейшего анализа отберем из всего множества объектов сферы услуг заведения, где можно поесть: рестораны, кафе, бары, пабы и заведения быстрого питания (фастфуд). В классификаторе OSM эти заведения имеют тип _restaurant_, _bar_, _cafe_, _pub_ и _fast\_food_. Для отбора используем два нововведения, ранее нами не применявшихся: 

* функция `subset()` --- аналог фильтра для таблиц данных. С ее помощью можно фильтровать данные в более ясном виде. В первом параметре функции используется таблица данных, во втором --- определяющий запрос, в параметре `select` --- столбцы, которые необходимо оставить в результате.
* оператор `%in%` --- используется для проверки вхождения в множество, т.е. когда нужно выбрать все объекты, совпадающие с одним из нескольких образцов.

```{r, collapse=TRUE}
poi.food <- subset(poi, 
                   AMENITY %in% c("restaurant", "bar", "cafe", "pub", "fast_food"),
                   select = c(NAME, AMENITY))
```

## Анализ расстояний

Метрические отношения связывают объекты в терминах расстояний между ними. Предположим, что мы хотим определить улицы, являющиеся сосредоточением заведений питания. Один из вариантов решения состоит в том, чтобы для каждого пункта обслуживания определить ближайшую к нему улицу и далее для каждой улицы просуммировать количество раз, которое улиц оказалось ближайшей. Подробнее алгоритм решения выглядит следующим образом:

1. Вычислить матрицу расстояний между пунктами обслуживания и улицами. Размер матрицы $M \times N$, где $M$ --- количество улиц (строк), $N$ --- количество пунктов (столбцов)
2. Найти в каждом столбце минимальное расстояние.
3. Получить идентификатор улицы (номер строки), соответствующий данному расстоянию.
4. Записать идентификатор в выходной вектор.

Таким образом, мы получим вектор из идентификаторов улиц, при этом каждый идентификатор будет встречаться в этом векторе столько раз, сколько раз данная улица оказалась ближайшей к какому-то объекту.

Вычислим матрицу расстояний с помощью функции `gDistance()` из пакета `rgeos()`:

```{r, collapse=TRUE}
dist.matrix <- gDistance(poi.food, roads, byid = TRUE)

# посмотрим, как выглядит результат на примере первых пяти объектов
View(dist.matrix[1:5,1:5]) 
```
```{r, echo = FALSE, purl = FALSE}
datatable(dist.matrix[1:5,1:5], options = list(pageLength = 5, scrollX = TRUE))
```

Далее необходимо в каждом столбце матрицы найти идентификатор строки с минимальным расстоянием. Для этого необходимо получить вектор названий строк, отсортировать его в порядке увеличения значений выбранного столбца, и далее из этого вектора извлечь первый элемент. Например, для 5-го столбца эта операция будет выглядеть так:
```{r, collapse=TRUE}
row.names(dist.matrix)[order(dist.matrix[, 5])][1]
```

Чтобы было понятнее, разобьем эту операцию на 3 элемента:

* `row.names(dist.matrix)` --- получаем названия строк
* `[order(dist.matrix[, 5])]` --- сортируем их в порядке увеличения значений в 5-м столбце матрицы
* `[1]` --- извлекаем первый элемент

Решив задачу для одного столбца, можно полученное решение легко распространить на все оставшиеся, используя цикл `for`:
```{r, eval = FALSE}
n <- ncol(dist.matrix)
ids <- vector("character", length = n)
for (i in 1:n){
  ids[i] <- row.names(dist.matrix)[order(dist.matrix[, i])][1]
}
```

Однако такое решение будет вычислительно неэффективным. К сожалению, циклы в R работают очень медленно и годятся для итерации небольшого количества объектов (единицы, десятки, сотни). У нас же матрица имеет более 1000 столбцов, и для ее эффективной циклической обработки предпочтительно использовать функции семейтва `apply()`. 

[Функции семейcтва `apply`](https://stat.ethz.ch/R-manual/R-devel/library/base/html/apply.html) используются, когда необходимо пройтись по всем элементам вектора или матрицы и применить к каждому некоторую произвольную функцию обработки. Функция `apply()` позволяет обрабатывать и матрицы и произвольные массивы данных. Функции `lapply()` и `sapply()` применяются к векторам.

Для запуска функции `apply()` необходимо указать три ее аргумента:

* X --- матрица или массив
* MARGIN --- измерение, по которому необходимо производить циклическую обработку. Для матриц значение 1 означает, что будут обрабатываться строки, 2 --- столбцы
* FUN --- функция, в которую будет передаваться каждый элемент выбранного измерения (строка или столбец для матрицы)

Переписать предыдущий цикл в терминах функции `apply()` можно следующим образом:
```{r, collapse=TRUE}
ids <- apply(
    dist.matrix, 2, function(X) {
      row.names(dist.matrix)[order(X)][1]
    }
)
```

Обратите внимание на особенности задания функции в качестве третьего аргумента. Во-первых, это безымянная функция (это допустимо, если она определяется непосредственно при вызове `apply()`). Во вторых, эта функция содержит некий параметр `X`. В этот параметр как раз и будет подставляться текущий элемент измерения.

Теперь применим уже знакомую нам функцию `table()`, чтобы подсчитать, сколько раз каждая улица оказалась наиболее близкой. Далее присоединим статистику к исходным улицам, однако для этого нам потребуется вынести названия строк (идентификаторов) улиц в отдельный столбец.

```{r, collapse=TRUE}
count.stats <- as.data.frame(table(ids))
roads$id <- row.names(roads)
merged.data <- merge(roads, 
                     count.stats, 
                     by.x = 'id', 
                     by.y = 'ids', 
                     all.x = T)
```

Для завершения анализа осталось визуализировать результаты. Чтобы усилить наглядность визуализации, мы не будем каждую улицу утолщать пропорционально количеству привязанных объектов, а разделим это количество на 4 класса. Каждый класс покажем линией соответствующей толщины и интенсивности цвета (чем больше объектов привязано к улице, тем толще линия, темнее и насыщеннее ее цвет). 

Для классификации используем функцию `cut()`, позволяющую перекодировать интервальные данные в номинальные, то есть сопоставить каждому элементу вектора некий класс, которому он принадлежит. На выходе будем иметь вектор, который состоит из такого же количества элементов, что и исходный, но вместо исходных значений будут стоять названия классов.

```{r, collapse=TRUE}
# Получим границы классов
nclasses <- 4
class.breaks <- classIntervals(merged.data$Freq, 
                               n = nclasses, 
                               style = "jenks")
# Извлечем граничные интервалы
borders <- class.breaks$brks

# Названия классов — они же толщины линия от 1 до 4
line.widths <- 1:nclasses

# Перекодируем столбец количества присоединенных пунктов в классы
sizes <- cut(merged.data$Freq, 
             breaks = borders, 
             labels = line.widths)
```

Теперь присвоим каждому объекту свой цвет в соответствии с классом, который ему присвоен. Удобная функция `findColours()` позволяет найти цвет для каждого объекта в соответствии с полученной классификацией:

```{r, collapse=TRUE}
base.colors <- c("mistyrose", "red")

ramp <- colorRampPalette(base.colors)

colors <- findColours(class.breaks, base.colors)
```

Визуализируем результат:
```{r, collapse=TRUE}
plot(frame)

plot(water, 
     col = "lightskyblue1",
     border = "lightskyblue3",
     add = TRUE)

plot(roads,
     col = "gray70",
     add = TRUE)

plot(merged.data,
     lwd = sizes, 
     col = colors,
     add = TRUE)

plot(poi.food, 
     col = "deepskyblue4", 
     pch = 20, 
     cex = 0.2, 
     add = TRUE)

# Функция legendGradLines из пакета cartography позволяет строить
# легенду для карт линий градуированных размеров:
legendGradLines(title.txt = "Пункты питания", 
                pos = "left",
                title.cex = 0.8,
                values.cex = 0.6, 
                breaks = borders,
                lwd = line.widths,
                col = "red")
# Статистика по улицам в табличном представлении (первые 10)
View(merged.data[order(merged.data$Freq, decreasing = TRUE),][1:10,c("NAME", "Freq")])
```
```{r, echo = FALSE, purl = FALSE}
datatable(merged.data[order(merged.data$Freq, decreasing = TRUE),]@data[1:10,c("NAME", "Freq")], options = list(pageLength = 10, scrollX = TRUE))
```

## Анализ взаимного положения (топологический)

Пространственные запросы, основанные на топологических отношениях, позволяют находить объекты, находящиеся внутри других объектов, соприкасающиеся с другими объектами, пересекающиеся с ними и так далее. Топологические отношения сохраняются при взаимно-однозначных и непрерывных преобразованиях плоскости. 

Отличия от метрических отношений легко пояснить на примере преобразования проекции. Представьте, что карту России в [конической проекции](http://geocnt.geonet.ru/projections/html/viewer.html) с концентрическими параллелями (известную по учебникам и атласам)  вы трансформировали в карту России в проекции Меркатора (такую же как на [Google Maps](https://www.google.ru/maps/place/Россия/)). Изогнутые параллели превратились в прямые линии; форма регионов, площади и расстояния между населенными пунктами значительно изменились. Однако Красноярск по-прежнему находится в Красноярском крае, Ярославль --- на реке Волге, Нижний Новгород --- на правом берегу Волги, озеро Белое --- внутри Вологодской области, а Московская область как не граничила с Тамбовской, так и не граничит после трансформации проекции. Это и есть топологические отношения.

Формально топологические отношения в ГИС описываются с помощью [модели девяти пересечений DE-9IM](https://en.wikipedia.org/wiki/DE-9IM).

В этой части лекции мы посмотрим, как можно определить концентрацию объектов по районам, используя топологическое отношение "Содержит" (contains). Для этого мы будем использовать функцию `gContains(A, B)` из пакета `rgeos`, которая возвращает матрицу логических значений, в которой на пересечении $i$-й строки и $j$-го столбца стоит `TRUE` или `FALSE` в зависимости от того, содержит ли $i$-й объект из $A$ $j$-й объект из $B$ внутри себя.

Алгоритм анализа будет выглядеть следующим образом:

1. Построить матрицу топологических отношений для множества районов $A$ и множества пунктов питания $B$, используя функцию`gContains()`. В этой матрице районы будут соответствовать столбцам, а точки --- строкам.
2. Подсчитать, сколько раз встречается значение `TRUE` в каждом столбце (районе), используя функции `apply()` и `table()` 
3. Записать результат в новый столбец слоя районов.
4. Визуализировать результат в виде картограмм по районам.

Начнем с вычисления матрицы топологических отношений:
```{r, collapse=TRUE}
over.matrix <- gContains(rayons, poi.food, byid = TRUE)

# Посмотрим для примера верхний левый угол матрицы
View(over.matrix[1:10,1:10]) 
```
```{r, echo = FALSE, purl = FALSE}
datatable(over.matrix[1:10,1:10], options = list(pageLength = 10, scrollX = TRUE))
```

Прежде чем применять `apply()` для функции `table()` при подсчете встречаемости значений `TRUE`, полезно посмотреть, какой результат функция `table()` будет давать для одного столбца:

```{r, collapse=TRUE}
table(over.matrix[,1])
```

Видно, что для одного столбца функция `table()` возвращает вектор из двух значений --- количество `FALSE` и количество `TRUE` (в данном случае `TRUE` и `FALSE` --- это _названия_ элементов вектора, а цифры --- это _значения_ элементов вектора). Таким образом, нам достаточно извлечь второй элемент этого вектора и функция `apply()` будет выглядеть просто:

```{r, collapse=TRUE}
# Подсчитаем, сколько раз встречается TRUE в районе
counts <- apply(over.matrix, 2, function(X) table(X)[2])

# Преобразуем результат в относительный показатель
# (единиц на кв.км. площади) и запишем в таблицу районов:
rayons$counts <- ceiling(1000000*counts/rayons$Shape_Area)
```

Масштабный множитель 1000000 в коде понадобился чтобы перевести площадь, храняющуюся в поле Shape_Area из квадратных метров в квадратные километры. Обратите внимание на то, что в данном случае мы не стали ограничивать фигурными скобками тело анонимной функции (`table(X)[2]`) внутри `apply()`, поскольку выполняемая операция достаточно компактна.

Подготовим параметры отображения:
```{r, collapse=TRUE}
# Настроим параметры отображения
choro.pal <- colorRampPalette(c("lightgoldenrodyellow", "orangered"))

intervals <- classIntervals(rayons$counts, 
                            n = 5, 
                            style = "quantile")
```

Далее используем функции `choroLayer()` и `legendChoro()` из пакета `cartography` для построения картограмм плотности пунктов питания и соответствующей им легенды средствами обычной функции `plot()`:
```{r, collapse=TRUE}
choroLayer(spdf = rayons, # Исходный слой типа SpatialPolygonsDataFrame
           var = "counts", # Картографируемая переменная (столбец) 
           breaks = intervals$brks, # Границы интервалов
           col = choro.pal(5), # Цвета для соответствующих интервалов
           legend.pos = "n") # Легенду мы нарисуем позднее, поверх всех слоев
plot(water, 
     col = "lightskyblue1",
     border = "lightskyblue3",
     add = TRUE)
plot(roads,
     col = "gray50",
     add = TRUE)
plot(poi.food, 
     col = "deepskyblue4", 
     pch = 20, 
     cex = 0.5, 
     add = TRUE)
plot(rayons,
     border = "black",
     lwd = 3,
     add = TRUE)
text(coordinates(rayons),
     labels = gsub(' ', '\n', rayons$NAME),
     font = 2,
     cex = 0.6)

# Рисуем легенду
legendChoro(breaks = intervals$brks, 
            col = choro.pal(5),
            pos = "topleft",
            frame = TRUE, 
            title.txt = "Заведений на 1 кв.км")
# Статистика по районам в табличном представлении:
View(rayons[order(rayons$counts, decreasing = TRUE),c("NAME", "counts")])
```
```{r, echo = FALSE, purl = FALSE}
datatable(rayons@data[order(rayons$counts, decreasing = TRUE), c("NAME", "counts")], options = list(pageLength = 11, scrollX = TRUE))
```

Итак, используя топологический пространственный запрос "Содержит", мы смогли агрегировать точечные объекты внутри площадных и построить картограммы плотности распределения пунктов питания по районам центра Москвы.

## Анализ абсолютных зон окружения

Задача данного раздела модуля звучит следующим образом: определить, какие пункты питания находятся в радиусе 300 метров от метро "Кропоткинская". Контекстом анализа в данном случае служит 300-метровая зона окружения станции метро. Поставленную задачу можно решить двумя способами:

* Рассчитать расстояния от каждого пункта питания до станции метро "Кропоткинская" и выбрать точки, для которых это расстояние меньше или равно 300 метрам.
* Построить буферную зону радиусом 300 метров и выбрать ею точки, используя топологическое отношение "Содержит"

Мы будем использовать второй вариант решения. Алгоритм выглядит следующим образом:

1. Построить буферную зону, используя функцию `gBuffer()` из пакета `rgeos`.
2. Выбрать полученной зоной точки пунктов питания, используя функцию `gContains()` из пакета `rgeos`.
3. Получить идентификаторы строк точек, для которых топологическое отношение равно `TRUE`.
4. Отобрать исходные точки, используя полученные идентификаторы.
5. Визуализировать на карте полученные точки и буферную зону.

Для выполнения шага 2 определим функцию `selectPointsByPolygon(polygon, points)`, которая будет выбирать все точечные объекты из `objects`, находящиеся внутри площадного объекта `polygon`. Для выполнения шага 5, определим функцию `plotBasemap()`, которая будет рисовать объекты картографической основы, ее мы будем использовать далее неоднократно.

```{r, collapse=TRUE}
# Функция отвечает за выбор точек полигоном
selectPointsByPolygon <- function(polygon, points){
  # В результате выполнения gcontains будет получен вектор,
  # в котором TRUE будет стоять напротив точек, попавших в зону
  marked.ids <- gContains(polygon, points, byid = TRUE)
  
  # Отфильтруем идентификаторы точек, попавших в буферную зону
  selected.ids <- row.names(subset(marked.ids, marked.ids == TRUE))
  
  # Отфильтруем исходные точки по идентификаторам
  selected.points <- subset(points, row.names(points) %in% selected.ids)
  
  return(selected.points)
}

# Функция отвечает за рисование базовой карты
plotBasemap <- function(){
  
  plot(frame)

  plot(water, 
       col = "lightskyblue1",
       border = "lightskyblue3",
       add = TRUE)
  
  plot(roads,
       col = "gray70",
       add = TRUE)
  
  plot(poi.food, 
       col = "deepskyblue4", 
       pch = 20, 
       cex = 0.3, 
       add = TRUE)
  plot(stations, 
       col = "slategray4", 
       pch = 20, 
       cex = 2, 
       add = TRUE)
  text(coordinates(stations),
       labels = "M",
       col = "white",
       cex = 0.4)
}
```

Определив вспомогательные функции,  можем приступать к выполнению анализа:
```{r, collapse=TRUE}
# Выберем станцию метро и построим буферную зону
krop <- stations[stations$NAME == "Кропоткинская",]
zone <- gBuffer(krop, width = 300)

# Применим разработанную функцию для отбора точек
selected.poi <- selectPointsByPolygon(zone, poi.food)

# Применим разработанную функцию для рисования картографической основы
plotBasemap()

# Визуализируем результаты анализа
plot(krop, 
     col = "red", 
     pch = 20, 
     cex = 4, 
     add = TRUE)

text(coordinates(krop),
     labels = "M",
     col = "white",
     cex = 0.7)

plot(zone,
     col = adjustcolor("sienna3", alpha.f = 0.5),
     border = "sienna3",
     add = TRUE)

plot(selected.poi, 
     col = "sienna4", 
     pch = 20, 
     cex = 0.5, 
     add = TRUE)
# Найденные объекты в табличном представлении:
View(selected.poi)
```
```{r, echo = FALSE, purl = FALSE}
datatable(selected.poi@data, options = list(pageLength = 10, scrollX = TRUE))
```

В качестве примера аналогичного анализа отберем все пункты питания, находящиеся в пределах 100 метров от реки Москвы:
```{r, collapse=TRUE}
river <- water[water$NAME == "Москва",]
zone <- gBuffer(river, width = 100)

selected.poi <- selectPointsByPolygon(zone, poi.food)

plotBasemap()

plot(zone,
     col = adjustcolor("orange", alpha.f = 0.5),
     border = "orange",
     add = TRUE)

plot(river, 
     col = adjustcolor("deepskyblue", alpha.f = 0.5), 
     border = F,
     add = TRUE)

plot(selected.poi, 
     col = "firebrick1", 
     pch = 20, 
     cex = 0.5, 
     add = TRUE)
# Найденные объекты в табличном представлении:
View(selected.poi)
```
```{r, echo = FALSE, purl = FALSE}
datatable(selected.poi@data, options = list(pageLength = 10, scrollX = TRUE))
```

## Анализ конкурентных зон окружения

В данном разделе мы решим следующую задачу: разбить всю изучаемую территорию на зоны окружения станций метро и подсчитать количество пунктов питания, попадающих в каждую зону. Полученные зоны должны быть конкурентными: любая точка, находящаяся в зоне окружения конкретной станции метро, должна быть ближе к этой станции, чем к любой другой станции.

Ранее мы говорили о том, что конкурентные зоны окружения по расстоянию можно реализовать с помощью диаграммы Вороного. Применим функцию `deldir()` из из одноименного пакета, чтобы посмотреть, как выглядит диаграмма Вороного для точек станций метро:

```{r, collapse=TRUE, results = FALSE}
coords <- data.frame(coordinates(stations))
d <- deldir(coords)
plot(d)
```
Сплошными линиями на рисунке показаны ребра [триангуляции Делоне](https://ru.wikipedia.org/wiki/Триангуляция_Делоне) для заданного множества точек. Штриховыми линиями --- диаграмма Вороного, которую мы и будем использовать в дальнейшем анализе.

К сожалению, полигоны Вороного, создаваемые функцией `deldir()`, не являются объектами типа `SpatialPolygons`, которые нам неободимы для анализа и картографирования. Поэтому мы напишем небольшую функцию, которая извлекает информацию об этих полигонах и собирает из координат их граничных точек полноценные полигональные объекты. Функция voronoyDiagram() будет принимать на вход два аргумента:

* pts --- объект типа `SpatialPoints`, содержащий точки для построения диаграммы Вороного
* box --- объект типа `bbox` (ограничивающий прямоугольник), который будет опредлять область построения диаграммы. Этот объект хранит размах координат по осям X и Y и легко извлекается из любого объекта типа `Spatial*` с помощью функции `bbox()`.

```{r, message = FALSE, results = "hide", collapse=TRUE}
voronoyDiagram <- function(pts, box){
  envelope <- c(box[1,1], box[1,2], box[2,1], box[2,2]) # Получим вектор координат углов
  coords <- data.frame(coordinates(pts)) # Извлечем координаты точек
  d <- deldir(coords, rw = envelope) # Получим объект типа deldir
  t <- tile.list(d) # Извлечем координаты границ полигонов Вороного в виде списка
  npoly <- length(t) # Подсчитаем количество полигонов (элементов списка)
  polys <- vector(mode = 'list', length = npoly) # Заготовим вектор полигонов
  
  for (i in 1:npoly){ # Пройдемся по списку координат
    polygon <- Polygon(cbind(t[[i]]$x, t[[i]]$y)) # Создадим объект Polygon по координатам
    polys[[i]] <- Polygons(list(polygon), ID = as.character(i)) # Преобразуем его в объект Polygons
  }
  
  # Создадим объект типа Spatial
  voronoi.sp = SpatialPolygons(polys) 
  
  # Добавим к нему атрибутивную таблицу из исходных точек
  voronoi.sp.frame = SpatialPolygonsDataFrame(voronoi.sp, data = pts@data) 
  
  # Вернем результат
  return(voronoi.sp.frame)
}
```

Итак, функция для построения диаграммы Вороного написана, и можно выполнить агрегирование точек по конкурентным зонам окружения станций метро. Для визуализации результатов мы будем использовать метод картодиаграмм (пропорциональных символов), реализованный в функции `propSymbolsLayer()` пакета `cartography`. Размером кружка покажем количество пунктов питания, оказавшихся в каждой зоне окружения:

```{r, collapse = TRUE}
# Получим диаграмму Вороного станций метро в пределах территории анализа
zones <- voronoyDiagram(stations, bbox(frame))

# Выполним пространственный запрос
over.matrix <- gContains(zones, poi.food, byid = TRUE)

# Агрегруем данные по каждой зоне
zones$counts <- apply(over.matrix, 2, function(X) table(X)[2])

# Визуализируем результат
plotBasemap()

plot(zones,
     col = adjustcolor("white", alpha.f = 0.5),
     add = TRUE)

propSymbolsLayer(spdf = zones, 
           var = "counts", 
           symbols = "circle",
           col = adjustcolor("turquoise3", alpha.f = 0.5),
           border = F,
           legend.title.txt = "Заведений питания")

text(coordinates(zones), 
     labels = zones$counts,
     col = "turquoise4",
     cex = log(zones$counts)/4)
# Результаты анализа в табличном виде:
View(zones)
```
```{r, echo = FALSE, purl = FALSE}
datatable(zones@data, options = list(pageLength = 10, scrollX = TRUE))
```

## Анализ зон транспортной доступности

Зоны транспортной доступности представляют из себя зоны окружения объектов, построенные не по евклидову расстоянию, а по расстоянию или времени движения по дорожной сети. В задачах логистики и геомаркетинга зоны транспортной доступности часто называют _зонами обслуживания_ (service area), поскольку используются для определения территории, которую может покрыть объект, предоставляющий некоторые услуги. Например, для пожарного депо зона 10-минутной доступности показывает территорию города, в любую точку которой пожарная машина может доехать __из__ данного депо в течение 10 минут. И наоборот, для торгового центра зона 10-минутной доступности показывает территорию города, __из__ любой точки которой можно добраться до ТЦ в течение 10 минут. Очевидно, что продолжительность прямого и обратного маршрута неодинакова, на нее может оказывать влияние схема движения, приоритет дорог и так далее.

Задача, которую мы решим в данном разделе, звучит так: определить все заведения питания, находящиеся в 3 минутах езды от Центрального детского магазина. Для построения зоны доступности мы будем использовать пакет [osrm](https://cran.r-project.org/web/packages/osrm/index.html), предоставляющий интерфейс __R__ к онлайн-библиотеке маршрутизации [OSRM](http://project-osrm.org), работающей на основе данных OSM. Для построения зоны доступности (изохроны) нам понадобится функция `osrmIsochrone()` из данного пакета.

> Внимание: для выполнения этого раздела модуля необходимо подключение к Интернету

Поскольку данные, используемые в настоящем модуле, предварительно были конвертированы в проекцию [UTM](https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system) и хранятся в метрах, а OSRM решает все задачи в географических координатах (широте и долготе относительно эллипсоида [WGS84](https://en.wikipedia.org/wiki/World_Geodetic_System)), нам необходимо научиться работать с проекциями данных и преобразовывать системы координат между собой.

### Пространственная привязка

Существует несколько способов описания системы координат, в которой хранятся пространственные данные. К наиболее часто используемым способам относятся:

* __WKT (Well-Known Text)__ --- базовый формат, определяемый международным стандартом [ISO 19162 (Geographic information — Well known text for coordinate reference systems)](http://docs.opengeospatial.org/is/12-063r5/12-063r5.html). В частности, [Esri](http://www.esri.com) использует свою вариацию WKT для описания проекций.
* __PROJ.4__ --- формат широко используемой библиотеки трансформации проекций [PROJ.4](http://proj4.org/parameters.html). В частности, применяемая нами библиотека [GDAL](http://www.gdal.org) использует PROJ.4 для преобразования координат. Работа с проекциями в [QGIS](http://www.qgis.org/ru/site/) также происходит в этом формате.
* __EPSG__ --- система уникальных идентификаторов проекций, разработанная рабочей группой [EPSG (European Petroleum Survey Group)](http://www.epsg.org), и широко используемая в ГИС-приложениях для быстрой инициализации параметров проекций вместо их ручного задания.

Приведем примеры описания системы координат WGS84 (широта, долгота) в перечисленных форматах.

__WKT__:
```
GEOGCS["WGS 84",
    DATUM["WGS_1984",
        SPHEROID["WGS 84",6378137,298.257223563,
            AUTHORITY["EPSG","7030"]],
        AUTHORITY["EPSG","6326"]],
    PRIMEM["Greenwich",0,
        AUTHORITY["EPSG","8901"]],
    UNIT["degree",0.01745329251994328,
        AUTHORITY["EPSG","9122"]],
    AUTHORITY["EPSG","4326"]]
```

__PROJ.4__:
```
+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs 
```

__EPSG__:
```
EPSG:4326
```

В свою очередь, проекция UTM, 37 зона будет описана в терминах данных форматов следующим образом:

__WKT__:
```
PROJCS["WGS 84 / UTM zone 37N",
    GEOGCS["WGS 84",
        DATUM["WGS_1984",
            SPHEROID["WGS 84",6378137,298.257223563,
                AUTHORITY["EPSG","7030"]],
            AUTHORITY["EPSG","6326"]],
        PRIMEM["Greenwich",0,
            AUTHORITY["EPSG","8901"]],
        UNIT["degree",0.01745329251994328,
            AUTHORITY["EPSG","9122"]],
        AUTHORITY["EPSG","4326"]],
    UNIT["metre",1,
        AUTHORITY["EPSG","9001"]],
    PROJECTION["Transverse_Mercator"],
    PARAMETER["latitude_of_origin",0],
    PARAMETER["central_meridian",39],
    PARAMETER["scale_factor",0.9996],
    PARAMETER["false_easting",500000],
    PARAMETER["false_northing",0],
    AUTHORITY["EPSG","32637"],
    AXIS["Easting",EAST],
    AXIS["Northing",NORTH]]
```

__PROJ.4__:
```
+proj=utm +zone=37 +ellps=WGS84 +datum=WGS84 +units=m +no_defs 
```

__EPSG__:
```
EPSG:32637
```

Видно, что формат WKT дает наиболее исчерпывающую информацию о проекции, формат PROJ.4 более краток, а EPSG и вовсе обозначает проекцию одним числовым кодом. Разумеется, в реальной практике при работе с известными проекциями хотелось бы использовать максимально краткую форму задания проекции --- EPSG, или в крайнем случае PROJ.4. К счастью, это возможно в R. Более того, существует краткий формат инициализации проекции в формате PROJ.4 по коду EPSG. Например, для WGS84:
```
+init=epsg:4326
```

Данная форма записи означает, что параметры проекции надо подставить по коду EPSG.

Для работы с проекциями в R нам понадобятся следующие функции из пакета __sp__:

* `proj4string()` --- извлекает информацию о проекции из объекта типа `Spatial` и возвращает ее в виде текстовой строки в формате _PROJ.4_. 
* `CRS()` --- создает объект класса `CRS`, описывающий систему координат во внутреннем формате R. В качестве параметра принимает текстовую строку в формате _PROJ.4_.
* `spTransform()` --- преобразует систему координат объекта типа `Spatial` в другую систему координат. Возвращает новый объект типа `Spatial` в требуемой системе координат (если между ними определено преобразование).

Вооружившись этим знанием, приступим к выполнению анализа:
```{r, collapse=TRUE, results=FALSE}
# Инициализируем систему координат WGS84, используемую в OSRM
WGS84 <- CRS("+init=epsg:4326")

# Извлечем информацию о системе координат исходных точек
UTM <- CRS(proj4string(poi))

# Выберем целевой объект
psel <- subset(poi, NAME == "Центральный детский магазин" & SHOP == "toys")

# Преобразуем координаты точки в WGS84
psel.wgs <- spTransform(psel, WGS84)

# Получаем 3-минутную зону транспортной доступности
# с помощью пакета osrm
service.area <- osrmIsochrone(loc = coordinates(psel.wgs), breaks = 3)

# Преобразуем зону обратно в UTM для дальнейших операций
service.area.utm <- spTransform(service.area, UTM)

# Отбираем точки
selected.poi <- selectPointsByPolygon(service.area.utm, poi.food)

# Визуализируем результат
plotBasemap()

plot(service.area.utm,
     col = adjustcolor("violetred3", alpha.f = 0.2),
     border = "violetred3",
     add = TRUE)

plot(selected.poi, 
     col = "violetred3", 
     pch = 20, 
     cex = 0.5, 
     add = TRUE)

plot(psel, 
     col = "violetred4", 
     pch = 20, 
     cex = 4, 
     add = TRUE)
# Результаты анализа в табличном виде:
View(selected.poi)
```
```{r, echo = FALSE, purl = FALSE}
datatable(selected.poi@data, options = list(pageLength = 10, scrollX = TRUE))
```

Итак, в данном разделе мы научились строить зоны транспортной доступности в виде полигонов, ограниченных изохроной времени движения. Одновременно с этим получена необходимая информация об инициализации и преобразовании систем координат слоев.

## Построение маршрутов и матриц времени движения

В этом разделе модуля пространственного анализа мы посмотрим, каким образом можно построить оптимальный маршрут между двумя точками, а также получить матрицу времени движения между точками (на примере станций метро). Для решения этих задач используем следующие функции пакета osrm:

* `osrmRoute(src, dest)` --- строит оптимальный маршрут между точками `src` и `dest`
* `osrmTable(loc)` --- строит матрицу времени движения между всеми парами точек в `loc`

Так же, как и в предвдущем разделе, нам понадобятся преобразования координат. Построим оптимальный маршрут между книжным магазином "Молодая Гвардия" на Полянке и чебуречной "Дружба" на метро Сухаревская:
```{r, collapse = TRUE}
# Выбираем и проецируем начальную точку
origin <- subset(poi, NAME == 'Молодая Гвардия')
origin.wgs <- spTransform(origin, WGS84)
  
# Выбираем и проецируем конечную точку
destination <- subset(poi, NAME == 'Чебуречная "Дружба"')
destination.wgs <- spTransform(destination, WGS84)

# Строим маршрут
route <- osrmRoute(origin.wgs, 
                   destination.wgs, 
                   overview = "full", # запретить генерализацию линий
                   sp = TRUE) # вернуть результат в виде объекта класса Spatial

# Преобразуем результат обратно в UTM
route.utm <- spTransform(route, UTM)

# Визуализируем результат:
plotBasemap()

plot(route.utm,
     lwd = 3,
     col = "orange",
     add = TRUE)

plot(origin, 
     col = "tomato3", 
     pch = 20, 
     cex = 3, 
     add = TRUE)
text(coordinates(origin),
     labels = "O",
     col = "tomato4",
     cex = 0.5)

plot(destination, 
     col = "tomato", 
     pch = 20, 
     cex = 4, 
     add = TRUE)
text(coordinates(destination),
     labels = "D",
     col = "tomato4",
     cex = 0.7)

```

Наконец, матрица времени движения между точками (в минутах), может быть получена посредством функции `osrmTable()`. Сама матрица содержится в элементе списка под названием `durations`:
```{r, collapse = TRUE}
stations.wgs <- spTransform(stations, WGS84)

# Добавим названия станций в идентификаторы строк:
row.names(stations.wgs) <- paste(row.names(stations.wgs), stations.wgs$NAME, sep = '.')

od.list <- osrmTable(stations.wgs)

od.matrix <- od.list$durations

# Посмотрим результат на примере первых пяти станций:
View(od.matrix[1:5, 1:5])
```
```{r, echo = FALSE, purl = FALSE}
datatable(od.matrix[1:5, 1:5], options = list(pageLength = 5, scrollX = TRUE))
```

Аналогичная матрица, содержащая не время движения, а объем транспортных перевозок, носит название [матрицы корреспонденций](http://www.isa.ru/transnet/intro/index.html?basicdefs.htm). Подобного рода матрицы часто используются в логистическом анализе, оптимизации перевозок и задачах геомаркетинга. 
