# Матрицы, таблицы и списки {#matrix_dataframes}

В это модуле мы продвинемся дальше в изучении структур данных языка и рассмотрим такие важные его элементы как матрицы, таблицы и списки.

## Матрицы

Матрица — это обобщение понятия вектора на 2 измерения. С точки зрения анализа данных матрицы ближе к реальным данным, посколько каждая матрица по сути представляет собой таблицу со столбцами и строками. Однако матрица, как и вектор, может содержать только элементы одного типа (числовые, строковые, логические и т.д.). Позже мы познакомимся с таблицами, которые не обладают подобным ограничением. А пока рассмотрим, как работать с двумерными данными на примере матриц.

Матрица, как правило, создается с помощью функции `matrix`, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов:
```{r, collapse=TRUE}
v <- 1:12  # создадим вектор из натуральных чисел от 1 до 12
m <- matrix(v, nrow = 3, ncol = 4)
m
```
По умолчанию матрица заполняется данными вектора по столбцам, что можно видеть в выводе программы. Если вы хотите заполнить ее по строкам, необходимо указать параметр `byrow = TRUE`:
```{r, collapse=TRUE}
m <- matrix(v, nrow = 3, ncol = 4, byrow = TRUE)
m
```
Доступ к элементам матрицы осуществляется аналогично вектору, за исключением того что нужно указать положение ячейки в строке и столбце:
```{r, collapse=TRUE}
m[2,4]  # 2 строка, 4 толбец
m[3,1]  # 3 строка, 1 столбец
```
Помимо этого, из матрицы можно легко извлечь одну строку или один столбец. Для этого достаточно указать только номер строки или столбца, а номер второго измерения пропустить до или после запятой. Результат является вектором:
```{r, collapse=TRUE}
m[2,]  # 2 строка
m[,3]  # 3 cтолбец
```
К матрицам можно применять операции, аналогичные операциям над векторами:
```{r, collapse=TRUE}
log(m)  # натуральный логарифм ото всех элементов
sum(m)  # сумма всех элементов матрицы
median(m) # медиана
```
А вот сортировка матрицы приведет к тому что будет возвращен обычный вектор:
```{r, collapse=TRUE}
sort(m)
```
К матрицам также применимы специальные функции, известные из линейной алгебры, такие как транспонирование и вычисление определителя:
```{r, collapse=TRUE, error = TRUE}
t(m)  # транспонированная матрица
m2<-matrix(-3:3,nrow = 3, ncol = 3)
m2
det(m2) # определитель матрицы
det(m)  # ошибка! определитель вычисляется только для квадратных матриц
```
Матрицы также можно перемножать с помощью специального оператора `%*%`. При этом, как мы помним, число столбцов в первой матрице должно равняться числу строк во второй:
```{r, collapse=TRUE, error = TRUE}
m2 %*% m
m %*% m2  # ошибка!
```
Функция `match()`, которую мы использовали для поиска элементов в векторе, не работает для матриц. Вместо этого необходимо использовать функцию `which()`. Если мы хотим найти в матрице m позицию числа $8$, то вызов функции будет выглядеть так:
```{r, collapse=TRUE}
which(m == 8, arr.ind = TRUE)
```
В данном случае видно, что результат возвращен в виде матрицы $1 \times 2$. Обратите внимание на то, что колонки матрицы имеют названия. Попробуем использовать найденные индексы, чтобы извлечь искомый элемент:
```{r, collapse=TRUE}
indexes <- which(m == 8, arr.ind = TRUE)
row <- indexes[1,1]
col <- indexes[1,2]
m[row,col]
```
Ура! Найденный элемент действительно равен $8$.

Еще один полезный способ создания матрицы — это собрать ее из нескольких векторов, объединив их по строкам. Для этого можно использовать функции `cbind()` и `rbind()`. На предыдущем занятии мы создали векторы с длиной и количеством станций на разных ветках метро. Можно объединить их в одну матрицу:
```{r, collapse=TRUE}
lengths <- c(28, 40, 45, 19, 38)
stations <- c(20, 21, 22, 12, 24)
cbind(lengths, stations)  # соединим вектора в качестве столбцов
rbind(lengths, stations)  # соединим вектора в качестве строк
```
Cтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций:
```{r, collapse=TRUE}
mm <- cbind(lengths, stations)
mm[,2]/mm[,1]  # количество станций на 1 км пути
```
Результат можно присоединить к уже созданной матрице:
```{r, collapse=TRUE}
dens <- mm[,2]/mm[,1]
mm<-cbind(mm, dens)
mm
```
Содержимое матрицы можно просмотреть в более привычном табличном виде для этого откройте вкладку _Environment_ и щелкните на строку с матрицей в разделе _Data_

Матрицы, однако, не дотягивают по функциональности до таблиц, и, в общем-то, не предназначены для объединения разнородных данных в один набор (как мы это сделали). Если вы присоедините к матрице столбец с названиями веток метро, система не выдаст сообщение об ошибке, но преобразует матрицу в текстовую, так как текстовый тип данных способен представить любой другой тип данных:
```{r, collapse=TRUE}
colors <- c("Красная", "Зеленая", "Синяя", "Коричневая", "Оранжевая")
mm2<-cbind(mm,colors)
mm2  # обратите внимание на то, что вокруг чисел добавились кавычки
```
При попытке выполнить арифметическое выражение над прежде числовыми полями, вы получите сообщение об ошибке:
```{r, collapse=TRUE,error = TRUE}
mm2[,2]/mm2[,1]
```

## Таблицы 

Таблица — это обобщение понятия матрицы на данные смешанных типов. Это наиболее распространенный формат представления данных. В R таблицы именуются датафреймами (_data frame_). Для их создания используется функция `data.frame()`:
```{r, collapse=TRUE}
t<-data.frame(colors,lengths,stations)
t  # как мы видим, уже никаких кавычек вокруг чисел
```
К таблицам также можно пристыковывать новые столбцы:
```{r, collapse=TRUE}
t<-cbind(t, dens)
t
```
Когда таблица формируется посредством функции `data.frame()` и `cbind()` названия столбцов берутся из названий векторов. Обратите внимание на то, что листинге выше столбцы имеют заголовки, а строки — номера:

Как и прежде, к столбцам и строкам можно обращаться по индексам:
```{r, collapse=TRUE}
t[2,2]
t[,3]
t[4,]

```
Вы можете обращаться к отдельным столбцам таблицы по их названию, используя оператор `$` (доллар):
```{r, collapse=TRUE}
t$lengths
t$stations
```
Так же как и ранее, можно выполнять различные операции над столбцами:
```{r, collapse=TRUE}
max(t$stations)
t$lengths / t$stations
```
Названия столбцов можно получить с помощью функции `colnames()`
```{r, collapse=TRUE}
colnames(t)
```
Чтобы присоединить строку, сначала можно создать таблицу из одной строки:
```{r, collapse=TRUE}
row<-data.frame("Фиолетовая", 40.5, 22, 22/45)
```
Далее нужно убедиться, что столбцы в этой мини-таблице называются также как и в той, куда мы хотим присоединить строку. Для этого нужно перезаписать результат, возвращаемый функцией colnames()
```{r, collapse=TRUE}
colnames(row) <- colnames(t)
```
Обратите внимание на синтаксис вышеприведенного выражения. Когда функция возвращает результат, она обнаруживает свойство самого объекта, и мы можем его перезаписать. После того как столбцы приведены в соответствие, можно присоединить новую строку:
```{r, collapse=TRUE}
t<-rbind(t,row)
```
Поскольку названия столбцов хранятся как вектор из строк, мы можем их переделать:
```{r, collapse=TRUE}
colnames(t)<-c("Цвет","Длина","Станции","Плотность")
colnames(t)
```
Обратимся по новому названию столбца:
```{r, collapse=TRUE}
t$Длина
t
```

## Списки

Список — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа. В качестве элементов списка могут быть числа, строки, вектора, матрицы, таблицы — и все это в одном контейнере. Списки используются как правило чтобы комбинировать разрозненную информацию. Результатом выполнения многих функций является список.

Например, можно создать список из текстового описания таблицы, самой таблицы и обобщающей статистики по таблице:
```{r, collapse=TRUE}
d <- "Эта таблица содержит данные по 6 линиям Московского метро"
s <- summary(t)  # summary() выдает обобщающую статистику вектору, матрице или таблице
```
Сооружаем список из трех элементов:
```{r, collapse=TRUE}
metrolist <- list(d,t,s)
metrolist
```
Можно дать элементам списка осмысленные названия при создании:
```{r, collapse=TRUE}
metrolist <- list(desc = d, table = t, summary = s)
metrolist
```
Теперь можно обратиться к элементу списка по его названию:
```{r, collapse=TRUE}
metrolist$summary
```
Поскольку summary сама является таблицей, из нее можно извлечь столбец:
```{r, collapse=TRUE}
metrolist$summary[,3]
```
К элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в _двойные_ квадратные скобки:
```{r, collapse=TRUE}
metrolist[[1]]
metrolist[["desc"]]
```
Использование двойных скобок отличает списки от векторов.