# Тематические карты в R {#thematic_mapping_new}

```{r setup, echo = FALSE, purl = FALSE, include=FALSE}
library(datasets)
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_knit$set(root.dir = "data/")
knitr::opts_chunk$set(warning=FALSE, message = FALSE, collapse=TRUE, cache = TRUE)
```

## Предварительные условия  {-}

Для выполнения кода данной лекции вам понадобятся следующие пакеты:
```{r}
library(sf)
library(tmap)
library(readxl)
library(raster)
library(mapview)
library(classInt)
library(gapminder)
library(tidyverse)
library(googlesheets)
library(rnaturalearth)
```

## Введение

Тематические карты представляют собой важный инструмент географических исследований. Таблицы и графики не дают полного представления о пространственном распределении изучаемого явления. Это знание способна дать исследователю карта.

Разнообразие типов и видов карт достаточно велико. Комплексные картографические произведения, содержащие многослойный набор объектов, создаются, как правило, средствами геоинформационных пакетов. Такие карты требуют тщательной и кропотливой работы с легендой, устранения графических конфликтов между знаками, многократного редактирования входных данных, условий, фильтров и способов изображения в попытке достичь эстетичного и вместе с тем информативного результата.

В то же время, гораздо большее количество создаваемых в повседневной практике карт носят простой аналитический характер. Такие карты показывают одно, максимум два явления, и могут иллюстрировать входные данные, результаты промежуточных или итоговых расчетов. Создание именно таких карт целесообразно автоматизировать средствами программирования. В этом разделе мы познакомимся с созданием тематических карт средствами пакета [__tmap__](https://cran.r-project.org/web/packages/tmap/index.html). В качестве источника открытых данных мы будем использовать [Natural Earth](https://www.naturalearthdata.com/) и [WorldClim](http://www.worldclim.org/).

### Данные Natural Earth {#thematic_mapping_ne}

[Natural Earth](https://www.naturalearthdata.com/) — это открытые мелкомасштабные картографические данные высокого качества. Данные доступны для трех масштабов: 1:10М, 1:50М и 1:110М. Для доступа к этимм данным из среды R без загрущзки исходных файлов можно использоват пакет [__rnaturalearth__](https://cran.r-project.org/web/packages/rnaturalearth/index.html). Пакет позволяет выгружать данные из внешнего репозитория, а также содержит три предзакачанных слоя:

- `ne_countries()` границы стран
- `ne_states()` границы единиц АТД 1 порядка
- `ne_coastline()` береговая линия

Для загрузки других слоев необходимо использовать функцию `ne_download()`, передав ей масштаб, название слоя и его категорию: 

```{r}
countries = ne_countries() %>% st_as_sf()

coast = ne_coastline() %>% st_as_sf()

ocean = ne_download(scale = 110, 
                    type = 'ocean', 
                    category = 'physical') %>% 
  st_as_sf()

cities = ne_download(scale = 110, 
                     type = 'populated_places', 
                     category = 'cultural') %>% 
  st_as_sf()

rivers = ne_download(scale = 110, 
                     type = 'rivers_lake_centerlines', 
                     category = 'physical') %>% 
  st_as_sf()
```

Познакомимся с загруженными данными:
```{r}
plot(ocean %>% st_geometry(), col = 'lightblue')
plot(countries, col = 'white', border = 'grey', add = TRUE)
plot(coast, add = TRUE, col = 'steelblue')
plot(rivers, add = TRUE, col = 'steelblue')
plot(cities, add = TRUE, col = 'black', pch = 19, cex = 0.2)
```


Перед построением карт мира данные целесообразно спроецировать. Чтобы не трансформировать каждый слой отдельно, можно объединить слои в список и воспользоваться функционалом `lapply` для множественного трансформирования. Для создания списка воспользуемся функцией `lst()` из пакета `tibble`, которая присваивает компонентам списка имена, соответствующие названиям входных переменных (чтобы не писать `ocean = ocean`):
```{r}
lyr = tibble::lst(ocean, coast, countries, rivers, cities)
lyrp = lapply(lyr, st_transform, crs = "+proj=eck3") # Псевдоцилиндрическая проекция Эккерта

g = st_graticule(lyrp$ocean) %>% st_geometry() # построим  координатную сетку

plot(lyrp$ocean %>% st_geometry(), col = 'lightblue', border = NA)
plot(lyrp$countries, col = 'white', border = 'grey', lwd = 0.5, add = TRUE)
plot(lyrp$coast, add = TRUE, lwd = 0.5, col = 'steelblue')
plot(lyrp$rivers, add = TRUE, lwd = 0.5, col = 'steelblue')
plot(lyrp$cities, add = TRUE, col = 'black', pch = 19, cex = 0.1)

plot(g, lty = 3, lwd = 0.5, add = TRUE)
```

### Данные WorldClim

[WorldClim](http://www.worldclim.org/) --- это открытые сеточные наборы климатических характеристик с пространственным разрешением от $30''$ (около 1 км) до $10'$ (около 20 км). Данные можно выгрузить в виде файлов GeoTiff, однако эту операцию можно сделать и программным путем через пакет __raster__ --- используя функцию `getData()`. Выполним загрузку 10-минутного растра с суммарным количеством осадков за год:
```{r, fig.height=20}
prec = getData("worldclim", var = "prec", res = 10)
plot(prec, nc = 2) # это 12-канальный растр
```

Выполним трансформирование данных в проекцию Миллера. Для того чтобы карта не обрезалась по охвату растра (он не включает данные на Антарктиду), необходимо расширить его охват на весь земной шар:
```{r}
precm = prec %>% 
  extend(extent(-180, 180, -90, 90)) %>% 
  projectRaster(crs = "+proj=mill")
lyrm = lapply(lyr, st_transform, crs = "+proj=mill") # Цилиндрическая проекция Миллера
```

Визуализируем на карте:
```{r}
ramp = colorRampPalette(c("white", "violetred"))

# Визуализируем данные на январь:
plot(precm, 1, 
     col = ramp(10),
     colNA = 'grey',
     main = 'Количество осадков в январе, мм',
     box = FALSE,
     axes = FALSE)
plot(lyrm$ocean, border = 'steelblue', 
     col = 'lightblue', add = TRUE)
```

> Использовать программную загрузку целесообразно для небольших наборов данных. Если счет пошел на десятки мегабайт и выше, следует все-таки выкачать данные в виде файла и работать с ним

## Тематические карты tmap {#thematic_mapping_tmap}

Пакет __tmap__ предоставляет простой в использовании и достаточно мощный механизм формирования тематических карт. Шаблон построения карты в этом пакете напоминает _ggplot_ и выглядит следующим образом:
```{r eval=FALSE}
tm_shape(<DATA>) +
  tm_<METHOD>(<PARAMETERS>)
```

где:

- `DATA` - объект пространственного типа (`sf`, `sp`, `stars` или `raster`)
- `METHOD` - метод визуализации этого объекта (спопоб изображения)
- `PARAMETERS` - параметры метода

### Векторные карты {#thematic_mapping_vectors}

Для реализации качественного и количественного фона, а также картограмм используется метод `tm_polygons()`. Он автоматически определяет тип переменной и строит соответствующую шкалу:
```{r}
tm_shape(lyrp$countries) +
  tm_polygons('economy') + # качественная переменная
tm_shape(lyrp$ocean)+
  tm_fill(col = 'azure') +
  tm_borders(col = 'steelblue')
```

__Количественный фон__ или __картограммы__ получаются при картографировании числового показателя применением той же функции `tm_polygons()`:
```{r}
('1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo' %>% # продолжительность жизни
  gs_key(lookup = FALSE) %>% # не используем авторизацию
  gs_read(ws = 1) %>% 
  rename(name = 1) %>% 
  gather(year, lifexp, -name) %>% 
  filter(year == 2016) %>% 
  left_join(read_excel('gapminder.xlsx', 2)) %>% 
  mutate(geo = stringr::str_to_upper(geo)) -> lifedf) # выгружаем данные по ВВП на душу населения и сохраняем в переменную lifedf

coun = lyrp$countries %>% left_join(lifedf, by = c('adm0_a3' = 'geo'))

tm_shape(coun) +
  tm_polygons('lifexp', border.col = 'gray20') + # количественная переменная
tm_shape(lyrp$ocean) +
  tm_fill(col = 'azure') +
  tm_borders(col = 'steelblue4')
```

Для реализации способа __картодиаграмм__ используется геометрия `tm_bubbles()`. Чтобы оставить отображение границ полигонов, нам необходимо к одной геометрии применить несколько способов изображения:
```{r}
tm_shape(coun) +
  tm_fill(col = 'white') +
  tm_borders(col = 'grey') +
  tm_bubbles('gdp_md_est', 
             scale = 3,
             col = 'red', 
             alpha = 0.5,
             title.size = '$ млн') + # количественная переменная
tm_shape(lyrp$ocean) +
  tm_fill(col = 'lightblue') +
  tm_borders(col = 'steelblue')
```

Аналогичным образом реализуется __значковый способ__ применительно к объектам, локализованным по точкам. Картографируем численность населения по крупнейшим городам:
```{r}
tm_shape(lyrp$countries) +
  tm_fill(col = 'white') +
  tm_borders(col = 'grey') +
tm_shape(lyrp$ocean) +
  tm_fill(col = 'lightblue') +
  tm_borders(col = 'steelblue') +
tm_shape(lyrp$cities) +
  tm_bubbles('POP2015', col = 'olivedrab', alpha = 0.8)
```

__Надписи__ объектов на карте размещаются с помощью функции `tm_text`. Данная функция содержит весьма полезные параметры remove.overlap и auto.placement, которые позволяют убрать перекрывающиеся подписи и автоматически разместить из вокруг точек так, чтобы уменьшить перекрытия с самими знаками и другими подписями. Дополним предыдущую карту названиями городов:
```{r}
tm_shape(lyrp$countries) +
  tm_fill(col = 'white') +
  tm_borders(col = 'grey') +
tm_shape(lyrp$ocean) +
  tm_fill(col = 'lightblue') +
  tm_borders(col = 'steelblue') +
tm_shape(lyrp$cities) +
  tm_bubbles('POP2015', col = 'olivedrab', alpha = 0.8) +
  tm_text('name_ru', size = 0.5, remove.overlap = TRUE, auto.placement = TRUE)
```

### Растровые карты {#thematic_mapping_rasters}

При отображении растровых данных используется способ отображения `tm_raster()`. Параметр `breaks` определяет границы интервалов, для которых будут использованы цвета, взятые из параметра `palette`:
```{r}
tm_shape(precm) +
    tm_raster('prec1',
              breaks = c(10, 50, 100, 200, 500, 1000),
              palette = ramp(5)) +
tm_shape(lyrm$ocean) +
  tm_fill(col = 'lightblue') +
  tm_borders(col = 'steelblue')
```

## Цветовые шкалы {#thematic_color_scales}

Для изменения цветовой шкалы при определдении способа избражения вы можете определить параметр `palette`. Пакет __tmap__ позволяет работать с цветовыми палитрами _Color Brewer_ или задавать цвета вручную. Очень удобным инструментом подбора шкалы является функция `palette_explorer()` из пакета __tmaptools__. При вызове функции открывается интерактивное приложение, позволяющее менять настройки цветовых палитр:
```{r, eval=FALSE}
tmaptools::palette_explorer()
```

![Приложение Palette Explorer из пакета __tmaptools__](images/palette_explorer.png)

Данных палитр хватат для решения большинства задач по картографической визуализации. Применим категориальную палитру _Dark2_:
```{r}
tm_shape(lyrp$countries) +
  tm_polygons('economy', palette = 'Dark2') + # качественная переменная
tm_shape(lyrp$ocean)+
  tm_fill(col = 'azure') +
  tm_borders(col = 'steelblue')
```

Для количественного показателя (количество осадков) применим палитру _PuBuGn_:
```{r}
tm_shape(precm) +
    tm_raster('prec1',
              breaks = c(10, 50, 100, 200, 500, 1000),
              palette = 'PuBuGn') +
tm_shape(lyrm$ocean) +
  tm_fill(col = 'lightblue') +
  tm_borders(col = 'steelblue')
```

Вы всегда можете, конечно, определить цвета вручную. В этом случае их количество должно совпадать с количеством интервалов классификации:
```{r}
tm_shape(precm) +
    tm_raster('prec1',
              breaks = c(10, 50, 100, 200, 500, 1000),
              palette = c('white', 'gray80', 'gray60', 'gray40', 'gray20')) +
tm_shape(lyrm$ocean) +
  tm_fill(col = 'lightblue') +
  tm_borders(col = 'steelblue')
```

## Классификация {#thematic_mapping_class}

### Методы классификации {#thematic_mapping_class_methods}

Классификация данных --- важнейший этап картографирования, который во многом определяет, как данные будут представлены на карте и какие географические выводы читатель сделает на ее основе. Существует множество методов классификации числовых рядов. Классифицировать данные автоматически можно с помощью функции `classIntervals()` из пакета `classInt`. Наберите в консоли `?classInt` чтобы прочитать справку о методах классификации.

Посмотрим несколько методов классификации. Первый параметр функции `classInt` --- это числовой ряд. Число классов следует передать в параметр `n =`, метод классификации указывается в параметре `style =`.

Для начала попробуем метод равных интервалов, который просто делит размах вариации (диапазон от минимума до максимум) на $n$ равных интервалов. Функция `plot()` применительно к созданной классификации рисует замечательный график, на котором показаны границы классов и  эмпирическая функция распределения показателя. В параметр `pal` можно передать цветовую палитру:
```{r, collapse=TRUE}
# Запишем число классов в переменную
nclasses = 5

intervals = classIntervals(coun$lifexp, n = nclasses, style = "equal")

# извлечь полученные границы можно через $brks
intervals$brks

plot(intervals, pal = ramp(nclasses), cex=0.5, main = "Равные интервалы MIN/MAX")
```

Cозданные интервалы хоть и равны, но не аккуратны. Зато метод классификации `"pretty"` создает также равные интервалы, но может слегка расширить диапазон или добавить 1 класс, чтобы получить границы интервалов, округленные до целых чисел:
```{r, collapse=TRUE}
intervals = classIntervals(coun$lifexp, n = nclasses, style = "pretty")
intervals$brks
plot(intervals, pal = ramp(nclasses), cex=0.5, main = "Округленные равные интервалы")
```

Квантили --- равноколичественные интервалы. В каждом классе содержится одинаковое число объектов:
```{r, collapse=TRUE}
intervals = classIntervals(coun$lifexp, n = nclasses, style = "quantile")
intervals$brks
plot(intervals, pal = ramp(nclasses), cex=0.5, main = "Квантили (равноколичественные)")
```

Метод "естественных интервалов", или метод Фишера-Дженкса позволяет найти классы, максимально однородные внутри и при этом максимально отличающиеся друг от друга:
```{r, collapse=TRUE}
intervals = classIntervals(coun$lifexp, n = nclasses, style = "jenks")
intervals$brks
plot(intervals, pal = ramp(nclasses), cex=0.5, main = "Естественные интервалы")
```

### Применение на картах {#thematic_mapping_class_application}

## Компоновка {#thematic_mapping_layouts}

Пакет __tmap__ предоставляет широкий набор настроек компоновки картографического изображения, который включает настройку легенды, заголовка карты и ряда других важных параметров. Большинство настроек компоновки осуществляется через функцию `tm_layout()`, однако часть из них, специфичная для конкретного слоя, определяется непосредственно при настройке способа изображения.

В примере ниже показано, как добавить заголовок карты, поместить ее легенду в полупрозрачный прямоугольник и заменить стандартный шрифт на _OpenSans_:
```{r}
tm_shape(lyrp$countries) +
  tm_polygons('economy', title = '') +
tm_shape(lyrp$ocean)+
  tm_fill(col = 'azure') +
  tm_borders(col = 'steelblue') +
tm_layout(legend.position = c('left', 'bottom'),
          fontfamily = 'OpenSans',
          main.title.size = 1.2,
          main.title = 'Тип экономики',
          legend.frame = TRUE,
          legend.frame.lwd = 0.2,
          legend.bg.alpha = 0.8,
          legend.bg.color = 'white')
```

По умолчанию tmap размещает легенду внутри фрейма картографического изображения. Однако ее можно вынести и наружу, используя параметр `legend.outside` функции `tm_layout()`. В примере ниже показано также, как можно задать способ отображения отсутствующих данных и отформатировать разделитель в легенде с интервалами значений:
```{r}
tm_shape(coun) +
  tm_polygons('lifexp', 
              border.col = 'gray20', 
              title = 'Лет',
              colorNA = 'lightgray',
              textNA = 'Нет данных',
              legend.format = list(text.separator = '—')) + # количественная переменная
tm_shape(lyrp$ocean) +
  tm_fill(col = 'azure') +
  tm_borders(col = 'steelblue4') +
tm_layout(legend.outside = TRUE,
          legend.outside.position = 'right',
          fontfamily = 'OpenSans',
          main.title.size = 1.2,
          main.title = 'Продолжительность жизни',
          legend.bg.color = 'white')
```


```{r}
tm_shape(precm) +
    tm_raster('prec1',
              breaks = c(10, 50, 100, 200, 500, 1000),
              palette = ramp(5), title = 'мм',
              colorNA = 'lightgray',
              textNA = 'Нет данных',
              legend.format = list(text.separator = '—')) +
tm_shape(lyrm$ocean) +
  tm_fill(col = 'lightblue') +
  tm_borders(col = 'steelblue') +
tm_layout(legend.position = c('left', 'bottom'),
          fontfamily = 'OpenSans',
          main.title.size = 1.2,
          main.title = 'Среднемноголетнее количество осадков в январе',
          legend.frame = TRUE,
          legend.frame.lwd = 0.2,
          legend.bg.alpha = 0.5,
          legend.bg.color = 'white')
```

## Фасетные карты {#thematic_mapping_facets}

## Анимированные карты {#thematic_mapping_facets}

## Анаморфозы {#thematic_mapping_facets}

## Интерактивные карты  {#thematic_mapping_interactive}

Любую карту tmap можно превести в интерактивный режим с помощью функции `tmap_mode()` с параметром `'view'`:
```{r}
tmap_mode('view')

tm_shape(coun) +
  tm_polygons('lifexp') # количественная переменная
```

Чтобы добавить карту-подложку, необходимо предварительно вызвать функцию `tm_basemap()`, передав ей название картографического сервиса:
```{r}
tm_basemap("OpenStreetMap") +
tm_shape(coun) +
  tm_polygons('lifexp', alpha = 0.5) # количественная переменная
```

## Контрольные вопросы и упражнения {#questions_tasks_tmap}

### Вопросы {#questions_tmap}

### Упражнения {#tasks_tmap}

1. Используя возможности пакетов __rnaturalearth__ и __tmap__, создпайте карту мира, в которой страны раскрашены в соответствии с континентом (переменная _continent_). Визуализируйте ее в статичном и интерактивном режиме.

2. Выполните выборку стран на Европейский континент. Трансформируйте данные о странах в коническую равнопромежуточную проекцию. Визуализируйте численность населения по странам (переменная _pop\_est_) способом картодиаграмм. Добавьте на карту реки, озера и города, используя возможности `ne_download()`.

----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----