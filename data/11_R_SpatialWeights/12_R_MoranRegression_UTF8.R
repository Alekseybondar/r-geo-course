#' ---
#' title: "Исследование простраственной автокорреляции II. Индекс Морана и пространственная авторегрессия"
#' abstract: "В данном модуле мы рассмотрим вычисление меры пространственной автокорреляции — индекса Морана, который дает оценку статистической зависимости между значением показателя в каждой локации (территориальной единице) и значениями в соседних локациях. Имея предположение о наличии пространственной автокорреляции, можно построить модель пространственной авторегрессии, которая дает фоновое распределение показателя по территориальным единицам, а также случайные остатки."
#' author: "Тимофей Самсонов"
#' e-mail: tsamsonov@geogr.msu.ru
#' date: "`r format(Sys.time(), '%d %B %Y')`"
#' output:
#'   html_document:
#'     highlight: tango
#'     theme: lumen
#'     toc: yes
#'     toc_float: yes
#' tags: [R, пространственный анализ, векторные данные]
#' version: 1
#' ---
## ----setup, include = FALSE----------------------------------------------
library(DT)
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_knit$set(root.dir = "data/12_R_MoranAutoregression/")

#' 
#' ## Введение
#' 
#' На этом занятии мы кратко познакомимся со статистической оценкой пространственной автокорреляции, а также построением простейших авторегрессионных моделей.
#' 
#' Мы будем использовать месячную статистику по случаям заболеваний верхних дыхательных путей в Кировской области за 2015 год (данные Росстата по районам, модифицированы автором для большей наглядности анализа).
#' 
#' Вам предстоит выполнить следующую последовательность действий:
#' 
#' 1. Загрузить исходные данные (границы районов и таблицу со статистикой)
#' 2. Присоединить таблицу к пространственным данным
#' 3. Построить серию карт по месяцам для визуального анализа данных
#' 4. Вычислить матрицу пространственных весов $W$
#' 5. Вычислить I-индекс Морана для численной оценки пространственной автокорреляции
#' 6. Построить диаграмму рассеяния Морана для визуальной оценки пространственной автокорреляции
#' 7. Подобрать параметры модели пространственной авторегрессии
#' 8. Построить карты реальных, модельных (fitted) значений и остатков (lag)
#' 
#' Для начала построим серию карт чтобы оценить по ним наличие или отсутствие пространственной автокорреляции по месяцам:
#' 
## ---- message = FALSE, results = "hide", collapse=TRUE-------------------
library(sp)
library(rgdal)
library(spdep) # пакет spdep содержит инструменты анализа ПА
library(lattice)
library(xlsx)

setwd("/Volumes/Dropbox/Dropbox/R/Lectures/Scripts/RMarkdown/data/12_R_MoranAutoregression")

# Чтение базовых пространственных данных
mun <- readOGR(".", "KirovUTF8")

# Чтение таблицы со статистикой
classes <- c("integer", "character", rep("numeric", 10))
tab <- read.xlsx2("Kirov.xlsx",1, colClasses = classes)

# Соединение таблиц
mun@data <- merge(mun@data, tab, by.x="OBJECTID", by.y="N")

# Построение серии карт
months <- names(mun)[22:31] # выбираем названия столбцов с месяцами
ramp <- colorRampPalette(c("white", "orange", "red"))
levels <- seq(0,10000,1000)
nclasses <- length(levels)-1
spplot(mun, months, at = levels, col.regions = ramp(nclasses))

#' 
#' Данная серия карт показывает, что наиболее интересный для анализа месяц — февраль, в котором наблюдается рост заболеваемости, а также очевидно наличие пространственной автокорреляции с двумя очагами в центральных и северо-зпапдных районах области.
#' 
#' Вычислим матрицу пространственных весов:
## ---- message = FALSE, results = "hide", collapse=TRUE-------------------
# Определение соседства (правило ферзя)
nei<-poly2nb(mun)

# Визиуализация графа соседства
coords <- coordinates(mun)
plot(mun, border="darkgray")
plot(nei, coords, pch = 19, cex = 0.5, add = TRUE)
title(main="Соседи по смежности (правило ферзя)")

# Вычисление весов (нормированная матрица)
W <- nb2listw(nei)

# Визуализация матрицы весов
M<-listw2mat(W)

ramp2 <- colorRampPalette(c("white","red"))
levels2 <- 1/1:10 # шкала 1, 0.5, 0.33, 0.25 ... 0.1
levelplot(M, 
          main="Матрица весов (нормированная)", 
          at = levels2, 
          col.regions=ramp2(10))

#' 
#' ## Вычисление индекса Морана (Moran's I)
#' 
#' Анализ пространственной автокорреляции осуществляется, как правило, путем вычисления индекса Морана (Moran's I), :
#' $$
#' I = \frac{n \sum^n_{i=1} \sum^n_{j=i} w_{ij} (y_i - \bar y)(y_j - \bar y)}{ \Big[\sum^n_{i=1} \sum^n_{j=i} w_{ij}\Big] \Big[\sum^n_{i=1} (y_i - \bar y)^2\Big]}
#' $$
#' где $n$ --- количество единиц, $w_{ij}$ --- вес пространственной связи между $i$-й и $j$-й единицей, $y_i$ --- значение в $i$-й единице, $\bar y$ --- выборочное среднее по всем единицам
#' 
#' Обратим внимание на то, что индекс Морана по сути и форме записи похож на линейный коэффициент корреляции Пирсона, в котором перебираются все пары соответствующих друг другу значений из рядов $X = \{x_i\}$ и $Y = \{y_i\}$: 
#' 
#' $$
#' r_{xy} = \frac{\sum_{i=1}^{n}(x_i - \bar x)(y_i - \bar y)}{\sqrt{\sum_{i=1}^{n}(x_i - \bar x)^2} \sqrt{\sum_{i=1}^{n}(y_i - \bar y)^2}}
#' $$
#' 
#' При вычислении индекса Морана происходит нечто подобное, но под соответствием понимается наличие соседства между $i$-й и $j$-й территориальной единицей. Степень выраженности соседства задается весом $W_{ij}$, который можно наблюдать в числителе формулы индекса Морана. Таким образом, пары территориальных единиц, для которых $w_{ij} = 0$, не участвуют в вычислении индекса Морана.
#' 
#' Индекс Морана для нормально распределенных данных лежит в диапазоне от -1 до 1:
#' 
#' * +1 означает детерминированную прямую зависимость — группировку схожих (низких
#'    или высоких) значений. 
#' * 0 означает абсолютно случайное распределение (_CSR — complete spatial randomness_)
#' * -1 означает детерминированную обратную зависимость — идеальное перемешивание
#'    низких и высоких значений, напоминающее шахматную доску
#' 
#' Для вычисления индекса Морана следует использовать функцию `moran.test()`, которая дополнительно оценивает статистическую значимость полученного значения:
## ---- message = FALSE, collapse=TRUE-------------------------------------
# Вычисление индекса (тест) Морана
moran.test(mun$Февраль, W)

#' 
#' Результаты теста включают в себя следующие значения:
#' 
#' * __Moran I statistic__ — полученный индекс Морана
#' * __Expectation__ — математическое ожидание индекса при нулевой гипотезе $E[I]$
#' * __Variance__ — дисперсия ожидаемого значения при нулевой гипотезе $D[I]$
#' * __Moran I statistic standard deviate__ — $Z$-оценка вычисленного индекса Морана
#' * __p-value__ — $p$-значение вычисленного индекса Морана
#' 
#' Здесь мы видим, что значение индекса Морана равно ~$0.52$ (__Moran I statistic__), то есть присутствует положительная пространственная автокорреляция. При этом вероятность того, что мы ошибаемся в наших выводах, и распределение на самом деле случайно - крайне мала и равна $2.408 \times 10^{-7})$ (__p-value__), то есть менее $0.0001\%$. Можно принимать гипотезу о наличии пространственной автокорреляции.
#' 
#' Рассмотрим чуть подробнее, откуда берутся эти и остальные значения результатов теста, и как их правильно интерпретировать. 
#' 
#' Обычно для сравнения принимают предположение о том, что исследуемая величина распределена случайно. Это так называемая "нулевая" гипотеза. После того как мы вычислили индекс Морана по фактическим данным, можно вычислить его аналитически, приняв нулевую гипотезу. В этом случае математическое ожидание индекса $E[I] = -1/(n-1)$, где $n$ - количество территориальных единиц. Также может быть вычислена и дисперсия индекса Морана $D[I]$ (в англоязычной литературе дисперсия обозначается $V[I]$).
#' 
#' Эти два параметра определяют функцию распределения индекса Морана при всевозможных случайных расстановках исследуемой величины по территориальным единицам. Грубо говоря, такое распределение получится, если мы извлечем все фактические данные, будем их случайным образом перемешивать между территориями и каждый раз вычислять индекс Морана, повторяя процедуру бесконечное число раз. Полученные индексы будут распределены нормально.
#' 
#' Значимость фактического индекса Морана можно оценить путем его сравнения с ожидаемым значением индекса $E[I]$ и его стандартным отклонением $s = \sqrt D$ Для такой оценки используется $Z$-тест Фишера. $Z$-значение вычисляется по формуле: $Z = (I - E[I])/s$
#' 
#' Эта величина говорит нам о том, на какое количество стандартных отклонений фактическое значение индекса Морана удалено от ожидаемого значения. Чем сильнее оно удалено — тем менее вероятно, что фактическое распределение случайно. Какова же эта вероятность? Каждому значению $Z$-score соответствует $p$-значение (_p-value_). _P-value_ — это вероятность появления значений, удаленных от мат. ожидания далее чем $Z$-score.
#' 
#' Например, при: 
#' 
#' * $Z < -1.96$ или $Z > +1.96$ значение $p < 0.05$
#' * $Z < -2.58$ или $Z > +2.58$ значение $p < 0.01$
#'               
#' Это означает, что вероятность того, что фактическое значение индекса Морана могло бы появиться на основе случайно распределенных данных с вероятностью $5\%$ и $1\%$ соответственно. Чем меньше $p$, тем менее вероятно, что распределение случайно. Говорят, что $p$ — это вероятность сделать ошибку первого рода, т.е. отвергнуть нулевую гипотезу, в то время как она на самом деле является истинной.
#' 
#' ### Перестановочный тест
#' 
#' Графически вышеприведенные рассуждения можно иллюстрировать с помощью перестановочного теста (__permutation test__). Для этого значения исследуемой нами величины перемешиваются между территориальными единицами и далее строится гистограмма распределения. Перестановочный тест выполняется с помощью функции `moran.mc()` с параметром `nsim =`, задающим число перестановок:
## ---- message = FALSE, results = "hide", collapse=TRUE-------------------
sim<-moran.mc(mun$Февраль, listw = W, nsim = 10000)
sim

# Построим гистограмму по вычисленным индексам:
hist(sim$res,
     freq=TRUE,
     breaks=20, 
     xlim = c(-1,1),
     main = "Перестановочный тест Морана", 
     xlab = "Случайный индекс Морана",
     ylab = "Частота появления",
     col = "steelblue")

# Нанесем фактическое значение
abline(v = sim$statistic, col = "red")

#' 
#' ### Диаграмма рассеяния Морана
#' 
#' Наконец, еще одним графическим инструментом оценки пространственной автокорреляции является диаграмма рассеяния Морана. По оси $X$ откладывается значение в каждой территориальной единице, в по оси $Y$ — ее пространственный лаг, который представляет собой средневзвешенное значение по всем ее соседям: 
## ---- message = FALSE, results = "hide", collapse=TRUE-------------------
moran.plot(mun$Февраль, W)

#' 
#' На диаграмме рассеяния Морана линиями отмечаются средние значения по обеим осям, а наклонной линией представляется линейная регрессия этих значений, при этом тангенс угла наклона кривой равен значению индекса Морана. Поскольку в данном случае распределение явно не случайно, можно приступать к его моделированию.
#' 
#' 
#' ## Пространственная авторегрессия (моделирование автокорреляции)
#' 
#' В статистике моделирование данных, обладающих автокорреляцией, осуществаляется с помощью авторегрессионных моделей (AR-моделей). Авторегрессионная модель связывает значения временного ряда в данный момент с предыдущими значениями этого же ряда. В пространственной статистике используется аналогичная методика, только в роли данного момента выступает данная территориальная единица, а в роли предыдущих значений — значения в соседних территориальных единицах (см. презентацию). После того как параметры пространственной авторегрессии подобраны, можно вычислить значение в каждой единице по соседним значениям, а также ошибку полученного значения путем вычитания из реального значения.
#' 
#' Простейшая модель пространственной авторегрессии строится как:
#' $$
#' Z = \mu + \sum b(z-\mu) + \epsilon
#' $$
#' где $Z$ - значение в текущей единице, $z$ - значение в соседней единице, $\mu$ — среднее значение (вычисленное по всем единицам), $b$ - весовой коэффициент и $ε$ — случайная ошибка. 
#' 
#' Подобное уравнение может быть составлено для каждой территориальной единицы. При этом суммирование производится по всем соседним территориальным единицам а неизвестный коэффициент $b$ обычно представляют в виде $b = \lambda w$, то есть как отмасштабированный на величину $\lambda$ вес связи между единицей и ее текущим соседом. Задача построения модели строится к поиску такого значения $\lambda$, который бы минимизировал сумму квадратов ошибок ε по всем территориальным единицам.
#' 
#' Если мы знаем, что в каждой единице значение связано не только с окружением, но также с другой величиной, то это можно моделировать заменив в вышеприведенном уравнении $\mu$ на $a + bY$, где $Y$ — объясняющая величина, а коэффициенты $a$ и $b$ подбираются путем построения линейной регрессии между $Z$ и $Y$.
#' 
#' Для построения модели пространственной авторегрессии используется функция `spautolm()`, принимающая два основных параметра — формулу и матрицу пространственных весов. Формула — это специальный объект __R__ для обозначения статистической зависимости. Например, если в таблице `tab` есть столбец `Z`, зависящий от `X` и `Y`, то соответствующая формула будет выглядеть следующим образом:
#' ```
#' Z ~ X + Y
#' ```
#' 
#' В случае если зависимости нет, используется следующая нотация:
#' ```
#' Z ~ 1
#' ```
#' 
#' Мы будем использовать простейший вариант пространственной авторегрессии без объясняющих факторов $(Z = \mu + \sum \lambda w(z-\mu) + \epsilon)$. Следовательно, используем вариант `~1`:
#' 
## ---- message = FALSE, collapse=TRUE-------------------------------------
model <- spautolm(mun$Февраль ~ 1, listw=W)
model

#' 
#' Расшифровываются параметры модели следующим образом:
#' 
#' * Intercept = $\mu$,
#' * lambda = $\lambda$
#' 
#' Извлекаем модельные значения $Z$ и записываем в таблицу
## ---- message = FALSE, results = "hide", collapse=TRUE-------------------
mun$fitted <- fitted(model)

# Извлекаем остатки ε и записываем в таблицу
mun$residuals <- residuals(model)

# Сравниваем исходные данные, модельные и остатки
spplot(mun, 
       zcol=c("Февраль","fitted", "residuals"),
       names.attr = c("Фактические значения", "Модель", "Остатки"),
       at = levels, 
       col.regions = ramp(nclasses))

