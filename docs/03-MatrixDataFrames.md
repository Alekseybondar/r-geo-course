# Матрицы, фреймы данных и списки {#matrix_dataframes}

В это модуле мы продвинемся дальше в изучении структур данных языка и рассмотрим такие важные его элементы как матрицы, фреймы данных и списки.

## Матрицы {#matrices}

Матрица — это обобщение понятия вектора на 2 измерения. С точки зрения анализа данных матрицы ближе к реальным данным, посколько каждая матрица по сути представляет собой таблицу со столбцами и строками. Однако матрица, как и вектор, может содержать только элементы одного типа (числовые, строковые, логические и т.д.). Позже мы познакомимся с фреймами данных, которые не обладают подобным ограничением. А пока рассмотрим, как работать с двумерными данными на примере матриц.

Матрица, как правило, создается с помощью функции `matrix`, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов:

```r
v <- 1:12  # создадим вектор из натуральных чисел от 1 до 12
m <- matrix(v, nrow = 3, ncol = 4)
m
##      [,1] [,2] [,3] [,4]
## [1,]    1    4    7   10
## [2,]    2    5    8   11
## [3,]    3    6    9   12
```
По умолчанию матрица заполняется данными вектора по столбцам, что можно видеть в выводе программы. Если вы хотите заполнить ее по строкам, необходимо указать параметр `byrow = TRUE`:

```r
m <- matrix(v, nrow = 3, ncol = 4, byrow = TRUE)
m
##      [,1] [,2] [,3] [,4]
## [1,]    1    2    3    4
## [2,]    5    6    7    8
## [3,]    9   10   11   12
```
Доступ к элементам матрицы осуществляется аналогично вектору, за исключением того что нужно указать положение ячейки в строке и столбце:

```r
m[2,4]  # 2 строка, 4 толбец
## [1] 8
m[3,1]  # 3 строка, 1 столбец
## [1] 9
```
Помимо этого, из матрицы можно легко извлечь одну строку или один столбец. Для этого достаточно указать только номер строки или столбца, а номер второго измерения пропустить до или после запятой. Результат является вектором:

```r
m[2,]  # 2 строка
## [1] 5 6 7 8
m[,3]  # 3 cтолбец
## [1]  3  7 11
```
К матрицам можно применять операции, аналогичные операциям над векторами:

```r
log(m)  # натуральный логарифм ото всех элементов
##          [,1]      [,2]     [,3]     [,4]
## [1,] 0.000000 0.6931472 1.098612 1.386294
## [2,] 1.609438 1.7917595 1.945910 2.079442
## [3,] 2.197225 2.3025851 2.397895 2.484907
sum(m)  # сумма всех элементов матрицы
## [1] 78
median(m) # медиана
## [1] 6.5
```
А вот сортировка матрицы приведет к тому что будет возвращен обычный вектор:

```r
sort(m)
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12
```
К матрицам также применимы специальные функции, известные из линейной алгебры, такие как транспонирование и вычисление определителя:

```r
t(m)  # транспонированная матрица
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
m2<-matrix(-3:3,nrow = 3, ncol = 3)
## Warning in matrix(-3:3, nrow = 3, ncol = 3): длина данных [7] не является
## множителем количества строк [3]
m2
##      [,1] [,2] [,3]
## [1,]   -3    0    3
## [2,]   -2    1   -3
## [3,]   -1    2   -2
det(m2) # определитель матрицы
## [1] -21
det(m)  # ошибка! определитель вычисляется только для квадратных матриц
## Error in determinant.matrix(x, logarithm = TRUE, ...): 'x' должен быть квадратной матрицей
```
Матрицы также можно перемножать с помощью специального оператора `%*%`. При этом, как мы помним, число столбцов в первой матрице должно равняться числу строк во второй:

```r
m2 %*% m
##      [,1] [,2] [,3] [,4]
## [1,]   24   24   24   24
## [2,]  -24  -28  -32  -36
## [3,]   -9  -10  -11  -12
m %*% m2  # ошибка!
## Error in m %*% m2: неподобные аргументы
```
Функция `match()`, которую мы использовали для поиска элементов в векторе, не работает для матриц. Вместо этого необходимо использовать функцию `which()`. Если мы хотим найти в матрице m позицию числа $8$, то вызов функции будет выглядеть так:

```r
which(m == 8, arr.ind = TRUE)
##      row col
## [1,]   2   4
```
В данном случае видно, что результат возвращен в виде матрицы $1 \times 2$. Обратите внимание на то, что колонки матрицы имеют названия. Попробуем использовать найденные индексы, чтобы извлечь искомый элемент:

```r
indexes <- which(m == 8, arr.ind = TRUE)
row <- indexes[1,1]
col <- indexes[1,2]
m[row,col]
## [1] 8
```
Ура! Найденный элемент действительно равен $8$.

Еще один полезный способ создания матрицы — это собрать ее из нескольких векторов, объединив их по строкам. Для этого можно использовать функции `cbind()` и `rbind()`. На предыдущем занятии мы создали векторы с длиной и количеством станций на разных ветках метро. Можно объединить их в одну матрицу:

```r
lengths <- c(28, 40, 45, 19, 38)
stations <- c(20, 21, 22, 12, 24)
cbind(lengths, stations)  # соединим вектора в качестве столбцов
##      lengths stations
## [1,]      28       20
## [2,]      40       21
## [3,]      45       22
## [4,]      19       12
## [5,]      38       24
rbind(lengths, stations)  # соединим вектора в качестве строк
##          [,1] [,2] [,3] [,4] [,5]
## lengths    28   40   45   19   38
## stations   20   21   22   12   24
```
Cтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций:

```r
mm <- cbind(lengths, stations)
mm[,2]/mm[,1]  # количество станций на 1 км пути
## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789
```
Результат можно присоединить к уже созданной матрице:

```r
dens <- mm[,2]/mm[,1]
mm<-cbind(mm, dens)
mm
##      lengths stations      dens
## [1,]      28       20 0.7142857
## [2,]      40       21 0.5250000
## [3,]      45       22 0.4888889
## [4,]      19       12 0.6315789
## [5,]      38       24 0.6315789
```
Содержимое матрицы можно просмотреть в более привычном табличном виде для этого откройте вкладку _Environment_ и щелкните на строку с матрицей в разделе _Data_

Матрицы, однако, не дотягивают по функциональности до представления таблиц, и, в общем-то, не предназначены для объединения разнородных данных в один набор (как мы это сделали). Если вы присоедините к матрице столбец с названиями веток метро, система не выдаст сообщение об ошибке, но преобразует матрицу в текстовую, так как текстовый тип данных способен представить любой другой тип данных:

```r
colors <- c("Красная", "Зеленая", "Синяя", "Коричневая", "Оранжевая")
mm2<-cbind(mm,colors)
mm2  # обратите внимание на то, что вокруг чисел добавились кавычки
##      lengths stations dens                colors      
## [1,] "28"    "20"     "0.714285714285714" "Красная"   
## [2,] "40"    "21"     "0.525"             "Зеленая"   
## [3,] "45"    "22"     "0.488888888888889" "Синяя"     
## [4,] "19"    "12"     "0.631578947368421" "Коричневая"
## [5,] "38"    "24"     "0.631578947368421" "Оранжевая"
```
При попытке выполнить арифметическое выражение над прежде числовыми полями, вы получите сообщение об ошибке:

```r
mm2[,2]/mm2[,1]
## Error in mm2[, 2]/mm2[, 1]: нечисловой аргумент для бинарного оператора
```

## Массивы {#arrays}

_Массивы (arrays)_ --- это многомерные структуры данных, с колчеством измерений 3 и более. Трехмерный массив представляет собой куб однородных данных. Массивы возникают тогда, например, когда имеются временные данные, зафиксированные в неких географических локациях. При этом 2 измерения отвечают за местоположение, а третье измерение — за временной срез.

## Фреймы данных {#data_frames}

_Фреймы данных_ — это обобщение понятия матрицы на данные смешанных типов. Фреймы данных - наиболее распространенный формат представления табличных данных. Для краткости мы иногда будем называть их просто фреймами.

> Мы специально не используем для перевода слова `data.frame` термин 'таблица', поскольку таблица — это достаточно общая категория, которая описывает концептуальный способ упорядочивания данных. В том же языке R для представления таблиц могут быть использованы как минимум две структуры данных: фрейм данных (data.frame) и тиббл (tibble), доступный в соответствующем [пакете](https://cran.r-project.org/web/packages/tibble/index.html). Мы не будем использовать тибблы в настоящем курсе, но после его освоения вы вполне сможете ознакомиться с ними самостоятельною

Для создания фреймов данных используется функция `data.frame()`:

```r
t<-data.frame(colors,lengths,stations)
t  # как мы видим, уже никаких кавычек вокруг чисел
##       colors lengths stations
## 1    Красная      28       20
## 2    Зеленая      40       21
## 3      Синяя      45       22
## 4 Коричневая      19       12
## 5  Оранжевая      38       24
```
К фреймам также можно пристыковывать новые столбцы:

```r
t<-cbind(t, dens)
t
##       colors lengths stations      dens
## 1    Красная      28       20 0.7142857
## 2    Зеленая      40       21 0.5250000
## 3      Синяя      45       22 0.4888889
## 4 Коричневая      19       12 0.6315789
## 5  Оранжевая      38       24 0.6315789
```
Когда фрейм данных формируется посредством функции `data.frame()` и `cbind()`, названия столбцов берутся из названий векторов. Обратите внимание на то, что листинге выше столбцы имеют заголовки, а строки — номера.

Как и прежде, к столбцам и строкам можно обращаться по индексам:

```r
t[2,2]
## [1] 40
t[,3]
## [1] 20 21 22 12 24
t[4,]
##       colors lengths stations      dens
## 4 Коричневая      19       12 0.6315789
```
Вы можете обращаться к отдельным столбцам фрейма данных по их названию, используя оператор `$` (доллар):

```r
t$lengths
## [1] 28 40 45 19 38
t$stations
## [1] 20 21 22 12 24
```
Так же как и ранее, можно выполнять различные операции над столбцами:

```r
max(t$stations)
## [1] 24
t$lengths / t$stations
## [1] 1.400000 1.904762 2.045455 1.583333 1.583333
```
Названия столбцов можно получить с помощью функции `colnames()`

```r
colnames(t)
## [1] "colors"   "lengths"  "stations" "dens"
```
Чтобы присоединить строку, сначала можно создать фрейм данных из одной строки:

```r
row<-data.frame("Фиолетовая", 40.5, 22, 22/45)
```
Далее нужно убедиться, что столбцы в этом мини-фрейме называются также как и в той, куда мы хотим присоединить строку. Для этого нужно перезаписать результат, возвращаемый функцией `colnames()`:

```r
colnames(row) <- colnames(t)
```
Обратите внимание на синтаксис вышеприведенного выражения. Когда функция возвращает результат, она обнаруживает свойство самого объекта, и мы можем его перезаписать. После того как столбцы приведены в соответствие, можно присоединить новую строку:

```r
t<-rbind(t,row)
```
Поскольку названия столбцов хранятся как вектор из строк, мы можем их переделать:

```r
colnames(t)<-c("Цвет","Длина","Станции","Плотность")
colnames(t)
## [1] "Цвет"      "Длина"     "Станции"   "Плотность"
```
Обратимся по новому названию столбца:

```r
t$Длина
## [1] 28.0 40.0 45.0 19.0 38.0 40.5
t
##         Цвет Длина Станции Плотность
## 1    Красная  28.0      20 0.7142857
## 2    Зеленая  40.0      21 0.5250000
## 3      Синяя  45.0      22 0.4888889
## 4 Коричневая  19.0      12 0.6315789
## 5  Оранжевая  38.0      24 0.6315789
## 6 Фиолетовая  40.5      22 0.4888889
```

## Списки {#lists}

Список — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа. В качестве элементов списка могут быть числа, строки, вектора, матрицы, фреймы данных — и все это в одном контейнере. Списки используются чтобы комбинировать разрозненную информацию. Результатом выполнения многих функций является список.

Например, можно создать список из текстового описания фрейма данных, самого фрейма данных и обобщающей статистики по нему:

```r
d <- "Этт фрейм данных содержит данные по 6 линиям Московского метро"
s <- summary(t)  # summary() выдает обобщающую статистику вектору, матрице или фрейму данных
```
Сооружаем список из трех элементов:

```r
metrolist <- list(d,t,s)
metrolist
## [[1]]
## [1] "Этт фрейм данных содержит данные по 6 линиям Московского метро"
## 
## [[2]]
##         Цвет Длина Станции Плотность
## 1    Красная  28.0      20 0.7142857
## 2    Зеленая  40.0      21 0.5250000
## 3      Синяя  45.0      22 0.4888889
## 4 Коричневая  19.0      12 0.6315789
## 5  Оранжевая  38.0      24 0.6315789
## 6 Фиолетовая  40.5      22 0.4888889
## 
## [[3]]
##          Цвет       Длина          Станции        Плотность     
##  Зеленая   :1   Min.   :19.00   Min.   :12.00   Min.   :0.4889  
##  Коричневая:1   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  
##  Красная   :1   Median :39.00   Median :21.50   Median :0.5783  
##  Оранжевая :1   Mean   :35.08   Mean   :20.17   Mean   :0.5800  
##  Синяя     :1   3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  
##  Фиолетовая:1   Max.   :45.00   Max.   :24.00   Max.   :0.7143
```
Можно дать элементам списка осмысленные названия при создании:

```r
metrolist <- list(desc = d, table = t, summary = s)
metrolist
## $desc
## [1] "Этт фрейм данных содержит данные по 6 линиям Московского метро"
## 
## $table
##         Цвет Длина Станции Плотность
## 1    Красная  28.0      20 0.7142857
## 2    Зеленая  40.0      21 0.5250000
## 3      Синяя  45.0      22 0.4888889
## 4 Коричневая  19.0      12 0.6315789
## 5  Оранжевая  38.0      24 0.6315789
## 6 Фиолетовая  40.5      22 0.4888889
## 
## $summary
##          Цвет       Длина          Станции        Плотность     
##  Зеленая   :1   Min.   :19.00   Min.   :12.00   Min.   :0.4889  
##  Коричневая:1   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  
##  Красная   :1   Median :39.00   Median :21.50   Median :0.5783  
##  Оранжевая :1   Mean   :35.08   Mean   :20.17   Mean   :0.5800  
##  Синяя     :1   3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  
##  Фиолетовая:1   Max.   :45.00   Max.   :24.00   Max.   :0.7143
```
Теперь можно обратиться к элементу списка по его названию:

```r
metrolist$summary
##          Цвет       Длина          Станции        Плотность     
##  Зеленая   :1   Min.   :19.00   Min.   :12.00   Min.   :0.4889  
##  Коричневая:1   1st Qu.:30.50   1st Qu.:20.25   1st Qu.:0.4979  
##  Красная   :1   Median :39.00   Median :21.50   Median :0.5783  
##  Оранжевая :1   Mean   :35.08   Mean   :20.17   Mean   :0.5800  
##  Синяя     :1   3rd Qu.:40.38   3rd Qu.:22.00   3rd Qu.:0.6316  
##  Фиолетовая:1   Max.   :45.00   Max.   :24.00   Max.   :0.7143
```
Поскольку `summary` сама является фреймом данных, из нее можно извлечь столбец:

```r
metrolist$summary[,3]
##                                                                         
## "Min.   :12.00  " "1st Qu.:20.25  " "Median :21.50  " "Mean   :20.17  " 
##                                     
## "3rd Qu.:22.00  " "Max.   :24.00  "
```
К элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в _двойные_ квадратные скобки:

```r
metrolist[[1]]
## [1] "Этт фрейм данных содержит данные по 6 линиям Московского метро"
metrolist[["desc"]]
## [1] "Этт фрейм данных содержит данные по 6 линиям Московского метро"
```
Использование _двойных скобок_ отличает списки от векторов.

## Контрольные вопросы и задачи {#questions_tasks_matrix}

### Вопросы {#questions_matrix}

1. Что такое матрица, массив, фрейм данных и список? Чем отличаются эти структуры данных?
1. Какие из рассмотренных в этой главе структур данных могут содержать элементы разного типа, а какие только один?
1. Какая функция позволяет создать матрицу? По строкам или по столбцам заполняется матрица при использовании вектора как источника данных по умолчанию?
1. Как извлечь элемент по его индексам из матрицы, массива, фрейма данных, списка?
1. Как извлечь строку или столбец из матрицы или фрейма данных?
1. С помощью какого специального символа можно обратиться к столбцу фрейма данных по его названию?
1. Как получить или записать названия столбцов фрейма данных?
1. Как получить или записать названия строк фрейма данных?
1. Какая структура данных является результатом сортировки матрицы?
1. Какая функция позволяет осуществить транспонирование матрицы?
1. Какой оператор используется для умножения матриц? Каким критериям должны отвечать перемножаемые матрицы, чтобы эта операция была осуществима?
1. Как добавить новый столбец в фрейм данных? Опишите несколько вариантов.
1. Как добавить новую строку в фрейм данных?
1. Что произойдет, если к целочисленной матрице прибавить столбец, заполненный строками?
1. Какая функция позволяет находить индексы элементов матрицы или фрейма данных по их значениям?

### Задачи {#tasks_matrix}

----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----
