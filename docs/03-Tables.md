# Таблицы {#tables}



[Программный код главы](https://github.com/tsamsonov/r-geo-course/blob/master/code/03-Tables.R)

__Необходимые пакеты:__ `openxlsx, readxl, readr, xlsx, dplyr`

Таблица представляет собой один из способов структурирования данных. Большинство научных данных представляется именно в виде таблиц. В настоящем модуле рассмотрены базовые процедуры обработки таблиц, такие как чтение, сортировка, фильтрация, отбор столбцов (переменных), добавление и вычисление новых строк и столбцов, поиск и исправление ошибок в данных, запись таблиц в файл. Показано, как одни и те же процедуры могут быть реализованы стандартными средствами __R__ и с помощью пакета `dplyr`.

Напомним, что для представления таблиц в __R__ используются фреймы данных. В рамках данной главы мы будем использовать оба понятия как взаимозаменяемые, предполагая, что речь идет о таблице, представленной в виде фрейма данных.

## Чтение таблиц {#reading_tables}

Существует множество файловых форматов представления табличных данных. Мы рассмотрим одни из наиболее распространенных --- __CSV__ и __Microsoft Excel__.

### Таблицы CSV {#reading_csv}

__CSV (Comma-separated value)__ --- общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу:

1. Каждая строка в файле соответствует строке в таблице
2. Ячейки отделяются друг от друга символом-разделителем.
3. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов.

Стандартным разделителем ячеек является запятая (`,`), а десятичным разделителем --- точка (`.`). Однако это не является строгим правилом.

Например, вот так выглядит таблица в формате CSV, с которой мы дальше будем работать:
```
Год;Всего;Балтийское;Черное;Азовское;Каспийское;Карское;Белое;Прочие
1993;27,2;2,5;0,4;4,3;12,1;5,3;1,0;1,6
1994;24,6;2,3;0,4;3,2;11,0;5,0;0,9;1,8
1995;24,5;2,3;0,4;3,5;10,4;5,2;0,9;1,8
1996;22,4;2,2;0,3;3,1;9,8;4,7;0,8;1,5
1997;23,0;2,2;0,3;3,8;9,8;4,4;0,8;1,7
```

Видно, что первая строка в файле занята заголовками столбцов. Формат CSV этот момент не обговаривает, поэтому при чтении таблицы нужно явным образом указывать, что данные начинаются со второй строки, а первую строку следует интерепретировать как заголовочную.

Также следует отметить, что в данном файле в качестве символа-разделителя ячеек используется точка с запятой (`;`), поскольку в русской локали запятая (`,`) зарезервирована под десятичный разделитель. Разделитель ячеек и десятичный разделитель также должны быть указаны при открытии файла, если они не соответствуют стандартным.

Таблицы в формате __CSV__ (Comma-Separated Values) можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета `readr`. Рассмотрим оба варианта. 

Для чтения таблиц с разделителем существует функция стандартной бибилиотеки `read.table()`. Ее основные параметры следующие:

- `file` --- название файла
- `sep` --- разделитель ячеек
- `dec` --- десятичный разделитель
- `header` --- содержится ли в первой строке заголовок
— `encoding` --- кодировка символов, в которой сохранен файл (чаще всего `UTF-8` или `CP1251`)

> __Стандартной кодировкой для представления текста__ в UNIX-подобных системах (_Ubuntu_, _macOS_ и т.д.) является __UTF-8 (Unicode)__, в русскоязычных версиях _Windows_ --- __CP1251 (Windows-1251)__. Текстовый файл __CSV__, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в __R__ вы видите вместо текста нечитаемые символы --- _кракозябры_ --- то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Попробуйте поменять `UTF-8` на `CP1251` или наоборот. Если вы не знаете, что такое кодировка и Юникод, то вам [сюда](https://ru.wikipedia.org/wiki/Набор_символов).

Прочтем таблицу с данными Росстата по объему сброса сточных вод в бассейны некоторых морей России (в млн. м$^3$):

```r

# Чтение таблиц CSV

tab = read.table("oxr_vod.csv",
                  sep = ';',
                  dec = ',',
                  header = TRUE,
                  encoding = 'UTF-8')
str(tab) # Посмотрим на структуру таблицы
## 'data.frame':	22 obs. of  9 variables:
##  $ Год       : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Всего     : num  27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ...
##  $ Балтийское: num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Черное    : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Азовское  : num  4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ...
##  $ Каспийское: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Карское   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ Белое     : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
##  $ Прочие    : num  1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ...
```

Существуют также специальные функции для чтения таблиц __CSV__: `read.csv()` и `read.csv2()`. По сути они являются "обертками" (_wrappers_) функции `read.table()` и выполняют ее вызов с автоматической подстановкой параметров `sep`, `dec` и `header`. Обе функции по умолчанию предполагают, что в файле имеется заголовок. `read.csv()` удобна для чтения таблиц с десятичной точкой и запятой-разделителем, а `read.csv2()` --- для таблиц с десятичной запятой и точкой-с-запятой в качестве разделителя.

Используем для чтения `read.csv2()`:

```r
tab = read.csv2("oxr_vod.csv", encoding = 'UTF-8')
str(tab) # Посмотрим на структуру таблицы
## 'data.frame':	22 obs. of  9 variables:
##  $ Год       : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Всего     : num  27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ...
##  $ Балтийское: num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Черное    : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Азовское  : num  4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ...
##  $ Каспийское: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Карское   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ Белое     : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
##  $ Прочие    : num  1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ...
```

Данная таблица не отличается от предыдущей, но ее чтение с помощью функции `read.csv2()` более компактно.

Помимо стандартной библиотеки вы можете читать таблицы CSV (и другие текстовые форматы) с помощью пакета `readr`. Одним из его преимуществ является то, что он читает таблицы примерно в 10 раз быстрее стандартной библиотеки. Аналогично стандартной библиотеки можно воспользоваться функцией `read_csv2()`. Отличие заключается только в том, что данная функция возвращает объект типа `tibble`, который является расширением фрейма данных. Если рабочий процесс предполагает использование фреймов данных, небходимо преобразовать результат к данному типу:


```r
library(readr)
tab = as.data.frame(read_csv2("oxr_vod.csv"))
str(tab) # Посмотрим на структуру таблицы
## 'data.frame':	22 obs. of  9 variables:
##  $ Год       : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Всего     : num  27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ...
##  $ Балтийское: num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Черное    : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Азовское  : num  4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ...
##  $ Каспийское: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Карское   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ Белое     : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
##  $ Прочие    : num  1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ...
##  - attr(*, "spec")=List of 2
##   ..$ cols   :List of 9
##   .. ..$ Год       : list()
##   .. .. ..- attr(*, "class")= chr  "collector_integer" "collector"
##   .. ..$ Всего     : list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   .. ..$ Балтийское: list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   .. ..$ Черное    : list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   .. ..$ Азовское  : list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   .. ..$ Каспийское: list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   .. ..$ Карское   : list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   .. ..$ Белое     : list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   .. ..$ Прочие    : list()
##   .. .. ..- attr(*, "class")= chr  "collector_double" "collector"
##   ..$ default: list()
##   .. ..- attr(*, "class")= chr  "collector_guess" "collector"
##   ..- attr(*, "class")= chr "col_spec"
```

### Таблицы Microsoft Excel {#excel_reading}

Чтение таблиц __Microsoft Excel__ не входит в возможности стандартной библиотеки R. В то же время, для этих целей существует ряд пакетов, таких как `xlsx`, `openxlsx` и `readxl`. Пакет `xlsx` требует наличия установленной среды __Java__ на компьютере, что несколько усложняет его использование. В нашей работе мы будем пользоваться пакетом `readxl`. Для чтения таблиц Excel с помощью этого пакета необходимо указать путь к файлу и номер листа:


```r
library(readxl)
sewage = read_excel("sewage.xlsx", 1)
str(sewage)
## Classes 'tbl_df', 'tbl' and 'data.frame':	97 obs. of  6 variables:
##  $ X__1: chr  "Российская Федерация" "Центральный федеральный округ" "Белгородская область" "Брянская область" ...
##  $ 2005: num  17727 4341 11 89 155 ...
##  $ 2010: num  16516 3761 77 78 129 ...
##  $ 2011: num  15966 3613 72 75 126 ...
##  $ 2012: num  15678 3651 71 71 124 ...
##  $ 2013: num  15189 3570 71 68 120 ...
```

### Типы данных столбцов {#excel_read_types}

Особого внимания при чтении таблиц заслуживает тема управления типами данных столбцов. В процессе чтения таблицы __R__ будет пытаться привести каждый столбец к одному из базовых типов, рассмотренных в первой главе. Как правило, столбцы приводятся либо к числовому (`numeric`), либо к текстовому (`character`) типу. В то же время, в таблицах часто бывают пропущенные значения (нет данных), которые выражаются в виде пустых ячеек или специальных символов (например, `-`). Также могут быть опечатки и неверно заданные разделители десятичного разряда (например, запятая вместо точки). 

В этом контексте при чтении таблиц действуют следующие правила:

- По умолчанию типы данных столбцов определяются автоматически, если не задано иное.
- По умолчанию текстовые столбцы преобразуются функциями стандартной библиотки в факторы, а функциями из пакетов `readr`, `openxlsx` и `readxl` --- остаются текстовыми столбцами.
- Если типы данных определяются автоматически, и в процессе чтения в текущем столбце обнаруживается хотя бы один нечисловой символ, столбец будет автоматически преобразован к текстовому типу. 
- Если тип данных столбца задан пользователем как числовой, и в процессе чтения в нем обнаруживается хотя бы один нечисловой символ, импорт таблицы будет прерван и вы получите сообщение об ошибке.

Управлять типами данных в фрейме данных _гораздо проще на стадии чтения таблицы_, чем уже после того, как она прочитана неправильно (см. раздел исправление ошибок в конце настоящей главы). Отсюда вытекают следующие рекомендации при чтении таблиц:

- Если вы пользуетесь стандартной библиотекой для чтения таблиц с текстовыми столбцами, запретите интерпретировать их как факторы, если это нежелательное поведение.
- Если вам известна структура таблицы, и вы не уверены в полноте и корректности ее наполнения, определите сразу при ее чтении типы столбцов, так вы поймете, все ли в порядке с данными.

В качестве примера неправильно прочитанной таблицы приведем данные о типах землепользования на Сатинском учебном полигоне географического факультета МГУ:


```r

# ТИПЫ ДАННЫХ СТОЛБЦОВ

tab2 = read.csv2("SatinoLanduse.csv", dec = '.')
str(tab2) # посмотрим, какова структура данных
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : Factor w/ 35 levels "","АО \"Родина\"",..: 30 1 1 1 1 1 1 3 2 1 ...
##  $ Perimeter     : num  2396 922 2181 3948 279 ...
##  $ Area          : Factor w/ 160 levels "0.238070145845919",..: 73 49 121 100 63 72 88 128 99 24 ...
```
Видно, что правильно прочитаны только три столбца: `ID`, хранящий идентификаторы, `Type`, хранящий тип землепользования, являющийся номинальной переменной, а также `Perimeter`, хранящий периметр участка. Текстовые столбцы `Administration` и `Comment` были также преобразованы в факторы, поскольку это стандартное поведение базовых функций __R__, хотя номинальными переменными по сути не являются. А последний столбец с площадью и вовсе не был прочитан правильно, так как содержит опечатки.

Запретить интерепретировать строки как факторы можно с помощью параметра `stringsAsFactors=FALSE`:

```r
tab2 = read.csv2("SatinoLanduse.csv", dec = '.', stringsAsFactors = FALSE)
str(tab2) # посмотрим, какова структура данных
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : chr  "Территории населенных пунктов" "Выгоны" "Выгоны" "Пашни" ...
##  $ Administration: chr  "Совьяковская сельская администрация" "Совьяковская сельская администрация" "Совьяковская сельская администрация" "" ...
##  $ Comment       : chr  "Село Беницы" "" "" "" ...
##  $ Perimeter     : num  2396 922 2181 3948 279 ...
##  $ Area          : chr  "286159.158855028570000" "21651.963989321295000" "56826.463220403260000" "450293.758854912190000" ...
```

Функции из пакета `readr` делают это по умолчанию:

```r
tab2 = as.data.frame(read_csv2("SatinoLanduse.csv"))
str(tab2) # посмотрим, какова структура данных
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : chr  "Территории населенных пунктов" "Выгоны" "Выгоны" "Пашни" ...
##  $ Administration: chr  "Совьяковская сельская администрация" "Совьяковская сельская администрация" "Совьяковская сельская администрация" NA ...
##  $ Comment       : chr  "Село Беницы" NA NA NA ...
##  $ Perimeter     : num  2.40e+18 9.22e+17 2.18e+18 3.95e+18 2.79e+17 ...
##  $ Area          : chr  "286159.158855028570000" "21651.963989321295000" "56826.463220403260000" "450293.758854912190000" ...
##  - attr(*, "spec")=List of 2
##   ..$ cols   :List of 6
##   .. ..$ ID            : list()
##   .. .. ..- attr(*, "class")= chr  "collector_integer" "collector"
##   .. ..$ Type          : list()
##   .. .. ..- attr(*, "class")= chr  "collector_character" "collector"
##   .. ..$ Administration: list()
##   .. .. ..- attr(*, "class")= chr  "collector_character" "collector"
##   .. ..$ Comment       : list()
##   .. .. ..- attr(*, "class")= chr  "collector_character" "collector"
##   .. ..$ Perimeter     : list()
##   .. .. ..- attr(*, "class")= chr  "collector_number" "collector"
##   .. ..$ Area          : list()
##   .. .. ..- attr(*, "class")= chr  "collector_character" "collector"
##   ..$ default: list()
##   .. ..- attr(*, "class")= chr  "collector_guess" "collector"
##   ..- attr(*, "class")= chr "col_spec"
```

_Надежны надежный способ убедиться, что все данные прочитаны с нужным типом --- определить типы данных в столбцах._ Для функций базовой библиотеки R названия типов совпадают с названиями стандартных типов данных. Необходимо сформировать вектор из названий типов (по количеству столбцов) и передать его в качестве параметра `colClasses`:

```r
classes = c("integer", "character", "character", "character", "numeric", "numeric")
tab2 = read.csv2("SatinoLanduse.csv", 
                 dec = '.', 
                 stringsAsFactors = FALSE, 
                 colClasses = classes)
## Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : 'scan()' ожидает 'a real', а не '89499,573298880117000'
```
В данном случае последний столбец вызывает ошибку, что говорит о том, что содержищиеся в нем данные надо исправлять (см. параграф "Исправление ошибок" в конце главы).

## Просмотр таблицы {#view_table}

Для просмотра фрейма данных в консоли __RStudio__ вы можете использовать несколько опций. Пусть наш фрейм данных называется `tab`. Тогда:

1. `print(tab)` --- выводит фрейм в консоль целиком (можно написать просто `tab` в консоли).
2. `head(tab, n)` --- отбирает первые $n$ строк фрейма 
3. `tail(tab, n)` --- отбирает последние $n$ строк фрейма

По умолчанию для функций `head()` и `tail()` $n=6$. Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли `head(tab)` или `tail(tab)`, то для выбранных строк будет вызвана функция `print()`, аналогично выводу всего фрейма:

```r

# ПРОСМОТР ТАБЛИЦЫ

print(tab)
##     Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие
## 1  1993  27.2        2.5    0.4      4.3       12.1     5.3   1.0    1.6
## 2  1994  24.6        2.3    0.4      3.2       11.0     5.0   0.9    1.8
## 3  1995  24.5        2.3    0.4      3.5       10.4     5.2   0.9    1.8
## 4  1996  22.4        2.2    0.3      3.1        9.8     4.7   0.8    1.5
## 5  1997  23.0        2.2    0.3      3.8        9.8     4.4   0.8    1.7
## 6  1998  22.0        2.2    0.3      3.2        9.5     4.2   0.8    1.8
## 7  1999  20.7        2.2    0.3      2.5        9.1     4.1   0.8    1.7
## 8  2000  20.3        2.2    0.3      2.0        9.2     4.2   0.9    1.5
## 9  2001  19.8        2.1    0.3      1.9        8.9     4.2   0.9    1.5
## 10 2002  19.8        2.0    0.2      2.0        9.2     4.1   0.8    1.5
## 11 2003  19.0        2.0    0.2      2.1        8.4     4.0   0.8    1.5
## 12 2004  18.5        2.0    0.2      2.1        8.3     3.8   0.8    1.3
## 13 2005  17.7        2.0    0.2      1.6        8.0     3.8   0.8    1.3
## 14 2006  17.5        1.9    0.2      1.7        7.8     3.8   0.8    1.3
## 15 2007  17.2        1.9    0.2      1.7        7.4     3.8   0.8    1.4
## 16 2008  17.1        1.9    0.2      1.6        7.5     3.9   0.8    1.2
## 17 2009  15.9        1.8    0.2      1.5        6.8     3.5   0.7    1.4
## 18 2010  16.5        2.0    0.2      1.6        7.3     3.3   0.7    1.4
## 19 2011  16.0        1.9    0.2      1.6        7.1     3.2   0.7    1.3
## 20 2012  15.7        1.8    0.2      1.6        7.0     3.0   0.7    1.4
## 21 2013  15.2        1.8    0.2      1.6        6.9     3.0   0.6    1.1
## 22 2014  14.8        1.7    0.2      1.5        6.4     3.2   0.6    1.2
head(tab)
##    Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие
## 1 1993  27.2        2.5    0.4      4.3       12.1     5.3   1.0    1.6
## 2 1994  24.6        2.3    0.4      3.2       11.0     5.0   0.9    1.8
## 3 1995  24.5        2.3    0.4      3.5       10.4     5.2   0.9    1.8
## 4 1996  22.4        2.2    0.3      3.1        9.8     4.7   0.8    1.5
## 5 1997  23.0        2.2    0.3      3.8        9.8     4.4   0.8    1.7
## 6 1998  22.0        2.2    0.3      3.2        9.5     4.2   0.8    1.8
tail(tab)
##     Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие
## 17 2009  15.9        1.8    0.2      1.5        6.8     3.5   0.7    1.4
## 18 2010  16.5        2.0    0.2      1.6        7.3     3.3   0.7    1.4
## 19 2011  16.0        1.9    0.2      1.6        7.1     3.2   0.7    1.3
## 20 2012  15.7        1.8    0.2      1.6        7.0     3.0   0.7    1.4
## 21 2013  15.2        1.8    0.2      1.6        6.9     3.0   0.6    1.1
## 22 2014  14.8        1.7    0.2      1.5        6.4     3.2   0.6    1.2
```

`RStudio`, разумеется, имеет "человеческий" интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать. Чтобы его активировать, надо вызвать функцию `View()`:

```r
View(tab)
```
<!--html_preserve--><div id="htmlwidget-f2fd1d2b706039686f10" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-f2fd1d2b706039686f10">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22"],[1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014],[27.2,24.6,24.5,22.4,23,22,20.7,20.3,19.8,19.8,19,18.5,17.7,17.5,17.2,17.1,15.9,16.5,16,15.7,15.2,14.8],[2.5,2.3,2.3,2.2,2.2,2.2,2.2,2.2,2.1,2,2,2,2,1.9,1.9,1.9,1.8,2,1.9,1.8,1.8,1.7],[0.4,0.4,0.4,0.3,0.3,0.3,0.3,0.3,0.3,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2],[4.3,3.2,3.5,3.1,3.8,3.2,2.5,2,1.9,2,2.1,2.1,1.6,1.7,1.7,1.6,1.5,1.6,1.6,1.6,1.6,1.5],[12.1,11,10.4,9.8,9.8,9.5,9.1,9.2,8.9,9.2,8.4,8.3,8,7.8,7.4,7.5,6.8,7.3,7.1,7,6.9,6.4],[5.3,5,5.2,4.7,4.4,4.2,4.1,4.2,4.2,4.1,4,3.8,3.8,3.8,3.8,3.9,3.5,3.3,3.2,3,3,3.2],[1,0.9,0.9,0.8,0.8,0.8,0.8,0.9,0.9,0.8,0.8,0.8,0.8,0.8,0.8,0.8,0.7,0.7,0.7,0.7,0.6,0.6],[1.6,1.8,1.8,1.5,1.7,1.8,1.7,1.5,1.5,1.5,1.5,1.3,1.3,1.3,1.4,1.2,1.4,1.4,1.3,1.4,1.1,1.2]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Год<\/th>\n      <th>Всего<\/th>\n      <th>Балтийское<\/th>\n      <th>Черное<\/th>\n      <th>Азовское<\/th>\n      <th>Каспийское<\/th>\n      <th>Карское<\/th>\n      <th>Белое<\/th>\n      <th>Прочие<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5,6,7,8,9]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Поскольку функции `head()` и `tail()` возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции `View()`:


```r
View(head(sewage, 3))
```
<!--html_preserve--><div id="htmlwidget-f4b53d2576356e377549" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-f4b53d2576356e377549">{"x":{"filter":"none","data":[["1","2","3"],["Российская Федерация","Центральный федеральный округ","Белгородская область"],[17727,4341,11],[16516,3761,77],[15966,3613,72],[15678,3651,71],[15189,3570,71]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>X__1<\/th>\n      <th>2005<\/th>\n      <th>2010<\/th>\n      <th>2011<\/th>\n      <th>2012<\/th>\n      <th>2013<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":[2,3,4,5,6]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

> __Как правило, не следует оставлять вызовы функции `View()` в тексте законченной программы.__ Это приведет к тому, что при запуске будут открываться новые вкладки с просмотром таблиц, что может раздражать пользователя (в том числе и вас самих). Используйте `View()` для вывода окончательного результата в конце программы или при отладке программы. Все вызовы `View()` в программе  можно легко закомментировать или раскомментировать, выполнив поиск с заменой `'View('` на `'# View('` и наоборот.

## Работа со столбцами {#working_with_columns}

### Названия столбцов {#colnames}

Для просмотра и изменения названий столбцов фрейма данных следует использовать функцию `colnames()`:

```r

# РАБОТА СО СТОЛБЦАМИ

# Просмотрим текущие названия
colnames(sewage)
## [1] "X__1" "2005" "2010" "2011" "2012" "2013"
colnames(tab)
## [1] "Год"        "Всего"      "Балтийское" "Черное"     "Азовское"  
## [6] "Каспийское" "Карское"    "Белое"      "Прочие"

# Заменим их на новые
colnames(sewage) = c("Region", "Year05", "Year10", "Year11", "Year12", "Year13")
colnames(tab) = c("Year", "Total", "Baltic", "Black", "Azov", "Caspian", "Kara", "White", "Other")

# Проверим результат
colnames(sewage)
## [1] "Region" "Year05" "Year10" "Year11" "Year12" "Year13"
colnames(tab)
## [1] "Year"    "Total"   "Baltic"  "Black"   "Azov"    "Caspian" "Kara"   
## [8] "White"   "Other"
```

### Обращение к столбцам {#col_calling}

К столбцу можно обращаться по номеру и названию (с помощью оператора `$` или в кавычках внутри скобок). Если вы указываете в квадратных скобках номер без запятой, он трактуется именно как номер столбца, а не строки. Тип возвращаемого значения зависит от синтаксиса:

- обращение через `$` возвращает вектор;
- обращение в скобках с запятой к одному столбцу возвращает вектор;
- обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных;
- обращение в скобках без запятой возвращает фрейм данных.

Несколько примеров:

```r
a = head(sewage)

# Один столбец - результат зависит от запятой
a$Year05      # столбец в виде вектора
## [1] 17727  4341    11    89   155   169
a[, "Year05"] # столбец в виде вектора
## # A tibble: 6 x 1
##   Year05
##    <dbl>
## 1  17727
## 2   4341
## 3     11
## 4     89
## 5    155
## 6    169
a[, 2]        # столбец в виде вектора
## # A tibble: 6 x 1
##   Year05
##    <dbl>
## 1  17727
## 2   4341
## 3     11
## 4     89
## 5    155
## 6    169

a["Year05"] # столбец в виде фрейма данных
## # A tibble: 6 x 1
##   Year05
##    <dbl>
## 1  17727
## 2   4341
## 3     11
## 4     89
## 5    155
## 6    169
a[2]        # столбец в виде фрейма данных
## # A tibble: 6 x 1
##   Year05
##    <dbl>
## 1  17727
## 2   4341
## 3     11
## 4     89
## 5    155
## 6    169

# Несколько столбцов - всегда фрейм данных
a[, c(1, 4)]              # столбцы в виде фрейма данных
## # A tibble: 6 x 2
##   Region                        Year11
##   <chr>                          <dbl>
## 1 Российская Федерация           15966
## 2 Центральный федеральный округ   3613
## 3 Белгородская область              72
## 4 Брянская область                  75
## 5 Владимирская область             126
## 6 Воронежская область              135
a[, c("Region", "Year11")]# столбцы в виде фрейма данных
## # A tibble: 6 x 2
##   Region                        Year11
##   <chr>                          <dbl>
## 1 Российская Федерация           15966
## 2 Центральный федеральный округ   3613
## 3 Белгородская область              72
## 4 Брянская область                  75
## 5 Владимирская область             126
## 6 Воронежская область              135
a[c("Region", "Year11")]  # столбцы в виде фрейма данных
## # A tibble: 6 x 2
##   Region                        Year11
##   <chr>                          <dbl>
## 1 Российская Федерация           15966
## 2 Центральный федеральный округ   3613
## 3 Белгородская область              72
## 4 Брянская область                  75
## 5 Владимирская область             126
## 6 Воронежская область              135
a[c(1, 4)]                # столбцы в виде фрейма данных
## # A tibble: 6 x 2
##   Region                        Year11
##   <chr>                          <dbl>
## 1 Российская Федерация           15966
## 2 Центральный федеральный округ   3613
## 3 Белгородская область              72
## 4 Брянская область                  75
## 5 Владимирская область             126
## 6 Воронежская область              135
```

Использование необходимой формы зависит от контекста и ваших целей.

### Выбор и исключение столбцов {#col_select}

Можно создать новую таблицу, выбрав необходимые столбцы, как это показано выше:

```r
# Создадим новый фрейм данных из трех необходимых столбцов:
caspian = tab[c("Year", "Total", "Caspian")]
str(caspian)
## 'data.frame':	22 obs. of  3 variables:
##  $ Year   : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Total  : num  27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ...
##  $ Caspian: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
```

Иногда проще создать новый фрейм данных, исключив из оригинала ненужные столбцы. Исключение делается с помощью знака '-', который ставится перед номером столбца. Например, вот так можно исключить из таблицы `tab` столбцы `Total` (2-й) и `Other` (9-й):

```r
cleaned = tab[c(-2, -9)]
str(cleaned)
## 'data.frame':	22 obs. of  7 variables:
##  $ Year   : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Baltic : num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Black  : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Azov   : num  4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ...
##  $ Caspian: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Kara   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ White  : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
```

Есть также способ _удалить столбец целиком_ (им пользуются довольно редко). Для этого необходимо записать в него значение `NULL`:

```r
cleaned$Azov = NULL
str(cleaned)
## 'data.frame':	22 obs. of  6 variables:
##  $ Year   : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Baltic : num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Black  : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Caspian: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Kara   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ White  : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
```

### Добавление и вычисление столбцов {col_add}

Существует простой способ создать новый столбец в таблице --- достаточно указать его название после значка `$`. Если среда R не обнаруживает столбец с таким названием, она его создаст:

```r
caspian$CaspianRatio = round(caspian$Caspian / caspian$Total, 3)
```

```r
View(caspian)
```
<!--html_preserve--><div id="htmlwidget-41af4f53c355cc8dd963" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-41af4f53c355cc8dd963">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22"],[1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014],[27.2,24.6,24.5,22.4,23,22,20.7,20.3,19.8,19.8,19,18.5,17.7,17.5,17.2,17.1,15.9,16.5,16,15.7,15.2,14.8],[12.1,11,10.4,9.8,9.8,9.5,9.1,9.2,8.9,9.2,8.4,8.3,8,7.8,7.4,7.5,6.8,7.3,7.1,7,6.9,6.4],[0.445,0.447,0.424,0.438,0.426,0.432,0.44,0.453,0.449,0.465,0.442,0.449,0.452,0.446,0.43,0.439,0.428,0.442,0.444,0.446,0.454,0.432]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Year<\/th>\n      <th>Total<\/th>\n      <th>Caspian<\/th>\n      <th>CaspianRatio<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

_Тем не менее, такой метод добавления столбцов нельзя считать правильным_. Главный его недостаток --- из формы записи неочевидно, что мы добавляем новый столбец, а не перевычисляем уже существующий. Пакет `dplyr`, который мы рассмотрим в конце настоящей главы, решает эту и многие другие стилистические проблемы работы с фреймами данных.

Помимо того что вы можете вычислять столбцы традиционным способом как функцию от других столбцов, есть удобные функции-агрегаторы, позволяющие сделать вычисления по всем столбцам. Это `rowSums()` (сумма всех столбцов в строке) и `rowMeans()` (среднее по всем столбцам в строке). На тот случай, когда в ячейках есть пропущенные значения, в функциях предусмотрен параметр `na.rm = TRUE`.

```r
years = sewage[c(-1, -2)] # оставим данные с 2010 по 2013 гг

colSums(years)  # сколько всего было сброшено в каждом регионе за эти года
## Year10 Year11 Year12 Year13 
##     NA     NA     NA     NA
rowMeans(years) # сколько было сброшено в среднем за каждый год
##  [1] 15837.250  3648.750    72.750    73.000   124.750   132.250    96.500
##  [8]    89.250    45.250    37.000    84.000  1234.500    52.750    86.000
## [15]    67.500    25.800    93.000   188.750   224.750   922.000  2906.750
## [22]   190.500   118.000   374.000        NA     0.175   373.750   152.750
## [29]    96.000   260.000   345.750    87.250    44.000  1239.250  1399.250
## [36]    27.750    27.250   878.500    62.000   155.250   248.500   389.000
## [43]    77.750     3.825    31.000    47.000    93.250     0.000  2860.750
## [50]   319.500    55.750    40.500   483.750   115.250    29.250   381.750
## [57]   180.250   477.250   125.250   106.000   376.250    59.500   110.250
## [64]  1745.750    44.750   733.000   184.000        NA    53.250    35.500
## [71]    95.250   784.500  2094.500     0.275    29.000     8.375    34.500
## [78]    10.775    73.500   427.250   582.250   632.750   107.250   166.000
## [85]    22.750   792.250    82.500    36.250   327.500   183.250    79.000
## [92]    21.500    42.250    15.000     4.975        NA        NA
```

Существуют также аналогичные им функции `colSums()` и `colMeans()`, осуществляющие агрегирование данных по столбцам, а не по строкам.

Перечисленные функции являются укороченной версией универсальных функций семейства `apply`, с которыми мы познакомимся далее.

## Сортировка и фильтрация {#filtering_sorting}

### Сортировка {#table_sorting}

Распространенные операции с таблицами — это упорядочение по определенному столбцу и фильтрация по значениям. Мы уже знаем что из вектора, матрицы или таблицы можно извлекать элементы: `tab[V, ]`, где `tab` --- имя таблицы, `V` --- это вектор из номеров элементов. Например, извлечь 5, 2 и 4 строку таблицы можно так:

```r
tab[c(5,2,4), ]
##   Year Total Baltic Black Azov Caspian Kara White Other
## 5 1997  23.0    2.2   0.3  3.8     9.8  4.4   0.8   1.7
## 2 1994  24.6    2.3   0.4  3.2    11.0  5.0   0.9   1.8
## 4 1996  22.4    2.2   0.3  3.1     9.8  4.7   0.8   1.5
```

Логично предположить, что таким же образом можно извлечь элементы таблицы в порядке, обеспечивающем возрастание или убывание значений в каком-то столбце. Для этого нужно правильным образом расставить индексы в векторе `c(...)`. Существует специальная функция `order()`, которая позволяет это сделать. Например, отсортируем таблицу по возрастанию сбросов в Каспийское море:

```r
indexes=order(tab$Caspian)
head(tab[indexes, ])
##    Year Total Baltic Black Azov Caspian Kara White Other
## 22 2014  14.8    1.7   0.2  1.5     6.4  3.2   0.6   1.2
## 17 2009  15.9    1.8   0.2  1.5     6.8  3.5   0.7   1.4
## 21 2013  15.2    1.8   0.2  1.6     6.9  3.0   0.6   1.1
## 20 2012  15.7    1.8   0.2  1.6     7.0  3.0   0.7   1.4
## 19 2011  16.0    1.9   0.2  1.6     7.1  3.2   0.7   1.3
## 18 2010  16.5    2.0   0.2  1.6     7.3  3.3   0.7   1.4
```

Если упорядочение несложное, программист его скорее всего вставит непосредственно в инструкцию обращения к таблице:

```r
head(tab[order(tab$Caspian), ])
##    Year Total Baltic Black Azov Caspian Kara White Other
## 22 2014  14.8    1.7   0.2  1.5     6.4  3.2   0.6   1.2
## 17 2009  15.9    1.8   0.2  1.5     6.8  3.5   0.7   1.4
## 21 2013  15.2    1.8   0.2  1.6     6.9  3.0   0.6   1.1
## 20 2012  15.7    1.8   0.2  1.6     7.0  3.0   0.7   1.4
## 19 2011  16.0    1.9   0.2  1.6     7.1  3.2   0.7   1.3
## 18 2010  16.5    2.0   0.2  1.6     7.3  3.3   0.7   1.4
```

### Фильтрация {#table_filtering}

Схожим образом реализована _фильтрация данных_ по значению. Например, вы хотите извлечь из таблицы только те года, в которых объем сбросов в Каспийское море составил более 10 млн м$^3$. Здесь используется еще одна возможность извлечения элементов таблицы — с помощью вектора логических значений `TRUE/FALSE`. Число элементов в этом векторе должно быть равно числу элементов в индексируемом векторе, а значение указывает на то, нужно ли извлекать (`TRUE`) или нет (`FALSE`) элемент с текущим индексом. Вектор логических значений получается естественным путем с помощью операции сравнения:

```r

# ФИЛЬТРАЦИЯ

condition = tab$Caspian > 10
condition  # посмотрим что получилось
##  [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
tab[condition, ] # используем его для фильтрации строк таблицы:
##   Year Total Baltic Black Azov Caspian Kara White Other
## 1 1993  27.2    2.5   0.4  4.3    12.1  5.3   1.0   1.6
## 2 1994  24.6    2.3   0.4  3.2    11.0  5.0   0.9   1.8
## 3 1995  24.5    2.3   0.4  3.5    10.4  5.2   0.9   1.8
```

Опять же, весьма часто используется запись одним выражением:

```r
tab[tab$Caspian > 10, ]
##   Year Total Baltic Black Azov Caspian Kara White Other
## 1 1993  27.2    2.5   0.4  4.3    12.1  5.3   1.0   1.6
## 2 1994  24.6    2.3   0.4  3.2    11.0  5.0   0.9   1.8
## 3 1995  24.5    2.3   0.4  3.5    10.4  5.2   0.9   1.8
```

Часто бывает необходимо отобрать данные из таблицы, содержащей разнородные данные. В частности, в нашей таблице смешаны данные по субъектам и федеральным округам. Предположим, необходимо выгрузить в отдельную таблицу данные по федеральным округам. Для этого нужно найти строки, в которых столбец `Region` содержит фразу `"федеральный округ"`. Для поиска по текстовым эталонам импользуется функция `grep()`, выдающая номера элементов, или ее разновидность `grepl()`, выдающая список логических констант

```r
# Первый параметр - искомое выражение, второй параметр - где искть
rows = grep("федеральный округ",sewage$Region)
rows  # посмотрим, какие элементы столбца Region ему соответствуют
## [1]  2 21 35 42 49 64 73 86
okruga = sewage[rows,] # отфильтруем найденные строки
```

```r
View(okruga)
```
<!--html_preserve--><div id="htmlwidget-09e868f30e1162bb0a37" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-09e868f30e1162bb0a37">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8"],["Центральный федеральный округ","Северо-Западный федеральный округ","Южный федеральный округ","Северо-Кавказский федеральный округ","Приволжский федеральный округ","Уральский федеральный округ","Сибирский федеральный округ","Дальневосточный федеральный округ"],[4341,3192,1409,496,3162,1681,2575,871],[3761,3088,1446,390,2883,1860,2218,870],[3613,2866,1436,397,2857,1834,2142,821],[3651,2877,1394,395,2854,1665,2077,765],[3570,2796,1321,374,2849,1624,1941,713]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Region<\/th>\n      <th>Year05<\/th>\n      <th>Year10<\/th>\n      <th>Year11<\/th>\n      <th>Year12<\/th>\n      <th>Year13<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":[2,3,4,5,6]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Наоборот --- для __исключения__ найденных объектов удобнее воспользоваться разновидностью `grepl()`, которая возвращает вектор из логических значений:

```r
rows2 = grepl("федеральный округ", sewage$Region)
rows2 # вот так выглядит результат grepl
##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [45] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [67] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
## [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE

neokruga = sewage[!rows2, ]
```

```r
View(neokruga)
```
<!--html_preserve--><div id="htmlwidget-411c7fbd992293ee910a" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-411c7fbd992293ee910a">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89"],["Российская Федерация","Белгородская область","Брянская область","Владимирская область","Воронежская область","Ивановская область","Калужская область","Костромская область","Курская область","Липецкая область","Московская область1)","Орловская область","Рязанская область","Смоленская область","Тамбовская область","Тверская область","Тульская область","Ярославская область","г. Москва1)","Республика Карелия","Республика Коми","Архангельская область","в том числе:","Ненецкий автономный округ","Архангельская область без автономного округа","Вологодская область","Калинингpадская область","Ленинградская область","Мурманская область","Новгородская область","Псковская область","г. Санкт-Петербург","Республика Адыгея","Республика Калмыкия","Краснодарский край","Астраханская область","Волгоградская область","Ростовская область","Республика Дагестан","Республика Ингушетия","Кабардино-Балкарская Республика","Карачаево-Черкесская Республика","Республика Северная Осетия - Алания","Чеченская Республика","Республика Башкортостан","Республика Марий Эл","Республика Мордовия","Республика Татарстан","Удмуртская Республика","Чувашская Республика","Пермский край","Кировская область","Нижегородская область","Оренбургская область","Пензенская область","Самарская область","Саратовская область","Ульяновская область","Курганская область","Свердловская область","Тюменская область","в том числе:","Ханты-Мансийский автономный округ - Югра","Ямало-Ненецкий автономный округ","Тюменская область без автономных округов","Челябинская область","Республика Алтай","Республика Бурятия","Республика Тыва","Республика Хакасия","Алтайский край","Забайкальский край","Красноярский край","Иркутская область","Кемеровская область","Новосибирская область","Омская область","Томская область","Республика Саха (Якутия)","Камчатский край","Приморский край","Хабаровский край","Амурская область","Магаданская область","Сахалинская область","Еврейская автономная область","Чукотский автономный округ","ѕѕѕѕѕ","1) Данные за 2012-2013 гг. по Москве и Московской области приведены с учетом изменения их границ с 1 июля 2012 г."],[17727,11,89,155,169,144,99,64,34,127,635,68,20,90,59,79,252,287,1959,205,133,465,null,1.2,464,172,139,356,394,78,61,1188,24,36,795,68,204,282,78,1.6,47,53,96,0,388,64,53,529,28,121,317,132,425,149,139,465,237,115,59,814,148,null,31,31,86,660,0.5,61,8,50,34,83,531,814,695,72,214,12,79,29,348,217,100,28,52,14,4,null,null],[16516,77,78,129,134,102,92,47,37,87,1309,50,89,73,13,99,196,240,909,190,117,416,null,0.3,415,152,88,291,339,97,52,1346,29,29,863,69,186,270,77,2.7,33,51,82,0,341,60,46,490,105,86,313,205,472,122,111,397,24,111,50,763,202,null,55,44,103,845,0.3,41,9,38,15,78,444,594,700,107,177,14,86,46,371,191,82,27,46,15,5,null,null],[15966,72,75,126,135,99,88,46,50,82,1220,54,84,68,9.2,93,187,218,908,175,129,375,null,0.2,375,157,91,231,334,92,45,1239,28,33,920,71,150,235,78,4.3,32,47,97,0,321,57,42,498,127,10,397,176,461,132,108,395,18,115,46,770,183,null,39,39,105,836,0.3,8,9,36,12,95,448,583,661,94,170,26,87,38,336,188,79,26,46,16,5,null,null],[15678,71,71,124,131,97,84,47,45,87,1219,53,86,67,42,90,185,229,925,177,120,364,null,0.1,364,154,103,241,376,87,40,1215,28,21,892,56,144,253,79,4.2,30,45,107,0,311,51,39,480,117,11,407,171,451,127,105,362,112,110,43,712,167,null,41,34,92,744,0.3,35,8,34,8,86,426,614,572,113,158,24,81,32,318,176,78,17,44,15,5,null,null],[15189,71,68,120,129,88,93,41,16,80,1190,54,85,62,39,90,187,212,946,220,106,341,null,0.1,341,148,102,277,334,73,39,1157,26,26,839,52,141,236,77,4.1,29,45,87,0,305,55,35,467,112,10,410,169,525,120,100,351,84,105,40,687,184,null,78,25,81,713,0.2,32,7.5,30,8.1,35,391,538,598,115,159,27,76,29,285,178,77,16,33,14,4.9,null,null]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Region<\/th>\n      <th>Year05<\/th>\n      <th>Year10<\/th>\n      <th>Year11<\/th>\n      <th>Year12<\/th>\n      <th>Year13<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":[2,3,4,5,6]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Обратите внимание на восклицательный знак перед `rows2`. Он меняет все значения `TRUE` на `FALSE` и наоборот, что позволяет исключить найденные объекты

В полученной таблице все еще содержится текстовая шелуха типа `"в том числе"`, `"Данные за..."`, а также строка `"Российская Федерация"`. К счастью, функция `grep()` достаточо умна и возволяет искать сразу по нескольким образцам строк. Для этого их нужно разделить вертикальной чертой — _пайпом_ (`|`):

```r
rows2 = grepl("федеральный|числе|Российская|за|ѕ", sewage$Region)
rows2
##  [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
## [23] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [45] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [67] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
## [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
neokruga = sewage[!rows2, ] # обратите внимание на восклицательный знак перед rows2
```

```r
View(neokruga)
```
<!--html_preserve--><div id="htmlwidget-5150e7a0225e00e4bff5" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-5150e7a0225e00e4bff5">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83"],["Белгородская область","Брянская область","Владимирская область","Воронежская область","Ивановская область","Калужская область","Костромская область","Курская область","Липецкая область","Московская область1)","Орловская область","Смоленская область","Тамбовская область","Тверская область","Тульская область","Ярославская область","г. Москва1)","Республика Карелия","Республика Коми","Архангельская область","Ненецкий автономный округ","Архангельская область без автономного округа","Вологодская область","Калинингpадская область","Ленинградская область","Мурманская область","Новгородская область","Псковская область","г. Санкт-Петербург","Республика Адыгея","Республика Калмыкия","Краснодарский край","Астраханская область","Волгоградская область","Ростовская область","Республика Дагестан","Республика Ингушетия","Кабардино-Балкарская Республика","Карачаево-Черкесская Республика","Республика Северная Осетия - Алания","Чеченская Республика","Республика Башкортостан","Республика Марий Эл","Республика Мордовия","Республика Татарстан","Удмуртская Республика","Чувашская Республика","Пермский край","Кировская область","Нижегородская область","Оренбургская область","Пензенская область","Самарская область","Саратовская область","Ульяновская область","Курганская область","Свердловская область","Тюменская область","Ханты-Мансийский автономный округ - Югра","Ямало-Ненецкий автономный округ","Тюменская область без автономных округов","Челябинская область","Республика Алтай","Республика Бурятия","Республика Тыва","Республика Хакасия","Алтайский край","Забайкальский край","Красноярский край","Иркутская область","Кемеровская область","Новосибирская область","Омская область","Томская область","Республика Саха (Якутия)","Камчатский край","Приморский край","Хабаровский край","Амурская область","Магаданская область","Сахалинская область","Еврейская автономная область","Чукотский автономный округ"],[11,89,155,169,144,99,64,34,127,635,68,90,59,79,252,287,1959,205,133,465,1.2,464,172,139,356,394,78,61,1188,24,36,795,68,204,282,78,1.6,47,53,96,0,388,64,53,529,28,121,317,132,425,149,139,465,237,115,59,814,148,31,31,86,660,0.5,61,8,50,34,83,531,814,695,72,214,12,79,29,348,217,100,28,52,14,4],[77,78,129,134,102,92,47,37,87,1309,50,73,13,99,196,240,909,190,117,416,0.3,415,152,88,291,339,97,52,1346,29,29,863,69,186,270,77,2.7,33,51,82,0,341,60,46,490,105,86,313,205,472,122,111,397,24,111,50,763,202,55,44,103,845,0.3,41,9,38,15,78,444,594,700,107,177,14,86,46,371,191,82,27,46,15,5],[72,75,126,135,99,88,46,50,82,1220,54,68,9.2,93,187,218,908,175,129,375,0.2,375,157,91,231,334,92,45,1239,28,33,920,71,150,235,78,4.3,32,47,97,0,321,57,42,498,127,10,397,176,461,132,108,395,18,115,46,770,183,39,39,105,836,0.3,8,9,36,12,95,448,583,661,94,170,26,87,38,336,188,79,26,46,16,5],[71,71,124,131,97,84,47,45,87,1219,53,67,42,90,185,229,925,177,120,364,0.1,364,154,103,241,376,87,40,1215,28,21,892,56,144,253,79,4.2,30,45,107,0,311,51,39,480,117,11,407,171,451,127,105,362,112,110,43,712,167,41,34,92,744,0.3,35,8,34,8,86,426,614,572,113,158,24,81,32,318,176,78,17,44,15,5],[71,68,120,129,88,93,41,16,80,1190,54,62,39,90,187,212,946,220,106,341,0.1,341,148,102,277,334,73,39,1157,26,26,839,52,141,236,77,4.1,29,45,87,0,305,55,35,467,112,10,410,169,525,120,100,351,84,105,40,687,184,78,25,81,713,0.2,32,7.5,30,8.1,35,391,538,598,115,159,27,76,29,285,178,77,16,33,14,4.9]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Region<\/th>\n      <th>Year05<\/th>\n      <th>Year10<\/th>\n      <th>Year11<\/th>\n      <th>Year12<\/th>\n      <th>Year13<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":[2,3,4,5,6]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

## Пропущенные значения {#missed_values}

Можно ли осуществлять обработку таблицы `sewage`? Попробуем в качестве примера найти минимум сбросов за 2012 год:

```r

# ПРОПУЩЕННЫЕ ЗНАЧЕНИЯ

max(sewage$Year12)
## [1] NA
```

Результат имеет тип `NA`, потому что в данном столбце имеются пропуски. В некоторых статистических задачах это недопустимо. Если вы хотите проигнорировать значения пропусков, следует в вызываемой статистической функции указать дополнительный параметр `na.rm = TRUE`:

```r
max(sewage$Year12, na.rm = TRUE)
## [1] 15678
```

Еще один вариант --- исключить из таблицы те строки, в которых имеются пропущенные значения (хотя бы одно!). Для этого существует функция `complete.cases()`, возвращающая вектор логических значений:

```r
filter=complete.cases(sewage)
filter  # посмотрим что получилось. Там где видим FALSE - есть пропуски в строках
##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [23]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [34]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [45]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [56]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [67]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [78]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [89]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE

sewage.complete = sewage[filter, ] # отфильтруем полные строки
```

```r
View(sewage.complete)
```
<!--html_preserve--><div id="htmlwidget-151521fce85dd215f030" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-151521fce85dd215f030">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93"],["Российская Федерация","Центральный федеральный округ","Белгородская область","Брянская область","Владимирская область","Воронежская область","Ивановская область","Калужская область","Костромская область","Курская область","Липецкая область","Московская область1)","Орловская область","Рязанская область","Смоленская область","Тамбовская область","Тверская область","Тульская область","Ярославская область","г. Москва1)","Северо-Западный федеральный округ","Республика Карелия","Республика Коми","Архангельская область","Ненецкий автономный округ","Архангельская область без автономного округа","Вологодская область","Калинингpадская область","Ленинградская область","Мурманская область","Новгородская область","Псковская область","г. Санкт-Петербург","Южный федеральный округ","Республика Адыгея","Республика Калмыкия","Краснодарский край","Астраханская область","Волгоградская область","Ростовская область","Северо-Кавказский федеральный округ","Республика Дагестан","Республика Ингушетия","Кабардино-Балкарская Республика","Карачаево-Черкесская Республика","Республика Северная Осетия - Алания","Чеченская Республика","Приволжский федеральный округ","Республика Башкортостан","Республика Марий Эл","Республика Мордовия","Республика Татарстан","Удмуртская Республика","Чувашская Республика","Пермский край","Кировская область","Нижегородская область","Оренбургская область","Пензенская область","Самарская область","Саратовская область","Ульяновская область","Уральский федеральный округ","Курганская область","Свердловская область","Тюменская область","Ханты-Мансийский автономный округ - Югра","Ямало-Ненецкий автономный округ","Тюменская область без автономных округов","Челябинская область","Сибирский федеральный округ","Республика Алтай","Республика Бурятия","Республика Тыва","Республика Хакасия","Алтайский край","Забайкальский край","Красноярский край","Иркутская область","Кемеровская область","Новосибирская область","Омская область","Томская область","Дальневосточный федеральный округ","Республика Саха (Якутия)","Камчатский край","Приморский край","Хабаровский край","Амурская область","Магаданская область","Сахалинская область","Еврейская автономная область","Чукотский автономный округ"],[17727,4341,11,89,155,169,144,99,64,34,127,635,68,20,90,59,79,252,287,1959,3192,205,133,465,1.2,464,172,139,356,394,78,61,1188,1409,24,36,795,68,204,282,496,78,1.6,47,53,96,0,3162,388,64,53,529,28,121,317,132,425,149,139,465,237,115,1681,59,814,148,31,31,86,660,2575,0.5,61,8,50,34,83,531,814,695,72,214,12,871,79,29,348,217,100,28,52,14,4],[16516,3761,77,78,129,134,102,92,47,37,87,1309,50,89,73,13,99,196,240,909,3088,190,117,416,0.3,415,152,88,291,339,97,52,1346,1446,29,29,863,69,186,270,390,77,2.7,33,51,82,0,2883,341,60,46,490,105,86,313,205,472,122,111,397,24,111,1860,50,763,202,55,44,103,845,2218,0.3,41,9,38,15,78,444,594,700,107,177,14,870,86,46,371,191,82,27,46,15,5],[15966,3613,72,75,126,135,99,88,46,50,82,1220,54,84,68,9.2,93,187,218,908,2866,175,129,375,0.2,375,157,91,231,334,92,45,1239,1436,28,33,920,71,150,235,397,78,4.3,32,47,97,0,2857,321,57,42,498,127,10,397,176,461,132,108,395,18,115,1834,46,770,183,39,39,105,836,2142,0.3,8,9,36,12,95,448,583,661,94,170,26,821,87,38,336,188,79,26,46,16,5],[15678,3651,71,71,124,131,97,84,47,45,87,1219,53,86,67,42,90,185,229,925,2877,177,120,364,0.1,364,154,103,241,376,87,40,1215,1394,28,21,892,56,144,253,395,79,4.2,30,45,107,0,2854,311,51,39,480,117,11,407,171,451,127,105,362,112,110,1665,43,712,167,41,34,92,744,2077,0.3,35,8,34,8,86,426,614,572,113,158,24,765,81,32,318,176,78,17,44,15,5],[15189,3570,71,68,120,129,88,93,41,16,80,1190,54,85,62,39,90,187,212,946,2796,220,106,341,0.1,341,148,102,277,334,73,39,1157,1321,26,26,839,52,141,236,374,77,4.1,29,45,87,0,2849,305,55,35,467,112,10,410,169,525,120,100,351,84,105,1624,40,687,184,78,25,81,713,1941,0.2,32,7.5,30,8.1,35,391,538,598,115,159,27,713,76,29,285,178,77,16,33,14,4.9]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>Region<\/th>\n      <th>Year05<\/th>\n      <th>Year10<\/th>\n      <th>Year11<\/th>\n      <th>Year12<\/th>\n      <th>Year13<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":[2,3,4,5,6]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

## Преобразование типов и поиск ошибок {#data_conversion}

Достаточно часто при работе с реальными данными возникает необходимость преобразования их типов. Например, вам необходимо перевести строки в даты, чтобы оперировать ими соответствующим образом. Или принудительным образом указать, что столбец со строками не хранит номинальную переменную (фактор), а его нужно интерпретировать именно как строковый столбец (обычно это полезно, когда столбец содержит какую-то текстовую информацию в виде комментариев по каждому измерению). Наконец, в данных могут быть ошибки, опечатки и так далее, которые могут препятствовать правильному их чтению.

В этом разделе мы рассмотрим, как можно:

1. Найти и исправить множественные варианты одного названия с опечатками
2. Исправить ошибки в числовых данных
3. Преобразовать факторы в строки и наоборот
4. Преобразовать строки в числа и наоборот

Рассмотрим возможные манипуляции с данными на примере таблицы о землепользовании на территории Сатинского учебного полигоны Географического факультета МГУ:

```r

# ПОИСК ОШИБОК

tab = read.csv2("SatinoLanduse.csv", encoding = 'UTF-8')
str(tab) # посмотрим, какова структура данных
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : Factor w/ 35 levels "","АО \"Родина\"",..: 30 1 1 1 1 1 1 3 2 1 ...
##  $ Perimeter     : Factor w/ 160 levels "1014.155593894044800",..: 67 155 51 104 78 153 17 19 108 57 ...
##  $ Area          : Factor w/ 160 levels "0.238070145845919",..: 73 49 121 100 63 72 88 128 99 24 ...
```

```r
View(tab)
```
<!--html_preserve--><div id="htmlwidget-507e5996f8c8f1683540" style="width:100%;height:auto;" class="datatables html-widget"></div>
<script type="application/json" data-for="htmlwidget-507e5996f8c8f1683540">{"x":{"filter":"none","data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160"],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160],["Территории населенных пунктов","Выгоны","Выгоны","Пашни","Леса","Выгоны","Леса","Фермерские хозяйства","Пашни","Сады","Фермерские хозяйства","Фермерские хозяйства","Фермерские хозяйства","Фермерские хозяйства","Фермерские хозяйства","Фермерские хозяйства","Выгоны","Территории населенных пунктов","Территории населенных пунктов","Лесные поляны","Фермерские хозяйства","Фермерские хозяйства","Фермерские хозяйства","Пашни","Фермерские хозяйства","Фермерские хозяйства","Фермерские хозяйства","Фермерские хозяйства","Луга","Фермерские хозяйства","Луга","Фермерские хозяйства","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Луга","Леса","Леса","Леса","Леса","Леса","Леса","Леса","Луга","Леса","Леса","Фермерские хозяйства","Леса","Выгоны","Фермерские хозяйства","Сады","Луга","Пашни","Луга","Луга","Леса","Заболоченные земли","Леса","Леса","Леса","Леса","Леса","Нет данных","Вырубки","Вырубки","Вырубки","Леса","Леса","Леса","Пашни","Фермерские хозяйства","Сады","Леса","Сады","Фермерские хозяйства","Вырубки","Выгоны","Выгоны","Выгоны","Выгоны","Выгоны","Леса","Вырубки","Вырубки","Вырубки","Выгоны","Нет данных","Пашни","Выгоны","Лесные поляны","Выгоны","Заболоченные земли","Выгоны","Выгоны","Выгоны","Луга","Лесные поляны","Пашни","Выгоны","Выгоны","Выгоны","Территории населенных пунктов","Выгоны","Территории населенных пунктов","Выгоны","Выгоны","Выгоны","Выгоны","Выгоны","Фермерские хозяйства","Пашни","Пашни","Выгоны","Заболоченные земли","Пашни","Леса","Территории населенных пунктов","Леса","Фермерские хозяйства","Луга","Территории населенных пунктов","Пашни","Заболоченные земли","Леса","Пашни","Гидрологические объекты","Выгоны","Пашни","Луга","Пашни","Территории населенных пунктов","Гидрологические объекты","Гидрологические объекты","Нет данных","Гидрологические объекты","Пашни","Леса","Луга"],["Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","","","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская Администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","","","","","","","","","","","","","","","","","","","","","","","","","","Совьяковская сельская администрация","","","","","","","","Совьяковская сельская администрация","","","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","РФ","Совьяковская сельскаая администрация","Совьяковская сельская админитрация","","","","","","","","","","","","","","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","РФ","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","","","","","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская администрация","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","РФ","","Совьяковская сельская администрация","","Совьяковская сельская администрация","Совьяковская сельская администрация","Совьяковская сельская администрация","","Совьяковская сельская администрация","","","","Совьяковская сельская администрация","","","","Совьяковская сельская администрация","","","","","Совьяковская сельская администрация","","Совьяковская сельская администрация"],["Село Беницы","","","","","","","Владелец - Айвозян","АО \"Родина\"","","Владелец - Кожокарь А.Ф.","Владелец - Кожокарь А.Ф.","Владелец - Сизанов","Владелец - Смородин","Владелец - Родинкин","Владелец - Жуков","","Село Сатино","Деревня Бутовка","","Владелец - Кожокарь М.Ф.","Владелец - Семенищев Н.А.","Владелец - Неверов","","Владелец - Горохов","Владелец - Солныкина","Владелец - Соловецкий","Владелец - Соловецкая","","Владелец - Семчук","","Владелец - Жуков","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Владелец - Легков В.И.","","","Владелец - Жуков","Коллективные сады товарищества \"Винт\"","","Федеральная собственность","","","","","","","","","Урочище Борок","","","","","","","","Урочище Дощечное","Владелец - Безрядин","Коллективные сады \"Эльф\"","","","Владелец - Фёдоров","","","","","","","","","","","","","","","","","","","","","","","","","","","Деревня Дедюевка","","Деревня Рыжково","","","","","","Владелец - Семчук","АО \"Родина\"","АО \"Родина\"","","","Федеральная собственность","","Деревня Ивановское","","Территория молочной фермы","","Деревня Загрязье","","","","","река Протва","","","","","Деревня Митинки","Озеро","Озеро","","","АО \"Родина\"","",""],["2395.725463843722500","922.314163446381600","2180.787622893539300","3947.940266502537700","278.569432215831970","875.438381164973630","12768.489513668199000","1285.637868954036100","4165.304881235649200","2276.494254985449100","1081.964408568060900","1020.278536197552200","955.245764593231120","987.238935738203510","923.493120570405610","2178.194227396214000","329.779915090419370","7797.569103061144200","1060.678503301135200","229.722576344810990","1021.109926202218700","1041.122684298658400","637.625220395232760","828.735132375886000","445.273316350918890","593.761730765728320","811.773990223761300","446.591223888069630","114.701418496307100","1282.216799368403800","492.557716818656050","658.044528067592980","2974.387632216028600","682.133273739147850","2913.012537616505100","1882.984892231590500","628.503509570987940","3544.869605738307700","296.955526951002750","9465.261080523363500","190.162157356840570","3520.181376630148000","2536.270353066599900","739.839528673226480","1094.945610298295600","372.424478591613480","1735.219181750783500","1014.155593894044800","3023.575166620509700","2767.036734352273500","991.756897880632780","345.001538925804540","505.717151349551840","313.301421769596120","258.619660986542390","175.421903279478530","557.414799680944720","867.460782446246640","381.026959675226410","711.182786063959840","1576.781840020214800","417.166384849397670","422.853128265023370","390.430477124089520","259.749731341368370","1190.198805959317700","160.308140233701070","234.354769745643610","806.348356707244190","227.482699039905870","385.442410488905580","1395.061678932684100","2358.080745882565700","303.226006081840350","2556.264468639007200","223.872618708442300","336.587519659077770","15354.682867180587000","469.693448694413520","2560.164619581864800","1942.663858781144400","2255.524732974263300","523.146454934524060","2000.574091337482500","222.364743390340890","1410.860705357233700","465.757326894891430","837.550517393744940","506.268371870586860","2009.694257792927600","140.498152700021900","1890.406103668618000","1019.457949256323400","2322.323294761477000","177.128454964415370","535.480506184955290","1490.866170010731600","868.590643296811210","784.919336080663810","396.566060884559080","593.035692141365870","1183.776899540326200","4667.526630330259600","349.478207826485230","293.448125744845750","807.368355582933420","755.135016833356990","2481.927468409167900","1307.095535218648600","2121.917315495333200","724.044910501994760","395.530650270342960","897.530950496543140","547.003638035006130","2071.426159798443700","2336.509349443190300","1655.312967754795000","282.729961911075750","353.455730955488600","2354.362993245422300","1155.916232728818800","269.740632059119380","423.879939058014540","1172.234440960391600","426.637291845218900","3074.046138125749600","147.523204483101130","619.822999428146320","2409.847196649397100","1801.488864110087900","217.448328183814680","30.213895842173304","3525.118948109050100","2311.525491311364500","1360.250444238750800","715.974579669219220","2017.730069296692100","869.011223067728220","2265.856027132804200","1210.155888961538000","360.328581498529050","3.086953443396793","1348.846937244813000","5877.198981566753000","1276.809801687205200","5245.058162376556500","2791.519179861358200","23920.944648227432000","6603.955909968268300","13493.773620681737000","4076.707549162360500","1795.590885848397400","722.879255316470560","119.083106284324340","71.543820942051099","1773.051855263179700","73.693186724796703","2519.712412758317000","1296.647097772085500","2338.524893045367200"],["286159.158855028570000","21651.963989321295000","56826.463220403260000","450293.758854912190000","2612.615315620203500","28608.401312941853000","3469445.792599530000000","62299.630521423671000","450291.261113939570000","147943.134285204400000","54440.358069744660000","53291.798236783667000","53457.621679177879000","57698.660258261974000","51281.983266728945000","312762.042063507660000","5941.499366660677000","830862.391512097560000","50478.678222297574000","3265.314293738872500","55861.392252290992000","65716.647795004552000","23869.914283815866000","25882.353530118649000","4603.953526588094100","4381.645029546117300","32036.296324754723000","7506.719090626902500","608.206081330334430","89499,573298880117000","3843.130646728627700","20738.846350572821000","227134.820162281510000","9621.367410346487300","181121.543272139530000","90314.422604615742000","14027.297670484913000","640110.951121168680000","4679.883188862047100","1092606.851056342700000","2411.255045553898100","121638.279177417540000","33752.794040286550000","8341.599124097163400","3617.243308510424000","1567.104813126887600","9865.323033935605100","3842.890721919666200","21384.109233813440000","14476.930711173922000","7301.141991778400600","6486.956681001920500","3803.477358724781900","1131.496066112815700","3002.504191971309000","539.123727506730010","11656.669250498955000","24185.158251040797000","1742.637023635242000","23433.587558919378000","8273.779426722529000","2952.616318962082500","1031.970181480255000","930.964001734238310","595.676646849412010","27357.732994543410000","1182.852128971498100","2946.442415283197500","34542.382853718096000","2119.622296355390100","6488.708338066418900","65059.301585804147000","171401.654524252810000","5899.447777935165500","198987.206721941820000","2835.948220782285300","3340.438498735139100","1693194.137634886200000","10703.189785344441000","20150.803155476631000","14668.634190504757000","20957.275579485271000","2270.043268259560100","53372.990081921045000","2754.008770193891000","18087.857495015258000","5489.955910415563300","11922,638460079328000","9061.158003221207800","14745.378415189980000","1249.715547920420900","161947.865081757050000","46765.120784921062000","108784.937946770630000","1981.382884888466400","10153.773347663515000","77374.938296643610000","50136.205656653998000","16622.017692742542000","8661.893137167837300","15533.889665445700000","49077.278244379464000","105469.258406255660000","5153,570673500797100","5528.939993184026200","23776.888687917577000","26269.470572935079000","103952.438739990700000","82555.307564889037000","85791.501222018822000","24123.584689912164000","4887.857056873202100","21135.851338957618000","7818.729506617504700","31958.770190284285000","29476.450655787026000","46859.503767767157000","4304.998783309750300","7802.791685541597000","103683.248190403130000","16903.853690979999000","3026.566822507951700","6209.206484740834600","78502.938905644885000","2849.291253874679100","197579.031028344530000","899.602008063114230","9008.261211555049200","75472.527696543737000","104968.978540695590000","2889.842511804906300","42.676917220700894","227408.935134828180000","279386.229946879550000","18938.366466128515000","27777.201578799330000","118823.585181967850000","7195.906821987659000","192862.712873304610000","23255.185056499882000","8658.590843035126500","0.238070145845919","84410.339552943304000","763452.968717598710000","43168.646454190544000","647899.870316969580000","349030.986488852180000","246765.587149404570000","273793.579821330380000","2001222.454137160200000","528505.851081224040000","157537.350429073330000","12646.532541280130000","960.889508904636270","328.327714712074620","47941.725558863203000","392.819854559529460","164132.667580747340000","13397.398783192089000","232022.514814842080000"]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>ID<\/th>\n      <th>Type<\/th>\n      <th>Administration<\/th>\n      <th>Comment<\/th>\n      <th>Perimeter<\/th>\n      <th>Area<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":5,"columnDefs":[{"className":"dt-right","targets":1},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false,"lengthMenu":[5,10,25,50,100]}},"evals":[],"jsHooks":[]}</script><!--/html_preserve-->

Видно, что все столбцы, кроме двух, хранящих идентификаторы, были прочитаны как строки и преобразованы в факторы (номинальные переменные). Это означает, что мы не сможем работать привычным образом со столбцами периметра и площади, а столбец комментариев теперь также является номинальной переменной, что противоречит здравому смыслу (он вообще переменной не является).

Когда вы отображаете таблицу в консоли или графическом интерфейсе, факторы выглядят и ведут себя как обычные строки. Подвох заключается в том, что хранятся они в виде пар "ключ — значение" (об этом мы говорили выше) и все операции преобразования осуществляются __над ключами__, а не значениями. Рассмотрим, как следует правильно преобразовывать номинальные переменные в __R__.

Чтобы привести столбцы к нужному типу, необходимо использовать преобразования типов. Для этого можно воспользоваться функциями семейства `as`, описанными в Главе 1.

Для начала преобразуем столбец `Comment` к обычному символьному представлению:

```r
tab$Comment = as.character(tab$Comment)
str(tab)
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : chr  "Село Беницы" "" "" "" ...
##  $ Perimeter     : Factor w/ 160 levels "1014.155593894044800",..: 67 155 51 104 78 153 17 19 108 57 ...
##  $ Area          : Factor w/ 160 levels "0.238070145845919",..: 73 49 121 100 63 72 88 128 99 24 ...
```

Посмотрим теперь, что произойдет, если мы попытаемся преобразовать столбец `Perimeter` к числовому виду:

```r
as.numeric(tab$Perimeter)
##   [1]  67 155  51 104  78 153  17  19 108  57   7   3 158 159 156  50  91
##  [18] 143   6  58   4   5 131 148 113 128 147 114   9  18 118 132  84 134
##  [35]  81  40 130  98  83 157  42  95  71 141   8 100  34   1  87  77 160
##  [52]  93 119  90  74  35 125 150 101 136  31 109 110 103  75  14  32  63
##  [69] 145  56 102  25  65  88  72  53  92  30 117  73  43  54 121  44  52
##  [86]  27 115 149 120  45  26  41   2  60  36 123  29 151 144 106 127  12
## [103] 116  94  82 146 142  69  21  48 139 105 154 124  47  61  33  80  97
## [120]  64  10  76 111  11 112  89  28 129  68  39  49  86  96  59  24 137
## [137]  46 152  55  15  99  85  22 126  16 122  79  66 133  23 107  38 138
## [154]  13 135  37 140  70  20  62
```

Вместо значений перметра мы получили загадочные числа, которых в таблице нет. Это и есть ключи факторов. Чтобы получить их значения, необходимо использовать функцию `levels()` (для краткости выведем первые 10 значений):

```r
levels(tab$Perimeter)[1:10]
##  [1] "1014.155593894044800" "1019.457949256323400" "1020.278536197552200"
##  [4] "1021.109926202218700" "1041.122684298658400" "1060.678503301135200"
##  [7] "1081.964408568060900" "1094.945610298295600" "114.701418496307100" 
## [10] "1155.916232728818800"
```

Обратите внимание на то, что значения фактора отсортированы в алфавитном порядке, без учете порядка их встречаемости в исходной таблице. Для корректного преобразования факторов в числа необходимо сначала привести их к обычному строковому виду:

```r
tab$Perimeter = as.numeric(as.character(tab$Perimeter))
str(tab)
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : chr  "Село Беницы" "" "" "" ...
##  $ Perimeter     : num  2396 922 2181 3948 279 ...
##  $ Area          : Factor w/ 160 levels "0.238070145845919",..: 73 49 121 100 63 72 88 128 99 24 ...

# Теперь попробуем преобразовать столбец Area
temp = as.numeric(as.character(tab$Area))
## Warning: в результате преобразования созданы NA
temp[1:10]
##  [1]  286159.159   21651.964   56826.463  450293.759    2612.615
##  [6]   28608.401 3469445.793   62299.631  450291.261  147943.134
```

Все прошло вроде бы успешно, но с предупреждением, что некоторые значения были преобразованы в `NA` (_Not Available_) --- отсутствующие значения. По всей видимости, данные в соответствущих ячейках не соответствуют представлениям __R__ о том, как должно выглядеть число: ячейка или пустая, или число набрано с ошибкой/опечаткой.

Чтобы найти и исправить все неверно заданные данные, необходимо выполнить следующие действия:

1. Получить индексы всех элементов, имеющих значение `NA`.
2. Просмотреть, какие значения были в исходных данных под этими индексами
3. Исправить ошибки в этих значениях, если это поддается автоматизации
4. Повторить конвертацию в числовой тип данных

Проверку на отсутствующие данные осуществляют с помощью функции `is.na()`. Передав ей в качестве аргумента вектор значений, вы получите вектор булевых значений, в котором `TRUE` будет стоять для пустых элементов. Проверим с помощью него, какие элементы столюца `Area` привели к ошибкам конвертации данных:

```r
tab[is.na(temp), "Area"]
## [1] 89499,573298880117000 11922,638460079328000 5153,570673500797100 
## 160 Levels: 0.238070145845919 ... 9865.323033935605100
```

Видно, что __R__ не справился с преобразованием типов там, где содержится опечатка в десятичном разделителе --- вместо точки указана запятая. 

Для исправления этой ошибки мы можем воспользоваться стандартной функцией замены символа `gsub(pattern, replacement, x)`. Ее стандартные параметры означают соответственно: что искать, на что заменять, где искать:

```r
tab$Area = gsub(',', '.', tab$Area) # заменим запятые на точки
tab$Area = as.numeric(as.character(tab$Area)) # Теперь можно преобразовать в числа
str(tab)
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : chr  "Село Беницы" "" "" "" ...
##  $ Perimeter     : num  2396 922 2181 3948 279 ...
##  $ Area          : num  286159 21652 56826 450294 2613 ...
```

Теперь необходимо навести порядок в значениях факторов, убедившись, что и там нет опечаток. Выведем все уникальные значения с помощью функции `levels()`:

```r
levels(tab$Type)
##  [1] "Выгоны"                        "Вырубки"                      
##  [3] "Гидрологические объекты"       "Заболоченные земли"           
##  [5] "Леса"                          "Лесные поляны"                
##  [7] "Луга"                          "Нет данных"                   
##  [9] "Пашни"                         "Сады"                         
## [11] "Территории населенных пунктов" "Фермерские хозяйства"
levels(tab$Administration)
## [1] ""                                    
## [2] "РФ"                                  
## [3] "Совьяковская администрация"          
## [4] "Совьяковская сельскаая администрация"
## [5] "Совьяковская сельская администрация" 
## [6] "Совьяковская сельская Администрация" 
## [7] "Совьяковская сельская админитрация"
```
Видно, что если с типами все в порядке, то в данных об административном подчинении содержится 5 вариантов названия одной и той же Совьяковской сельской администрации. Помимо этого, пустые ячейки хорошо бы заменить на значение `"Прочее"`.

Чтобы найти все строчки, относящиеся к одному и тому же объекту, можно воспользоваться уже знакомой нам функцией `grep()`, передав ей подстроку, которая является для них общей. Например, `"Совьяковская"` (хотя в данном случае было бы вообще достаточно одной буквы `"с"`).

```r
filter = grep("Совьяковская", tab$Administration) # Найдем все записи
tab[filter, "Administration"] = "Совьяковская сельская администрация" # Заменим их одним значением
tab$Administration = droplevels(tab$Administration) # Удаляем неиспользуемые уровни
levels(tab$Administration)
## [1] ""                                   
## [2] "РФ"                                 
## [3] "Совьяковская сельская администрация"
```

Пустые строки можно также найти c помощью `grep()`, но мы этого делать не будем, так как это требует дополнительных знаний о регулярных выражениях. Вместо этого воспользуемся тем, что пустые строки имеют длину 0. Обратите внимание ниже, что преобразование в вектор столбца `Administration` необходимо, т.к. `nchar()` не понимает объекты типа `data.frame`, которыми являются не только таблицы, но и их столбцы:

```r
filter = nchar(as.vector(tab$Administration)) == 0 # TRUE если длина равна 0
# Пробуем заменить:
tab[filter, "Administration"] = "Прочее"
## Warning in `[<-.factor`(`*tmp*`, iseq, value = c("Прочее", "Прочее", :
## неправильный уровень фактора, получились NA
```

Ошибка выше связана с тем, что __R__ строго следит за неизменностью набора значений фактора для того чтобы избежать всевозможных ошибок при работе с данными (опечаток и т.д.). Предыдущий раз мы заменили все значаниея одним из существующих. В данном случае необходимо ввести новое значение фактора. Чтобы это сделать, придется преобразовать данные в символьные, произвести замену срок и после этого снова конвертировать столбец в фактор:

```r
tab$Administration = as.character(tab$Administration)
tab[filter, "Administration"] = "Прочее"
tab$Administration = as.factor(tab$Administration)
levels(tab$Administration)
## [1] "Прочее"                             
## [2] "РФ"                                 
## [3] "Совьяковская сельская администрация"
```

Теперь таблица готова к работе. Можно, например, подсчитать по ней сводную статистику:

```r
summary(tab)
##        ID                                    Type   
##  Min.   :  1.00   Леса                         :52  
##  1st Qu.: 40.75   Выгоны                       :27  
##  Median : 80.50   Фермерские хозяйства         :22  
##  Mean   : 80.50   Пашни                        :15  
##  3rd Qu.:120.25   Луга                         :11  
##  Max.   :160.00   Территории населенных пунктов: 8  
##                   (Other)                      :25  
##                              Administration   Comment         
##  Прочее                             :76     Length:160        
##  РФ                                 : 3     Class :character  
##  Совьяковская сельская администрация:81     Mode  :character  
##                                                               
##                                                               
##                                                               
##                                                               
##    Perimeter              Area        
##  Min.   :    3.087   Min.   :      0  
##  1st Qu.:  421.431   1st Qu.:   5087  
##  Median :  939.369   Median :  21260  
##  Mean   : 1761.654   Mean   : 125002  
##  3rd Qu.: 2135.987   3rd Qu.:  83019  
##  Max.   :23920.945   Max.   :3469446  
## 
```
Обратите внимание, что строки, интервальные и номинальные (факторы) переменные обрабатываются функцией `summary()` по-разному.

## Сохранение таблиц {#table_writing}

Одной из завершающих стадий анализа данных, помимо графиков и отчетов, часто являются новые табличные представления, которые было бы неплохо сохранить в виде файлов. К счастью, сохранение таблиц в __R__ столь же просто, как и чтение. Для текстовых файлов в формате __CSV__ можно использовать функции `write.table()`, `write.csv()` и `write.csv2()`. Для файлов __Microsoft Excel__ используйте функцию `write.xlsx()` из пакета `openxlsx` соответственно. 

> __По умолчанию функции `write.table()`, `write.csv()` и `write.csv2()` записывают в таблицы в качестве первого столбца названия (номера) строк таблиц.__ Если вы не хотите, чтобы это происходило, укажите дополнительный параметр `row.names=FALSE`.

Сохраним таблицы `okruga` и `neokruga`, раздельно хранящие статистику по объему сброса сточных в поверхностные водные объекты по федеральным округам и субъектам соответственно:

```r

# СОХРАНЕНИЕ ТАБЛИЦ
library(writexl)

write.csv2(okruga, "okruga.csv", fileEncoding = 'UTF-8') # Сохраним первую таблицу в CSV в кодировке Unicode
write_xlsx(neokruga, "neokruga.xlsx") # Сохраним вторую таблицу в XLSX без названий строк

# Проверим, все ли в порядке с сохраненными таблицами:

okruga.saved = read.csv2("okruga.csv", encoding = 'UTF-8')
head(okruga.saved)
##   X                              Region Year05 Year10 Year11 Year12 Year13
## 1 1       Центральный федеральный округ   4341   3761   3613   3651   3570
## 2 2   Северо-Западный федеральный округ   3192   3088   2866   2877   2796
## 3 3             Южный федеральный округ   1409   1446   1436   1394   1321
## 4 4 Северо-Кавказский федеральный округ    496    390    397    395    374
## 5 5       Приволжский федеральный округ   3162   2883   2857   2854   2849
## 6 6         Уральский федеральный округ   1681   1860   1834   1665   1624

neokruga.saved = read_xlsx("neokruga.xlsx",1)
head(neokruga.saved)
## # A tibble: 6 x 6
##   Region               Year05 Year10 Year11 Year12 Year13
##   <chr>                 <dbl>  <dbl>  <dbl>  <dbl>  <dbl>
## 1 Белгородская область     11     77     72     71     71
## 2 Брянская область         89     78     75     71     68
## 3 Владимирская область    155    129    126    124    120
## 4 Воронежская область     169    134    135    131    129
## 5 Ивановская область      144    102     99     97     88
## 6 Калужская область        99     92     88     84     93
```

Видно, что в файле __CSV__ присутствует также дополнительный столбец с названиями строк, а в файле __XLSX__ его нет. Если вы не задавали названия строк явным образом и они не несут какого-то смысла, всегда указывайте параметр `row.names=FALSE`

> __Вы можете дать строкам таблицы названия и извлечь их, используя функцию `row.names()`__ аналогично функции `colnames()` для столбцов

## Правила подготовки таблиц для чтения в R {#table_rules}

С таблицами, которые мы использовали в настоящем модуле, все прошло относительно гладко, поскольку они были подготовлены специальным образом. Несмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу:

1. В первой строке таблицы должны располагаться названия столбцов.
1. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.
1. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.
1. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: `Валовый внутренний продукт за 2015 г.`. Хорошее название столбца: `GDP2015`.
1. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в __R__.

Следование этим правилам значительно облегчит работу с табличными данными.

## Контрольные вопросы и задачи {#questions_tasks_tables}

### Вопросы {#questions_tables}

1. Назовите принципы формата CSV
1. Какие пакеты позволяют читать файлы в формате Microsoft Excel? Какие их них позволяют еще и записывать такие файлы?
1. В каких кодировках сохраняются файлы в операционных системах Windows и UNIX/Linux/macOS? Что делать, чтобы правильно прочесть таблицу, сохраненную не в кодировке вашей операционной системы?
1. Можно ли изменять типы данных столбцов после чтения таблицы? Если да, то какими средствами это можно сделать?
1. Как просмотреть в консоли шапку или конец таблицы? Можно ли при этом определить количество отображаемых строк?
1. Как просмотреть таблицу в графическом интерфейсе RStudio?
1. Какая форма обращения к столбцу вызвращает вектор?
1. Какая форма обращения к столбцу возвращает фрейм данных?
1. Какие существуют способы обратиться к столбцу фрейма данных по его названию?
1. Как удалить столбец в фрейме данных?
1. Как выбрать требуемые столбцы фрейма данных, указав ненужные столбцы?
1. Как отсортировать фрейм данных по одному столбцу? Нескольким столбцам?
1. Какие функции-агрегаторы стандартной библиотеки позволяют считать суммы по столбцам и строкам?
1. К каким компонентам фрейма данныз применяются операции фильтрации (filter) и выборки (select)? Что применяется к строкам, а что --- к столбцам?
1. Какую функцию стандартной библиотеки можно использовать для поиска строк и их фрагментов?
1. Перечислите основные функции пакета `dplyr` для преобразования таблиц. Какие задачи они помогают решать?
1. Для чего нужен пайп-оператор `%>%`? Какие виды рабочих процессов он позволяет упростить?

### Задачи {#tasks_tables}

----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----
