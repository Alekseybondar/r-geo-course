[
["tables.html", "Глава 3 Таблицы 3.1 Предварительные требования 3.2 Структуры данных 3.3 Чтение 3.4 Просмотр 3.5 Столбцы, строки и ячейки 3.6 Преобразования 3.7 Соединение 3.8 Запись 3.9 Правила подготовки таблиц для чтения в R 3.10 Краткий обзор 3.11 Контрольные вопросы и упражнения", " Глава 3 Таблицы 3.1 Предварительные требования Для работы по теме текущей лекции вам понадобятся пакеты из tidyverse, а также writexl. Установите их, используя следующую команду: install.packages(&#39;tidyverse&#39;) install.packages(&#39;writexl&#39;) Внимание: установка пакетов выполняется один раз из консоли. Вызов функции install.packages() не должен присутствовать в ваших скриптах 3.2 Структуры данных Стандартным средством представления табличных данных в R являются фреймы данных (data.frame), кратко рассмотренные в предыдущей лекции. В современных пакетах типа tidyverse используется разновидность фрейма данных, которая называется тиббл (tibble). Создать тиббл можно напрямую, либо путем конвертации фрейма данных: library(tibble) tibble( a = 1:3, b = 1, c = -1:1 ) dfr = data.frame(a = 1:3, b = 1, c = -1:1) as_tibble(dfr) Тиббл является расширением класса фрейма данных, то есть любая операция, применимая к фрейму, применима и к тибблу. Однако, тиббл поддерживает дополнительные возможности, которые оказываются очень удобны в анализе: При выводе в консоль тиббл печатает только те столбцы, которые помещаются на экран, и только первые 10 строк (что позволяет избежать переполнения консоли при печати больших таблиц) Тибблы поддерживают имена столбцов, которые недопустимы в фреймах данных (например, начинающиеся с цифры). Так называть столбцы, вообще говоря, неправильно, но это позволяет сохранить именно те названия, которые даны в исходных файлах. Например, географические таблицы часто содержат данные за разные года, и столбцы названы по этим годам. Тибблы поддерживают внутренние группировки данных. Установив группировку по одной или нескольким переменным, можно эффективным и компактным путем считать агрегирующие статистики по группам измерений. Тибблы можно создавать вручную не только по столбцам, но и по строкам. Для реализации последней возможности можно использовать функцию tribble() (переводится как transposed tibble — транспонированный тиббл), указав имена столбцов с помощью тильды (~): tribble( ~a, ~b, ~c, 1, 1, -1, 2, 1, 0, 3, 1, 1 ) В данной и последующих лекциях понятия мы будем использовать понятия таблица, фрейм данных и тиббл как взаимозаменяемые. Однако следует помнить, что пакеты из группы tidyverse всегда создают тиббл. 3.3 Чтение Существует множество способов получить набор табличных данных в текущей сессии R. Эти способы варьируются от загрузки данных из пакета до извлечения таблиц из текстовых документов и веб-страниц. В настоящей главе мы рассмотрим наиболее распространенные способы, нацеленные на работу с готовыми таблицами. 3.3.1 Встроенные данные Пакеты R часто содержат тестовые наборы данных. Эти данные, как правило, предназначены для ознакомления с возможностями пакета. Чтобы узнать, какие данные есть в пакете, вы можете вызвать функцию data(package = 'packagename'), где packagename — это имя интересующего вас пакета. Например, посмотрим, какие данные есть в пакете dplyr (произносится как deep liar — ‘диплáйер’), который мы далее будем использовать для манипуляций с таблицами: data(package = &#39;dplyr&#39;) Данные, доступные в пакете dplyr На рисунке можно видеть перечень наборов данных и их краткие описания. Для загрузки набора данных передайте его название в качестве первого параметра функции data(). Ну-ка, что там с персонажами из Star Wars: data(starwars, package = &#39;dplyr&#39;) starwars Обратите внимание, что после подключения набора данных он становится доступным в текущей сесси R именно с тем именем, с которым он сохранен в пакете Если вызвать функцию data() без параметров, будет выведен список данных со всех пакетов, которые подключены в текущей сессии R: data() Данные, доступные в текущей сессии R По умолчанию в RStudio всегда подключен пакет datasets, который устанавливается вместе с базовым дистрибутивом R. Если пакет подключен в текущую сессию, то можно получить набор данных по его имени, не указывая название пакета. Например, в пакете datasets есть набор данных quakes о землетрясениях на о. Фиджи: data(quakes) quakes Таким образом, если вы используйете пакет dplyr в своей программе, данные о героях Звездных Войн можно загрузить не указывая пакет, т.к. он был ранее подключен через функцию library(): library(dplyr) ## ## Присоединяю пакет: &#39;dplyr&#39; ## Следующие объекты скрыты от &#39;package:stats&#39;: ## ## filter, lag ## Следующие объекты скрыты от &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union data(starwars) 3.3.2 Текстовые таблицы Текстовые таблицы бывают, как правило, двух типов: с разделителем (CSV) и с фиксированной шириной столбца. 3.3.2.1 Файлы с разделителем CSV (Comma-separated value) — общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу: Каждая строка в файле соответствует строке в таблице. Ячейки отделяются друг от друга символом-разделителем. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов. Стандартным разделителем ячеек является запятая (,), а десятичным разделителем — точка (.). Однако это не является строгим правилом. Например, в ряде локалей (например, русской) запятая используется в качестве десятичного разделителя, поэтому колонки часто разделяют точкой с запятой (;). Формат CSV никак не оговаривает наличие заголовочной строки с названиями столбцов в начале файла — она может как отсутствовать, так и присутствовать. Поэтому при чтении таблиц из файлов необходимо информировать программу о наличии заголовка путем указания соответствующего параметра. Любая функция, используемая вами для чтения файлов, вне зависимости от пакета, который вы используете, как правило, содержит параметры, с помощью которых можно задать символы, отвечающие за десятичный разделитель и разделитель столбцов, а также наличие или отсутствие строки-заголовка и кодировку файла. Если таблица читается некорректно, ознакомьтесь со справкой к функции и при необходимости замените стандартные значения этих параметров на те, что соответствуют формату вашей таблицы. Например, вот так выглядит текстовая таблица в формате CSV с данными по численности населения в Федеральных округах Российской Федерации за 2005 и 2010-2013 гг. (по данным Росстата): N,Region,Year05,Year10,Year11,Year12,Year13 1,Центральный,4341,3761,3613,3651,3570 2,Северо-Западный,3192,3088,2866,2877,2796 3,Южный федеральный,1409,1446,1436,1394,1321 4,Северо-Кавказский,496,390,397,395,374 5,Приволжский,3162,2883,2857,2854,2849 6,Уральский,1681,1860,1834,1665,1624 7,Сибирский,2575,2218,2142,2077,1941 8,Дальневосточный,871,870,821,765,713 Таблицы в формате CSV можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета readr, который входит в набор пакетов tidyverse. Мы будем использовать последние, а стандартные средства языка оставим на самостоятельное изучение. Для чтения таблиц с разделителем в readr имеется несколько функций: read_csv() читает файлы с разделителем запятой read_csv2() читайт файоы с разделителем точкой-с-запятой (может быть особенно актуально для русских файлов) read_tsv() читает файлы с разделителем табуляцией или пробелом read_delim() читает файлы с произвольным разделителем (указывается в качестве параметра) Вышеуказанный файл сохранен с разделителем запятой, поэтому мы можем прочесть его посредством первой функции из списка: library(readr) (okruga = read_csv(&#39;okruga.csv&#39;)) ## Parsed with column specification: ## cols( ## `№` = col_integer(), ## Регион = col_character(), ## `2005` = col_integer(), ## `2010` = col_integer(), ## `2011` = col_integer(), ## `2012` = col_integer(), ## `2013` = col_integer() ## ) Как видно, функции пакета readr выдают диагностическую информацию о том, к какому типу были приведены столбцы таблицы при чтении. Помимо этого, первая строка была использована в качестве заголовочной. 3.3.2.2 Файлы с фиксированной шириной столбца В файлах с фиксированной шириной на каждый столбец резервируется определенное количество символов. При этом данные выравниваются по правому краю, а короткие строки отбиваются слева пробелами. Такой формат часто используется в численных моделях (например, метеорологических) для представления входных данных или результатов расчетов. Например, файл ниже содержит данные об энергии ветра (\\(Вт/м^2\\)) на высотах 50 и 110 м по точкам вдоль побережья Черного моря: 1 43.500000 28.000000 111.05298 178.41447 2 43.500000 28.500000 187.38620 301.05331 3 44.000000 28.500000 168.82031 271.22421 4 44.500000 28.500000 157.22586 252.59746 5 44.500000 29.000000 189.46452 304.39597 6 45.000000 29.000000 170.40709 273.77536 7 45.000000 29.500000 198.92389 319.58777 8 45.500000 29.500000 188.64406 303.07242 9 46.000000 30.000000 180.10541 289.35379 10 46.000000 30.500000 207.91818 334.03564 Для чтения таких файлов в readr есть функции: read_fwf() читает файлы с фиксированной шириной столбца, позволяя задавать ширины столбцов (через fwf_widths()) или начальные позиции каждого столбца (через fwf_positions()) read_table() читает наиболее распространенный вариант файла с фиксированной шириной столбца, в котором колонки разделены пробелами. Позиции столбцов определяются автоматически, что очень удобно. Прочитаем вышеприведенный файл с данными о ветровой энергии: (wenergy = read_table(&#39;wind_energy.txt&#39;, col_names = c(&#39;id&#39;, &#39;lat&#39;, &#39;lon&#39;, &#39;energy50&#39;, &#39;energy110&#39;))) ## Parsed with column specification: ## cols( ## id = col_integer(), ## lat = col_double(), ## lon = col_double(), ## energy50 = col_double(), ## energy110 = col_double() ## ) 3.3.3 Таблицы Microsoft Excel Для чтения таблиц Microsoft Excel, так же как и для тектовых файлов, существуют множество пакетов, таких как xlsx, openxlsx и readxl. Я рекомендую пользоваться пакетом readxl, поскольку он не имеет внешних зависимостей, а его функции концептуально идентичны функциям пакета readr. Прочтем данные о лесовосстановлении (в тысяч га), полученные из регионального ежегодника Росстата за 2017 год. Эта таблица содержит колонку с названием субъекта и еще 8 колонок с данными по годам. Поскольку в таблице есть пропущенные значения, необходимо определить типы столбцов (в противном случае они могут быть определены как текстовые): library(readxl) (reforest = read_excel(&#39;reforest.xlsx&#39;, col_types = c(&#39;text&#39;, rep(&#39;numeric&#39;, 8)))) 3.3.4 Параметры Функции пакетов readr и readxl имеют идентичный набор параметров, позволяющих управлять процедурой чтения данных (многоточие используется вместо перечисления параметров): skip = n позволяет пропустить первые n строк таблицы (например, если в них содержатся какие-то комментарии) col_names = FALSE позволяет не интерпретировать первую строку как заголовочную (вместо этого она будет читаться как строка с данными) col_names = c(...) позволяет задать имена столбцов (удобно, если в файле они длинные) col_types = cols(...) позволяет задать типы столбцов (необходимо, если функция неправильно определяет их сама) na = '-' позволяет указать символ, который используется для указания пропущенных значений (в данном случае указан прочерк-дефис) locale = locale(...) управляет локалью (в том числе позволяет указать кодировку файла) Стандартной кодировкой для представления текста в UNIX-подобных системах (Ubuntu, macOS и т.д.) является UTF-8 (Unicode), в русскоязычных версиях Windows — CP1251 (Windows-1251). Текстовый файл CSV, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в R вы видите вместо текста нечитаемые символы — кракозябры — то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Если вы не знаете, что такое кодировка и Юникод, то вам сюда По умолчанию файлы читаются в той кодировке, которая соответствует операционной системе, на которой запущен R. Если файл создан в другой кодировке, придется указать ее при чтении. Например, вы пользуетесь macOS (UTF-8), а ваш коллега — Windows (CP1251), то для чтения созданного им файла вам, скорее всего, понадобится указать что-то вроде locale = locale(encoding = 'CP1251') 3.4 Просмотр Для просмотра фрейма данных в консоли RStudio вы можете использовать несколько опций. Пусть наш фрейм данных называется reforest. Тогда: print(reforest) — выводит фрейм в консоль целиком (можно написать просто tab в консоли). head(reforest, n) — отбирает первые \\(n\\) строк фрейма tail(reforest, n) — отбирает последние \\(n\\) строк фрейма По умолчанию для функций head() и tail() \\(n=6\\). Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли head(reforest) или tail(reforest), то для выбранных строк будет вызвана функция print(), аналогично выводу всего фрейма: # ПРОСМОТР ТАБЛИЦЫ print(reforest) ## # A tibble: 89 x 9 ## Region `2005` `2010` `2011` `2012` `2013` `2014` `2015` `2016` ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Российская Фед… 812. 812. 860 842. 872. 863 803. 840. ## 2 Центральный фе… 52.6 62.7 60.9 60.3 70.9 71.2 72.6 77 ## 3 Белгородская о… 0.4 0.1 0.3 0.3 0.4 0.4 0.2 0.2 ## 4 Брянская облас… 2.9 2.8 3 3.2 3.5 3.3 3.1 3 ## 5 Владимирская о… 4.4 5.3 5.7 6 7.1 5.9 6 4.9 ## 6 Воронежская об… 1.1 1.1 1.8 3 2.7 2.7 2.6 2.3 ## 7 Ивановская обл… 2.1 1.6 2.2 3.1 4 4.8 4.6 4.2 ## 8 Калужская обла… 2.2 2.3 2.3 2.5 2.4 3.1 3.2 3.2 ## 9 Костромская об… 10 25.2 11 11.8 15.3 13.6 15.1 16.4 ## 10 Курская область 0.5 0.3 0.4 0.6 0.6 0.6 0.5 0.4 ## # ... with 79 more rows head(reforest) tail(reforest) RStudio предоставляет графический интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать. Чтобы его активировать, надо вызвать функцию View(): View(tab) Поскольку функции head() и tail() возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции View(): View(head(reforest, 3)) Как правило, не следует оставлять вызовы функции View() в тексте законченной программы. Это приведет к тому, что при запуске будут открываться новые вкладки с просмотром таблиц, что может раздражать пользователя (в том числе и вас самих). Используйте View() для вывода окончательного результата в конце программы или при отладке программы. Все вызовы View() в программе можно легко закомментировать или раскомментировать, выполнив поиск с заменой 'View(' на '# View(' и наоборот. 3.5 Столбцы, строки и ячейки 3.5.1 Названия Столбцы, строки и ячейк представляют собой основные структурные элементы фрейма данных или тиббла. Перед тем как мы поднимемся на уровень выше и рассмотрим обобщенные операции преобразования таблиц, необходимо посмотреть, как извлекать структурные элементы таблиц. Столбцы и строки таблицы имеют названия, которые можно читать и записывать с помощью функций colnames() и rownames(): # Чтение названий столбцов и строк colnames(okruga) ## [1] &quot;№&quot; &quot;Регион&quot; &quot;2005&quot; &quot;2010&quot; &quot;2011&quot; &quot;2012&quot; &quot;2013&quot; rownames(okruga) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; # Замена названий столбцов и строк colnames(okruga) &lt;- c(&quot;N&quot;, &quot;Region&quot;, &quot;Year05&quot;, &quot;Year10&quot;, &quot;Year11&quot;, &quot;Year12&quot;, &quot;Year13&quot;) print(okruga) ## # A tibble: 8 x 7 ## N Region Year05 Year10 Year11 Year12 Year13 ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 Центральный 4341 3761 3613 3651 3570 ## 2 2 Северо-Западный 3192 3088 2866 2877 2796 ## 3 3 Южный федеральный 1409 1446 1436 1394 1321 ## 4 4 Северо-Кавказский 496 390 397 395 374 ## 5 5 Приволжский 3162 2883 2857 2854 2849 ## 6 6 Уральский 1681 1860 1834 1665 1624 ## 7 7 Сибирский 2575 2218 2142 2077 1941 ## 8 8 Дальневосточный 871 870 821 765 713 Названия строк редко заменяются, поскольку с точки зрения реляционной алгебры большого смысла они не имеют. 3.5.2 Обращение к столбцам К столбцу можно обращаться по номеру и названию (с помощью оператора $ или в кавычках внутри скобок). Если вы указываете в квадратных скобках номер без запятой, он трактуется именно как номер столбца, а не строки. Тип возвращаемого значения зависит от синтаксиса: обращение через $ возвращает вектор; обращение в скобках с запятой к одному столбцу возвращает вектор; обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных; обращение в скобках без запятой возвращает фрейм данных. Несколько примеров: # Один столбец - результат зависит от запятой okruga$Year05 # столбец в виде вектора okruga[, &quot;Year05&quot;] # столбец в виде вектора okruga[, 2] # столбец в виде вектора okruga[&quot;Year05&quot;] # столбец в виде фрейма данных/тиббла okruga[2] # столбец в виде фрейма данных/тиббла # Несколько столбцов - всегда фрейм данных/тиббл okruga[, c(1, 4)] okruga[, c(&quot;Region&quot;, &quot;Year11&quot;)] okruga[c(&quot;Region&quot;, &quot;Year11&quot;)] okruga[c(1, 4)] 3.5.3 Обращение к строкам Обращаться к строкам можно по их номерам. В этом случае в качестве индекса можно передать номер (номера) интересующих строк, либо вектор логических значений, в котором интересующие строки помечены как TRUE, а остальные — FALSE (в этом случае длина вектора должна равняться количеству строк в таблице): okruga[5, ] # Одна строка okruga[2:4, ] # Несколько строк okruga[okruga$Year10 &gt; 2000, ] # Несколько строк через TRUE/FALSE В отличие от работы со столбцами, выбор строк всегда возвращает таблицу (фрейм или тиббл). 3.5.4 Обращение к ячейкам Чтобы выбрать конкретные ячейки в таблице, необходимо задать оба измерения: okruga[2:3, c(&quot;Year11&quot;, &quot;Year12&quot;)] Обратите внимание на то, что при этом возвращаются все комбинации строк и столбцов. То есть, нельзя выбрать ячейки 2,&quot;Year11&quot; и 3,&quot;Year2&quot; — вместе с ними также будут выбраны ячейки 3,&quot;Year11&quot; и 2,&quot;Year2&quot;. Впрочем, подобные задачи возникают довольно редко 3.6 Преобразования 3.6.1 Грамматика манипуляций Если проанализировать наиболее типичные манипуляции, которые осуществляются над таблицами, то их окажется совсем немного. К таким манипуляциям относятся выбор переменных, фильтрация строк, сортировка, вычисление новых столбцов, агрегирующие статистики и группировка. Все эти задачи можно решать стандартными средствами R (и мы увидим, как это делается). Однако некоторые из них достаточно громоздки в реализации (например, группировка). К счастью, экосистема R предлагает готовые средства, позволяющие справляться с подобными задачами простым и элегантным путем. Эти средства предоставляет пакет dplyr, входящий в набор инструментов tidyverse. В основе конецепции dplyr лежит понятие о грамматике табличных манипуляций, которая включает в себя ограниченное число наиболее используемых операций, а также ряд вспомогательных функций. Основные функции пакета dplyr представлены в таблице ниже: Функция Назначение select() Выбор переменных по их названиям filter() Выбор строк по заданному критерию (запросу) arrange() Упорядочение по указанным переменным mutate() Вычисление новых переменных (мутирование) summarise() Агрегирование значений переменных group_by() Группировка строк (для последующего агрегирования) Как можно видеть, этих функций совсем немного. Дополнительно к ним пакет dplyr содержит еще множество вспомогательных функций, которые применяются при выполнении основных манипуляций. Рассмотрим применение этих функций на примере работы с таблицей по восстановлению лесного фонда в регионах России. Для начала переименуем столбцы с годами, чтобы их названия начинались с буквы y: old_names = colnames(reforest) colnames(reforest) = c(old_names[1], paste(&#39;y&#39;, old_names[2:9], sep = &#39;&#39;)) Начнем с выбора нужных переменных, используя select(). Оставим только название региона и данные за 2010 и 2015 гг: (rdf = select(reforest, Region, y2010, y2015)) Ту же самую задачу можно решить от противного — указать со знаком - те столбцы, которые надо убрать: (rdf = select(reforest, -y2005, -y2011:-y2014, -y2016)) Обратите внимание на то, что можно указывать еще и диапазоны названий столбцов, если они идут друг за другом. Названия столбцов в функциях dplyr указываются без кавычек, что позволяет сделат код проще и читаемее. Этот прием называется квотацией, с ним мы познакомимся подробнее в следующей лекции. Чтобы осуществить фильтрацию, необходимо задать условие, накладываемое на строки. Текущая таблица содержит данные по субъектам, федеральным округам и России в целом. Поскольку данные по округам и стране являются избыточными (их можно получить путем агрегирования данных по субъектам), выполним фильтрацию таблицы, убрав строки, в которых содержатся слова Федерация и федеральный округ. Для этого используем функцию str_detect() из пакета stringr, который также входит в tidyverse: flt = !stringr::str_detect(rdf$Region, &#39;Федерация|федеральный округ&#39;) # готовим фильтр для строк (regdf = filter(rdf, flt)) # применяем фильтр Условие можно прописать непосредственно при вызове filter(). Например, выберем регионы, в которых объем лесовосстановительных работ в 2015 году был более 50 тыс. га: filter(regdf, y2015 &gt; 50) Для сортировки таблицы посредством arrange() необходимо указать столбцы, по которым будет осуществлено упорядочение строк. Чаще всего это один столбец, например y2015: arrange(regdf, y2015) # по возрастанию arrange(regdf, desc(y2015)) # по убыванию Добавление новых столбцов осуществляется посредством mutate(). Например, определим, как изменился объем лесовосстановительных работ в 2015 году по сравнению с 2010 годом: (regdf = mutate(regdf, delta = y2015 - y2010)) Существует редко используемая разновидность мутирования, при которой сохраняются только столбцы, указанные в параметрах. Она называется transmute() — по сути это кобинация mutate() и select(). Если вы хотите просто сохранить какой-то из столбцов, то укажите его через оператор равенства: transmute(regdf, Region = Region, delta = y2015 - y2010) # сохраняем только Region и delta Вы можете выполнять агрегирование данных и вычислять суммы, средние значения и т.д. используя summarise(). После того как мы избавились от избыточных данных в таблице, мы всегда можем получить их через агрегирование. Например, посчитаем суммарный, минимальный и максимальный объем лесовосстановительных работ по всей стране: summarise(regdf, sumforest = sum(y2015, na.rm = TRUE), minforest = min(y2015, na.rm = TRUE), maxforest = max(y2015, na.rm = TRUE)) Достаточно часто данные надо агрегировать не по всей таблице, а по группам измерений. Предположим, что нам нужно найти регион с наихудшей тенденцией изменения лесовосстановительных работ в каждом федеральном округе. Для этого нам потребуется: Дополнить каждую строку региона информацией о принадлежности к федеральному округу Сгруппировать субъекты по федеральным округам — Отсортировать каждую группу по убыванию значения поля Взять первую строку в каждой группе Объединить результаты Для начала вернемся на этап, когда мы избавлялись от федеральных округов в таблице. Поскольку в исходной таблице данные были упорядочены по округам, эту информацию можно использовать для создания нового столбца с названием округа каждого субъекта. В этом нам поможет функция fill() из пакета tidyr: flt2 = stringr::str_detect(rdf$Region, &#39;федеральный округ&#39;) # ищем округа (rdf2 = mutate(rdf, okrug = if_else(flt2, Region, NULL))) # перенесем названия округов в новый столбец (rdf2 = tidyr::fill(rdf2, okrug)) # заполним все пустые строчки предыдущим значением (regdf = filter(rdf2, flt)) # оставим только регионы Теперь мы можем определить регион с максимальным объемом лесовосстановительных работ в каждом Федеральном округе, используя вспомогательную функцию row_number() которая возвращает номер для каждой строки таблицы: regdf_gr = group_by(regdf, okrug) regdf_arr = arrange(regdf_gr, desc(y2015)) (regdf_res = filter(regdf_arr, row_number() == 1)) Использование dplyr целым обладает рядом преимуществ по сравнению с применением стандартных средств R: вызов функций с говорящими названиями операции более понятными; код выглядит более чистым и легко читаемым за счет отсутствия обращений к фреймам данных через квадратные скобки, доллары и «закавыченные» названия переменных; код с использованием функций dplyr часто оказывается короче, чем его традиционные аналоги; операции dplyr можно выстраивать в конвейеры с помощью пайп-оператора %&gt;%. Последнюю возможность мы рассмотрим в следующем параграфе. 3.6.2 Конвейер манипуляций В предыдущем параграфе было показано как найти регион-лидер в каждой группе по выбранному показателю. При этом, несмотря на то что интерес представляет только конечный результат, нам пришлось шесть раз осуществить запись промежуточного результата в соответствующую переменную. Чтобы избежать подобного многословия в программах, в R реализована возможность организации конвейера манипуляций (pipeline) посредством использования пайп-оператора %&gt;%. Пайп-оператор %&gt;% предназначен для компактной и наглядной записи последовательностей обработки данных. Работает он следующим образом: x %&gt;% f эквивалентно f(x) x %&gt;% f(y) эквивалентно f(x, y) x %&gt;% f %&gt;% g %&gt;% h эквивалентно h(g(f(x))) Коротко говоря, пайп оператор берет результат вычисления выражения слева и подставляет его в качестве первого аргумента в выражение справа. С помощью этого оператора вышеприведенный код по нахождению региона-лидера можно записать так: regdf = rdf %&gt;% mutate(okrug = if_else(flt2, Region, NULL)) %&gt;% tidyr::fill(okrug) %&gt;% filter(flt) leaders = regdf %&gt;% group_by(okrug) %&gt;% arrange(desc(y2015)) %&gt;% filter(row_number() == 1) print(leaders) ## # A tibble: 8 x 4 ## # Groups: okrug [8] ## Region y2010 y2015 okrug ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Иркутская область 80.4 117. Сибирский федеральный округ ## 2 Хабаровский край 70.2 59.6 Дальневосточный федеральный округ ## 3 Архангельская область 39.4 57.6 Северо-Западный федеральный округ ## 4 Пермский край 22.9 32.5 Приволжский федеральный округ ## 5 Свердловская область 25.6 24.4 Уральский федеральный округ ## 6 Костромская область 25.2 15.1 Центральный федеральный округ ## 7 Волгоградская область 1.8 0.9 Южный федеральный округ ## 8 Чеченская Республика 0.9 0.7 Северо-Кавказский федеральный округ Если бы мы попытались написать те же последовательности операций одним выражением в традиционной «матрешечной» парадигме, это выглядело так: regdf = filter( tidyr::fill( mutate( rdf, okrug = if_else(flt2, Region, NULL) ), okrug ), flt ) result = filter( arrange( group_by( regdf, okrug ), desc(y2015) ), row_number() == 1 ) Выглядит несколько устрашающе. К тому же, читать такой код приходится задом наперед (изнутри наружу), чтобы понять последовательность действий. Таким образом, организация конвейера манипуляций с использованием пайп-оператора позволяет: упорядочить операции по обработке данных слева направо (в противоположность направлению изнутри наружу); избежать вложенных вызовов функций (матрёшки); минимизировать количество переменных для храненния промежуточных результатов; упростить добавление новых операций по обработке данных в любое место последовательности. Пайп-оператор %&gt;% можно быстро набрать в RStudio, нажав клавиатурное сочетание Ctrl + Shift + M (Cmd + Shift + M на помпьютерах Mac) 3.6.3 Преобразование структуры Одни и те же данные можно предствить в табличной форме по-разному. Одна форма будет удобной для ручного заполнения таблицы. Другая форма будет удобной для программной обработки и анализа. Большинство же остальных форм не будут оптимальными ни для того, ни для другого. Наш курс посвящен автоматизированной обработке данных на языке R, поэтомы мы должны определить, какая форма таблицы удобна для этих целей. В экосистеме R такие данные принято называть «аккуратными», или по-английски tidy data. Аккуратные таблицы отвечают следующим требованиям: Каждый столбец представляет переменную Каждая строка представляет измерение Каждая ячейка представляет значение С некоторой долей условности можно говорить, что это третья нормальная форма реляционного отношения. Таблицы, с которыми мы работали до настоящего момента в этой главе, не отвечают данным требованиям. В частности, данные по лесовосстановлению содержат столбцы, в которых приведены данные за соответствующие года. Это одна переменная, разбитая на несколько столбцов. При этом год измерения является второй переменной. Такая форма удобна для заполнения и визуального анализа, но неудобна для программной обработки. Предположим, что нам надо найти все регионы, у которых в промежутке между 2012 и 2015 годами лесовосстановительные работы хотя бы в один год не производились (их объем был равен нулю). В текущей форме таблицы нам придется сделать 4 условия — по одному на каждый год-столбец. Это при том, что мы должны быть уверены, что все промежуточные года в таблице присутствуют. Приведя таблицу к аккуратному виду, мы можем решить задачу более компактно, отправив всего 2 запроса: один на год измерения и второй на величину показателя. Приведение таблицы к аккуратному виду можно сделать, используя функции из пакета tidyr. Основных функций в этом пакете всего две: gather() берет несколько колонок и преобразует их к виду «ключ—значение»: широкие таблицы становятся длинными. spread() берет две колонки, соответствующие ключу и значению, и распределяет их на множество колонок: длинные таблицы становятся широкими. Помимо этого, есть еще 2 полезных функции, которые позволяют «распиливать» или «склеивать» колонки: separate() разделяет колонку на несколько колонок, используя заданный символ-разделитель или позицию. unite() скливает несколько колонок, используя заданный символ-разделитель. Функция gather() ожидает получить следующие параметры: data — входная таблица (фрейм данных или тиббл) key — имя нового столбца, который будет хранить ключи value — имя нового столбца, который будет хранить значения ... — перечисление столбцов, которые необходимо подвергнуть преобразованию Рассмотрим на примере таблицы reforest приведение к аккуратному виду: library(tidyr) (reforest_tidy = reforest %&gt;% gather(year, value, y2005:y2016)) Осталось избавиться от буквы y перед каждым годом — для этого можно использовать separate(), select() и mutate() чтобы отделить букву в отдельный столбец, отбросить его, а оставшийся год преобразовать к целочисленному значению: reforest_tidy = reforest_tidy %&gt;% separate(year, c(&#39;y&#39;, &#39;year&#39;), 1) %&gt;% select(-y) %&gt;% mutate(year = as.integer(year)) reforest_tidy Теперь можно выполнять любые запросы, комбинирующие год измерения и величину показателя: reforest_tidy %&gt;% filter(year &gt; 2011 &amp; year &lt; 2016 &amp; value == 0) В некоторых случая бывает удобно распределить переменную по нескольким колонкам. В частности, это может быть удобно, если нам надо вычислить разности между годами. Для этого используем spread(): (reforest = reforest_tidy %&gt;% spread(year, value)) Теперь вычислим разности по сравнению с предыдущим годом: diffs = reforest %&gt;% select(`2011`:`2016`) - reforest %&gt;% select(`2010`:`2015`) diffs %&gt;% mutate(Region = reforest$Region) %&gt;% select(Region, `2011`:`2016`) 3.7 Соединение Данные, с которыми мы работаем, часто распределены по нескольким таблицам. Если возникает задача их совместного использования (сравнения, вычисления производных показателей), таблицы необходимо соединить. В процессе соединения в обеих таблицах находятся строки, соответствующие одному и тому же измерению (например, региону). После этого столбцы второй таблицы пристыковываются к столбцам первой таблицы, а строки — к соответствующим строкам (мутирующее соединение), либо же происходит фильтрация строк первой таблицы на основе нахождения соответствующих строк во второй таблице (фильтрующее соединение). Чтобы найти соответствие, в обеих таблицах должен быть по крайней мере один столбец, идентифицирующий каждую строку. В первой таблице он называется первичным ключом (primary key), во второй таблице — внешним ключом (foreign key). Для выполнения соедининия в пакете dplyr имеется несколько функций. Мутирующее соединение: inner_join(x, y, by = ) возвращает все строки из x, для которых имеются соответствующие строки в y, а также все столбцы из x и y. left_join(x, y, by = ) возвращает все строки из x, а также все столбцы из x и y. Строки в x, для которых не найдены соответствия в y, будут иметь значения NA в присоединенных столбцах right_join(x, y, by = ) возвращает все строки из y, а также все столбцы из x и y. Строки в y, для которых не найдены соответствия в x, будут иметь значения NA в присоединенных столбцах full_join(x, y, by = ) возвращает все строки и колонки из x и y. В строках, для которых не найдено соответствие ячейки присоединяемых стольков будут заполнены значениями NA Фильтрующее соединение: semi_join(x, y, by = ) возвращает все строки из x, для которых имеются соответствующие строки в y, а также все столбцы из x anti_join(x, y, by = ) возвращает все строки из x, для которыхне найдены соответствующие строки в y, а также все столбцы из x Рассмотрим соединение таблиц на примере данных по лесовосстановлению и заготовкам древесины. Наша задача — оценить количество гектаров восстанавливаемой лесной площади (в га) на тысячу кубометров лесозаготовок (и таким образом оценить эффективность лесовосстановительных мероприятий). Подгрузим таблицу по лесозаготовкам: (timber = read_excel(&#39;timber.xlsx&#39;, col_types = c(&#39;text&#39;, rep(&#39;numeric&#39;, 8))) %&gt;% filter(!stringr::str_detect(Регион, &#39;Федерация|федеральный округ&#39;))) Приведем ее к аккуратному виду, который соответствует виду таблицы по лесовосстановлению: (timber_tidy = timber %&gt;% gather(year, harvest, `2010`:`2016`) %&gt;% transmute(Region = Регион, year = as.numeric(year), harvest = harvest)) Теперь нам осталось присоединить данные по лесозаготовкам к таблице по лесовосстановлению, используя имя региона (Region) и год (year) в качестве ключевых полей. Для этого мы используем функцию inner_join(), поскольку нас интересует сравнение по тем годам, для которых имеются данные в обеих таблицах: (compare = reforest_tidy %&gt;% inner_join(timber_tidy, by = c(&quot;Region&quot; = &quot;Region&quot;, &quot;year&quot; = &quot;year&quot;))) Наконец, вычислим искомое отношние и упорядочим регионы по году (возрастание) и отношению (убывание): (compare = compare %&gt;% mutate(ratio = 1000 * value / harvest) %&gt;% select(Region, year, ratio, value, harvest) %&gt;% arrange(year, desc(ratio))) Из этой таблицы видно, что площадь восстанавливаемых лесов далеко не всегда пропорциональна объему заготовок необработанной древесины. 3.8 Запись Запись файлов в текстовом формате можно осуществить посредством функций из пакета readr, таких как write_delim(), write_csv() и write_tsv(). Базовый синтаксис их предельно прост: write_csv(compare, &quot;output/timber_compare.csv&quot;) Для записи таблиц Microsoft Excel можно использовать возможности пакета writexl: library(writexl) write_xlsx(compare, &quot;output/timber_compare.xlsx&quot;) Каждая из этих функций содержит ряд дополнительных параметров, позволяющих управлять внешним видом выгружаемых таблиц. Более подробно с ними вы можете ознакомиться, вызвав справку для соответствующей функции. 3.9 Правила подготовки таблиц для чтения в R Несмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу: В первой строке таблицы должны располагаться названия столбцов. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: Валовый внутренний продукт за 2015 г.. Хорошее название столбца: GDP2015. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в R. Следование этим правилам значительно облегчит работу с табличными данными в среде R. 3.10 Краткий обзор 3.11 Контрольные вопросы и упражнения 3.11.1 Вопросы 3.11.2 Упражнения Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "]
]
