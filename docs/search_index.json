[
["index.html", "Визуализация и анализ географических данных на языке R Введение Программное обеспечение Установка и подключение пакетов Выполнение программного кода Установка рабочей директории Диагностические функции Получение справки Комментарии Стандарт оформления кода на R Зарезервированные слова Названия переменных Названия специальных символов Ссылка на пособие", " Визуализация и анализ географических данных на языке R Тимофей Самсонов 2018-09-04 Введение Добро пожаловать в курс “Визуализация и анализ географических данных на языке R”! В данном курсе мы освоим азы программирования на языке R, а затем научимся использовать его для решения географических задач. Никаких предварительных знаний и навыков программирования не требуется. Программное обеспечение Для успешного прохождения курса на вашем компьютере должно быть установлено следующее программное обеспечение: Язык R Среда разработки RStudio Выбирайте инсталлятор, соответствующий вашей операционной системе. Обратите внимание на то, что RStudio не будет работать, пока вы не установите базовые библиотеки языка R. Поэтому обе вышеуказанные компоненты ПО обязательны для установки. Установка и подключение пакетов Существует множество дополнительных пакетов R (вы тоже можете написать свой) практически на все случаи жизни. Как и дистрибутив R, они доступны через CRAN (Comprehensive R Archive Network). Одним из таких пакетов является, например, пакет openxlsx, позволяющий читать и записывать файлы в форматах Microsoft Excel. Существует два способа установки пакетов в RStudio. Во-первых, вы можете сделать это в графическом интерфесе, нажав кнопку Install на панели Packages (по умолчанию эта панель расположена в нижней правой четверти окна программы). В появившемся окне введите название пакета и нажмите Install: Установка пакета Во-вторых, вы можете вызвать из консоли команду install.packages(), передав ей в качестве параметра название пакета, заключенное в кавычки: install.packages(&quot;readxl&quot;) Никогда не включайте команду install.packages() в тело скрипта. Это приведет к тому, что каждый раз при запуске программы среда RStudio будет пытаться заново установить пакет, который уже установлен. Запускайте эту функцию только из консоли. Подключение пакета осуществляется с помощью функции library(), при этом название пакета можно в кавычки не заключать: library(readxl) Не получается установить пакет Иногда по тем или иным причинам невозможно установить пакет в стандартный каталог. Наиболее часто эта проблема дает о себе знать в случае когда: у вас Windows и ваш пользователь назван кириллическими буквами (Маша, Петя и т.д.) у вашего пользователя нет прав административного доступа к каталогу, в который устанавливаются пакеты Чтобы проверить, где находится ваши текущие каталоги для установки пакетов, можно набрать в консоли команду .libPaths(). На Windows для этих целей резервируется сразу 2 каталога — пользовательский и системный: &gt; .libPaths() [1] &quot;C:/Users/Timofey Samsonov/Documents/R/win-library/3.5&quot; &quot;C:/Program Files/R/R-3.5.1/library&quot; На UNIX-подобных системах (macOS, Linux) используется только системный каталог: &gt; .libPaths() [1] &quot;/Library/Frameworks/R.framework/Versions/3.5/Resources/library&quot; По умолчанию на Windows пакеты устанавливаются в пользовательскую директорию (&quot;C:/Users/Timofey Samsonov/Documents/R/win-library/3.5&quot;). Если Rstudio не сможет установить пакет в эту директорию, он будет пытаться установить его в системную директорию (&quot;C:/Program Files/R/R-3.5.1/library&quot;). Если же и туда поставить не удается, будет выведено сообщение об ошибке. В этом случае вам необходимо создать новый каталог для размещения пакетов, который не будет вызывать проблем с кодировкой и доступом. Требования к каталогу следующие: наличие полных (административных) прав доступа у текущего пользователя отсутствие кириллических символов в пути Подходящие примеры каталогов: C:\\Rlib\\, D:\\Rlibraries\\. Создав каталог, вы можете решить проблему с пакетами временно или постоянно. Временное решение: при установке пакета укажите адрес каталога в параметре lib функции install.packages(). Например: install.packages(&quot;xlsx&quot;, lib = &quot;C:/Rlib/&quot;) для загрузки пакета укажите местоположение пакета в дополнительном параметре lib.loc: library(xlsx, lib.loc = &quot;C:/Rlib&quot;) Постоянное решение: добавьте путь к новому каталогу через функцию .libPaths(): .libPaths(c(&quot;С:/Rlib/&quot;, .libPaths())) используйте для установки и загрузки команды install.packages и library как обычно. Новые пакеты будут устанавливаться и загружаться из нового каталога, а системные пакеты будут по прежнему доступны из каталогов по умолчанию Если добавление через .libPaths() по каким-то причинам не сработало, вы можете решить ту же задачу, используя системные переменные: Откройте список системных переменных (команда My Computer -&gt; System Properties -&gt; Advanced system properties -&gt; Environment Variables -&gt; User Variables). Создайте новую системную переменную (команда New User Variable), дайте ей имя R_LIBS и значение, равное пути к вашему каталогу (C:\\Rlib\\). Сохраните результат. Выглядеть это должно примерно так: Системная переменная для библиотек Выполнение программного кода Существует несколько способов выполнения исходного кода: Выполнить одну строку: поставить курсор в любую строку и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X). Выполнить несколько строк: выделить необходимые строки и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X). Выполнить весь код можно сразу тремя способами: Выделить весь текст и нажать над редактором кода кнопку Run или сочетание клавиш Ctrl+Enter (Cmd+Enter для OS X) Нажать клавиатурное сочетание Ctrl+Alt+Enter (Cmd+Alt+Enter для OS X) Нажать в правом верхнем углу редактора кода кнопку Source Команды Source и Ctrl+Alt+Enter могут не сработать, если у вас не установлена рабочая директория, или если в пути к рабочей директории содержатся кириллические символы (не актуально для Windows 10+ и OS X, которые являются системами, основанными на кодировке Unicode). Существует также ряд дополнительных опций выполнения кода, которые вы можете найти в меню Code &gt; Run Region Выполняя код построчно, делайте это последовательно, начиная с первой строки программы. Одна из самых распространенных ошибок новичков заключается в попытке выполнить некую строку, не выполнив предыдущий код. Нет никаких гарантий, что что-то получится, если открыть файл, поставить курсор в произвольную строку посередине программы и попытаться выполнить ее. Возможно, вам и повезет — если эта строка никак не зависит от предыдущего кода. Однако в реальных программах такие строки составляют лишь небольшую долю от общего объема. Как правило, в них происходит инициализация новых переменных стартовыми значениями. Установка рабочей директории Вы можете открывать и сохранять любые поддерживаемые файлы в R, указывая полный системный путь к файлу. Например, так может выглядеть открытие и сохранение таблицы в формате CSV на компьютере Mac: d = read.csv(&quot;/Volumes/Data/GitHub/r-geo-course/data/oxr_vod.csv&quot;) write.csv(d, &quot;/Volumes/Data/GitHub/r-geo-course/data/oxr_vod_copy.csv&quot;) Однако, если вам требуется открыть или сохранить несколько файлов (и не только данных, но и графиков, карт и т.п.), программа будет выглядеть громоздко. К тому же, прописывать каждый раз полный путь достаточно утомительно и неприятно (даже путем копирования и вставки), а главное — может привести к ошибкам. Чтобы облегчить работу с файлами, в R существует понятие домашней директории. Домашняя директория задается для текущей сессии R с помощью функции setwd(). После установки домашней директории R будет полагать, что все открываемые и сохраняемые файлы должны находиться в ней: setwd(&quot;/Volumes/Data/GitHub/r-geo-course/data&quot;) read.csv(&quot;oxr_vod.csv&quot;) write.csv(d, &quot;oxr_vod_copy.csv&quot;) Как видно, мы добавили дополнительную строчку кода, но сэкономили на длине двух других строк. При увеличении количества обращений к файлам польза домашней директории будет возрастать. При этом вы можете открывать и сохранять файлы в поддиректориях, наддиректориях и соседних директориях, используя синтаксис, стандартный для большинства операционных систем: # сохранить файл в поддиректорию data write.csv(d, &quot;data/oxr_vod_copy.csv&quot;) # сохранить файл в наддиректорию по отношению к текущей директории write.csv(d, &quot;../oxr_vod_copy.csv&quot;) # сохранить файл в директорию data, соседнюю по отношению к текущей директории write.csv(d, &quot;../data/oxr_vod_copy.csv&quot;) Если вы перенесли код и данные с другого компьютера (возможно, вы получили их от своего коллеги или скачали с репозитория данного пособия), необходимо заменить путь, указанный в функции setwd() на путь к каталогу, в который вы положили данные. Рабочая директория и местоположение скрипта могут не совпадать. Вы можете хранить их в разных местах. Однако рекомендуется держать их вместе, что облегчит передачу вашей программы вместе с данными другим пользователям. К сожалению, не существует надежного программного способа сказать среде выполнения R, что в качестве домашей директории следует использовать директорию в которой лежит сам скрипт (что, вообще говоря, было бы крайне удобно). Возможно, в будущем разработчики языка добавят такую полезную функцию. Однако, если для работы с R вы пользуетесь средой RStudio, задача может быть решена путем использования проектов. Подробнее читайте здесь. Диагностические функции В R существует ряд диагностических функций, которые позволяют узнавать информацию об объектах, переменных, а также текущих параметрах среды, оказывающих влияние на результаты выполнения программы. Эти функции полезны, когда необходимо понять, какого типа, размера и содержания данные хранятся в той или иной переменной. Нижеприведенный список функций не являются исчерпывающим, но охватывает наиболее употребильные функции: Функция Назначение class() Класс (тип данных или структура данных) объекта str() Компактное представление внутренней структуры объекта. names() Названия элементов объекта colnames() Названия колонок фрейма данных или матрицы rownames() Названия строк фрейма данных или матрицы mode() Режим хранения объекта. length() Размер (длина) объекта. dim() Измерение объекта. sessionInfo() Информация о текущей сессии R и подключенных пакетах. options() Получение и установка параметров среды. getwd() Текущая рабочая директория Получение справки Любая функция R содержит документированное описание ее параметров и правил использования. Справку можно получить несколькими способами: Найти интересующую вас функцию вручную на вкладке Packages, выбрав нужный пакет Воспользоваться строкой поиска на вкладке Help Ввести знак вопроса и название функции в консоли (будет искать только среди подключенных в настоящий момент пакетов): library(readxl) ?read_xlsx # равносильно вызову функции help(read_xlsx) Справка по функции Ввести двойной знак вопроса и название функции в консоли (будет искать по всем установленным пакетам, независимо от того, подключены ли они в настоящий момент): ??spsample Поиск по функциям Во многих пакетах есть также подробная документация с примерами использования функций в виде руководств и так называемых виньеток (vignettes), которые представляют из себя расширенные руководства (статьи) по использованию пакета. С документацией пакета можно ознакомиться, щелкнув на его названии на вкладке Packages и перейдя по ссылке User guides, package vignettes and other documentation: Документация пакета Комментарии Комментарии — это фрагменты текста программы, начинающиеся с символа #. Комментарии не воспринимаются как исполняемый код и служат для документирования программы. При выполнении программы содержимое комментария в зависимости от настроек среды может выводиться или не выводиться в консоль, однако их содержание никак не влияет на результаты выполнения программы. Всегда пишите комментарии, чтобы по прошествии времени можно было открыть файл и быстро восстановить в памяти логику программы и смысл отдельных операций. Комментарии особенно необходимы, если вашей программой будет пользоваться кто-то другой — без них будет трудно разобраться в программном коде. Действие комментария продолжается от символа # до конца строки. Соответственно, вы можете поставить данный символ в самом начале строки и тогда комментарий будет занимать всю строку. Комментарий также можно расположить справа от исполняемого кода, и тогда он будет занимать только часть строки. Прервать комментарий и написать справа от него исполняемый код нельзя Полнострочные комментарии часто используются для выделения разделов в программе и написания объемных пояснений. Часто в них вводят имитации разделительных линий с помощью символов дефиса (-) или подчеркивания (_), а заголовки набирают прописными буквами. Короткие комментарии справа от фрагментов кода обычно служат пояснением конкретных простых операций. Подобная логика употребления комментариев не является обязательной. Вы можете оформлять их на свое усмотрение. Главное, чтобы они выполняли свою основную функцию — пояснять смысл выполняемых действий. Например: # ОПЕРАЦИИ С ЧИСЛАМИ # --------------------------- # В данном разделе рассматриваются арифметические операции, такие как сложение, вычитание, деление, деление с остатком, взятие остатка и возведение в степень: a = 3 + 2 # Сложение b = 4 ^ 8 # Возведение в степень c = b %% a # Взятие остатка # Деление d = c / a # Умножение e = d * b Однако, усердствовать с комментированием каждой мелочи в программе, разумеется, не стоит. Со временем у вас выработается взвешенный подход к документированию программ и понимание того, какие ее фрагменты требуют пояснения, а какие самоочевидны. Для быстрой вставки комментария, обозначающего новый раздел программы, воспользуйтесь командой меню Code &gt; Insert Section или клавиатурным сочетанием Ctrl+Shift+R (Cmd+Shift+R для OS X) Стандарт оформления кода на R Очень важно сразу же приучить себя грамотно, структурированно и красиво оформлять код на языке R. Это существенно облегчит чтение и понимание ваших программ не только вами, но и другими пользователями и разработчиками. Помимо вышеуказанных рекомендаций по написанию комментариев существует также определенное количество хорошо зарекомендовавших себя и широко используемых практик оформления кода. Эти практики есть в каждом языке программирования и их можно найти в литературе (и в Интернете) в виде негласных сводов правил (style guides) Если вы не хотите быть белой вороной в мире R, вам будет полезно внимательно ознакомиться со стандартом оформления кода на R от компании Google, которая широко использует этот язык в своей работе. Стандарт оформления кода иногда также называют стилем программирования. Мы не будем использовать этот термин, поскольку под стилем программирования традиционно понимают фундаментальный подход (парадигму) к построению программ: процедурный, функциональный, логический, объектно-ориентированный стиль и некоторые другие. К числу негласных правил оформления кода на R можно отнести следующие: Последовательно используйте знак присвоения &lt;- или = на протяжении всей программы. Если вы начали использовать = – применяйте его на протяжении всей программы, не используя &lt;-. Традиционный подход предполагает использование &lt;-, однако все больше программистов использует знак = в своих программах, что делает R более похожим на другие языки программирования. Помните, что использование = официально не рекомендуется, поскольку существует много старого кода на R, который может ошибочно выполняться в сочетании с кодом, использующим =. Но вы, скорее всего, с такими проблемами не столкнетесь. Так что выбор за вами! После запятой всегда ставьте пробел, перед запятой – нет: # Правильно: a = c(1, 2, 3, 4) m = matrix(a, 2, 2) # Неправильно: a = c(1,2,3,4) a = c(1 ,2 ,3 ,4) a = c(1 , 2 , 3 , 4) m = matrix(a,2,2) m = matrix(a ,2 ,2) m = matrix(a , 2 , 2) Отделяйте любые бинарные операторы (такие как =, +, -, &lt;-, *) пробелами с двух сторон: a = sin(b + pi * 0.5) # правильно a=sin(b+pi*0.5) # неправильно Между названием функции и открывающей скобкой пробела быть не должно. То же самое касается обращения к элементам вектора, матрицы и т.п.: # Правильно: sin(b) a[2] # Неправильно: sin (b) a [2] В то же время, при вызове команд управления выполнением программы (условные операторы и циклы) перед и после скобок пробел должен стоять: # Правильно: if (a &gt; 0) { print(a) } i = 0 while (i &lt; a) { print(i) i = i + 1 } # Неправильно: if(a &gt; 0){ print(a) } i = 0 while(i &lt; a){ print(i) i = i + 1 } Зарезервированные слова В R существует небольшое количество зарезервированных слов, которые нельзя использовать в качестве имен переменных, функций и проч. Список этих слов можно получить, набрав в консоли ?Reserved. К ним относятся: Слово Назначение if Условный оператор ЕСЛИ else Условный оператор ИНАЧЕ repeat Цикл без внешнего условия while Цикл “пока верно условие, повторять” function Функция for Цикл “пройти по элементам последовательности” in Оператор вхождения в множество next Переход на новую итерацию цикла break Принудительный выход из цикла или условного оператора TRUE Логическое значение ИСТИНА FALSE Логическое значение ЛОЖЬ NULL Пустое значение Inf Бесконечность NaN Нечисловое значние NA Отсутствующее значение NA_integer_ Отсутствующее целое число NA_real_ Отсутствующее число с плавающей точкой NA_complex_ Отсутствующее комплексное число NA_character_ Отсутствующая строка Названия переменных В качестве названий переменных нельзя использовать заразервированные слова, а также не рекомендуется использовать названия общеупотребительных (диагностических) функций и констант. Также не следует давать переменным названия, совпадающие с широко распространенными функциями – например, котороткими функциями из пакета base, такими как t(), с() и т.д., так как это может привести к путанице в программе и даже ошибкам выполнения кода. Каждый раз, создавая переменную, спрашивайте себя, не совпадает ли ее название с названием одной из используемых вами функций. Названия специальных символов В R, как и во многих других языках программирования испльзуются различные специальные символы. Их смысл и значение мы узнаем по ходу изучения языка, а пока что выучите их названия, чтобы грамотно употреблять в своей речи Символ Название $ доллар # шарп &amp; амперсанд (решетка) / прямой слэш \\ обратный слэш | пайп (вертикальная черта) ^ циркумфлекс (крышечка) @ эт (собачка) ~ тильда '' одинарные кавычки &quot;&quot; двойные кавычки `` обратные кавычки Ссылка на пособие Если этот курс лекций оказался полезным для вас, и вы хотите процитировать его с списке литературы вашей работы, то ссылку можно оформить по следующей форме: Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "],
["data-types.html", "Глава 1 Типы данных, условия, ввод и вывод 1.1 Типы данных 1.2 Числа 1.3 Строки 1.4 Даты 1.5 Логические 1.6 Определение типа данных 1.7 Преобразование типов данных 1.8 Проверка типов данных и пустых значений 1.9 Ввод и вывод данных в консоли 1.10 Условный оператор 1.11 Оператор переключения 1.12 Краткий обзор 1.13 Контрольные вопросы и упражнения", " Глава 1 Типы данных, условия, ввод и вывод Программный код главы 1.1 Типы данных Тип данных — это класс данных, характеризуемый членами класса и операциями, которые могут быть к ним применены1. С помощью типов данных мы можем представлять привычные нам сущности, такие как числа, строки и т.д. В языке R существует 5 базовых типов данных: Название Тип данных complex комплексные числа character строки integer целые числа logical логические (булевы) numeric числа с плавающей точкой Помимо этого есть тип Date, который позволяет работать с датами. Рассмотрим использование каждого из перечисленных типов. 1.2 Числа Числа — основной тип данных в R. К ним относятся числа c плавающей точкой и целые числа. В терминологии R такие данные называются интервальными, поскольку к ним применимо понятие интервала на числовой прямой. Целые числа относятся к дискретным интервальным, а числа с плавающей точкой — к непрерывным интервальным. Числа можно складывать, вычитать и умножать: 2 + 3 ## [1] 5 2 - 3 ## [1] -1 2 * 3 ## [1] 6 Разделителем целой и дробной части является точка, а не запятая: 2.5 + 3.1 ## [1] 5.6 Существует также специальный оператор для возведения в степень. Для этого вы можете использовать или двойной знак умножения (**) или циркумфлекс (^), который в обиходе называют просто “крышечкой”: 2 ^ 3 ## [1] 8 2 ** 3 ## [1] 8 Результат деления по умолчанию имеет тип с плавающей точкой: 5 / 3 ## [1] 1.666667 5 / 2.5 ## [1] 2 Если вы хотите чтобы деление производилось целочисленным образом (без дробной части) необходимо использовать оператор %/%: 5 %/% 3 ## [1] 1 Остаток от деления можно получить с помощью оператора %%: 5 %% 3 ## [1] 2 Вышеприведенные арифметические операции являются бинарными, то есть требуют наличия двух чисел. Числа называются “операндами”. Отделять операнды от оператора пробелом или нет — дело вкуса. Однако рекомендуется все же отделять, так как это повышает читаемость кода. Следующие два выражения эквивалентны. Однако сравните простоту их восприятия: 5%/%3 ## [1] 1 5 %/% 3 ## [1] 1 Как правило, в настоящих программах числа в явном виде встречаются лишь иногда. Вместо этого для их обозначения используют переменные. В вышеприведенных выражениях мы неоднократно использовали число 3. Теперь представьте, что вы хотите проверить, каковы будут результаты, если вместо 3 использовать 4. Вам придется заменить все тройки на четверки. Если их много, то это будет утомительная работа, и вы наверняка что-то пропустите. Конечно, можно использовать поиск с автозаменой, но что если тройки надо заменить не везде? Одно и то же число может выполнять разные функции в разных выражениях. Чтобы избежать подобных проблем, в программе вводят переменные и присваивают им значения. Оператор присваивания значения выглядит как = a = 5 b = 3 Чтобы вывести значение переменной на экран, достаточно просто ввести его: a ## [1] 5 b ## [1] 3 Мы можем выполнить над переменными все те же операции что и над константами: a + b ## [1] 8 a - b ## [1] 2 a / b ## [1] 1.666667 a %/% b ## [1] 1 a %% b ## [1] 2 Легко меняем значение второй переменной с 3 на 4 и выполняем код заново. b = 4 a + b ## [1] 9 a - b ## [1] 1 a / b ## [1] 1.25 a %/% b ## [1] 1 a %% b ## [1] 1 Нам пришлось изменить значение переменной только один раз в момент ее создания, все последующие операции остались неизменны, но их результаты обновились! Новую переменную можно создать на основе значений существующих переменных: c = b d = a+c Посмотрим, что получилось: c ## [1] 4 d ## [1] 9 Вы можете комбинировать переменные и заданные явным образом константы: e = d + 2.5 e ## [1] 11.5 Противоположное по знаку число получается добавлением унарного оператора - перед константой или переменной: f = -2 f ## [1] -2 f = -e f ## [1] -11.5 Операция взятия остатка от деления бывает полезной, например, когда мы хотим выяснить, является число четным или нет. Для этого достаточно взять остаток от деления на 2. Если число является четным, остаток будет равен нулю. В данном случае c равно 4, d равно 9: c %% 2 ## [1] 0 d %% 2 ## [1] 1 1.2.1 Числовые функции Прежде чем мы перейдем к рассмотрению прочих типов данных и структур данных нам необходимо познакомиться с функциями, поскольку они встречаются буквально на каждом шагу. Понятие функции идентично тому, к чему мы привыкли в математике. Например, функция может называться Z, и принимать 2 аргумента: x и y. В этом случае она записывается как Z(x,y). Чтобы получить значение функции, необходимо подставить некоторые значения вместо x и y в скобках. Нас даже может не интересовать, как фактически устроена функция внутри, но важно понимать, что именно она должна вычислять. С созданием функций мы познакомимся позднее. Важнейшие примеры функций — математические. Это функции взятия корня sqrt(x), модуля abs(x), округления round(x, digits), натурального логарифма abs(x), тригонометрические функции sin(x), cos(x), tan(x), обратные к ним asin(y), acos(y), atan(y) и многие другие. Основные математические функции содержатся в пакете base, который по умолчанию доступен в среде R и не требует подключения. В качестве аргумента функции можно использовать переменную, константу, а также выражения: sqrt(a) ## [1] 2.236068 sin(a) ## [1] -0.9589243 tan(1.5) ## [1] 14.10142 abs(a + b - 2.5) ## [1] 6.5 Вы также можете легко вкладывать функции одна в одну, если результат вычисления одной функции нужно подставить в другую: sin(sqrt(a)) ## [1] 0.7867491 sqrt(sin(a) + 2) ## [1] 1.020331 Также как и с арифметическими выражениями, результат вычисления функции можно записать в переменную: b = sin(sqrt(a)) b ## [1] 0.7867491 Если переменной b ранее было присвоено другое значение, оно перезапишется. Вы также можете записать в переменную результат операции, выполненной над ней же. Например, если вы не уверены, что a — неотрицательное число, а вам это необходимо в дальнейших расчетах, вы можете применить к нему операцию взятия модуля: b = sin(a) b ## [1] -0.9589243 b = abs(b) b ## [1] 0.9589243 1.3 Строки Строки — также еще один важнейший тип данных. Строки состоят из символов. Чтобы создать строковую переменную, необходимо заключить текст строки в кавычки: s = &quot;В историю трудно войти, но легко вляпаться (М.Жванецкий)&quot; s ## [1] &quot;В историю трудно войти, но легко вляпаться (М.Жванецкий)&quot; Длину строки в символах можно узнать с помощью функции nchar() nchar(s) ## [1] 56 Строки можно складывать так же как и числа. Эта операция называется конкатенацией. В результате конкатенации строки состыковываются друг с другом и получается одна строка. В отличие от чисел, конкатенация производится не оператором +, а специальной функцией paste(). Состыковываемые строки нужно перечислить через запятую, их число может быть произвольно s1 = &quot;В историю трудно войти,&quot; s2 = &quot;но легко вляпаться&quot; s3 = &quot;(М.Жванецкий)&quot; Посмотрим содержимое подстрок: s1 ## [1] &quot;В историю трудно войти,&quot; s2 ## [1] &quot;но легко вляпаться&quot; s3 ## [1] &quot;(М.Жванецкий)&quot; А теперь объединим их в одну: s = paste(s1, s2) s ## [1] &quot;В историю трудно войти, но легко вляпаться&quot; s = paste(s1, s2, s3) s ## [1] &quot;В историю трудно войти, но легко вляпаться (М.Жванецкий)&quot; Настоящая сила конкатенации проявляется когда вам необходимо объединить в одной строке некоторое текстовое описание (заранее известное) и значения переменных, которые у вас вычисляются в программе (заранее неизвестные). Предположим, вы нашли в программе что максимальная численность населения в Детройте пришлась на 1950 год и составила 1850 тыс. человек. Найденный год записан у вас в переменную year, а население в переменную pop. Вы их значения пока что не знаете, они вычислены по табличным данным в программе. Как вывести эту информацию на экран “человеческим”&quot; образом? Для этого нужно использовать конкатенацию строк. Условно запишем значения переменных, как будто мы их знаем year = 1950 pop = 1850 s1 = &quot;Максимальная численность населения в Детройте пришлась на&quot; s2 = &quot;год и составила&quot; s3 = &quot;тыс. чел&quot; s = paste(s1, year, s2, pop, s3) s ## [1] &quot;Максимальная численность населения в Детройте пришлась на 1950 год и составила 1850 тыс. чел&quot; Обратите внимание на то что мы конкатенировали строки с числами. Конвертация типов осуществилась автоматически. Помимо этого, функция сама вставила пробелы между строками. 1.4 Даты Даты являются необходимыми при работе с временными данными. В географическом анализе подобные задачи возникают сплошь и рядом. Точность указания времени может быть самой различной. От года до долей секунды. Чаще всего используются даты, указанные с точностью до дня. Для создания даты используется функция as.Date(). В данном случае точка — это лишь часть названия функции, а не какой-то особый оператор. В качестве аргумента функции необходимо задать дату, записанную в виде строки. Запишем дату рождения автора (можете заменить ее на свою): birth = as.Date(&#39;1986/02/18&#39;) birth ## [1] &quot;1986-02-18&quot; Сегодняшнюю дату вы можете узнать с помощью специальной функции Sys.Date(): current = Sys.Date() current ## [1] &quot;2018-09-04&quot; Даты также можно складывать и вычитать. В зависимости от дискретности данных, вы получите результат в часах, днях, годах и т.д. Например, узнать продолжительность жизни в днях можно так: livedays = current - birth livedays ## Time difference of 11886 days Вы также можете прибавить к текущей дате некоторое значение. Например, необходимо узнать, какая дата будет через 40 дней: current + 40 ## [1] &quot;2018-10-14&quot; 1.5 Логические Логические переменные возникают там, где нужно проверить условие. Переменная логического типа может принимать значение TRUE (истина) или FALSE (ложь). Для их обозначения также возможны более компактные константы T и F соответственно. Следующие операторы приводят к возникновению логических переменных: РАВНО (==) — проверка равенства операндов НЕ РАВНО (!=) — проверка неравенства операндов МЕНЬШЕ (&lt;) — первый аргумент меньше второго МЕНЬШЕ ИЛИ РАВНО (&lt;=) — первый аргумент меньше или равен второму БОЛЬШЕ (&gt;) — первый аргумент больше второго БОЛЬШЕ ИЛИ РАВНО (&gt;=) — первый аргумент больше или равен второму Посмотрим, как они работают: a = 1 b = 2 a == b ## [1] FALSE a != b ## [1] TRUE a &gt; b ## [1] FALSE a &lt; b ## [1] TRUE Если необходимо проверить несколько условий одновременно, их можно комбинировать с помощью логических операторов. Наиболее популярные среди них: И (&amp;&amp;) - проверка истинности обоих условий ИЛИ (||) - проверка истинности хотя бы одного из условий НЕ (!) - отрицание операнда (истина меняется на ложь, ложь на истину) c=3 (b&gt;a) &amp;&amp; (c&gt;b) ## [1] TRUE (a&gt;b) &amp;&amp; (c&gt;b) ## [1] FALSE (a&gt;b) || (c&gt;b) ## [1] TRUE !(a&gt;b) ## [1] TRUE Более подробно работу с логическими переменными мы разберем далее при знакомстве с условным оператором if. 1.6 Определение типа данных Определение типа данных осуществляется с помощью функции class() (см. раздел Диагностические функции во Введении) class(1) ## [1] &quot;numeric&quot; class(0.5) ## [1] &quot;numeric&quot; class(1 + 2i) ## [1] &quot;complex&quot; class(&quot;sample&quot;) ## [1] &quot;character&quot; class(TRUE) ## [1] &quot;logical&quot; class(as.Date(&#39;1986-02-18&#39;)) ## [1] &quot;Date&quot; В вышеприведенном примере видно, что R по умолчанию “повышает” ранг целочисленных данных до более общего типа чисел с плавающей точкой, тем самым закладываясь на возможность точного деления без остатка. Если вы хотите, чтобы данные в явном виде интерпретировались как целочисленные, их нужно принудительно привести к этому типу. Операторы преобразования типов рассмотрены ниже. 1.7 Преобразование типов данных Преобразование типов данных осуществляется с помощью функций семейства as(d, type), где d — это входная переменная, а type — название типа данных, к которому эти данные надо преобразовать (см. таблицу в начале главы). Несколько примеров: k = 1 print(k) ## [1] 1 class(k) ## [1] &quot;numeric&quot; l = as(k, &quot;integer&quot;) print(l) ## [1] 1 class(l) ## [1] &quot;integer&quot; m = as(l, &quot;character&quot;) print(m) ## [1] &quot;1&quot; class(m) ## [1] &quot;character&quot; n = as(m, &quot;numeric&quot;) print(n) ## [1] 1 class(n) ## [1] &quot;numeric&quot; Для функции as() существуют обертки (wrappers), которые позволяют записывать такие преобразования более компактно и выглядят как as.&lt;dataype&gt;(d), где datatype — название типа данных: k = 1 l = as.integer(k) print(l) ## [1] 1 class(l) ## [1] &quot;integer&quot; m = as.character(l) print(m) ## [1] &quot;1&quot; class(m) ## [1] &quot;character&quot; n = as.numeric(m) print(n) ## [1] 1 class(n) ## [1] &quot;numeric&quot; d = as.Date(&#39;1986-02-18&#39;) print(d) ## [1] &quot;1986-02-18&quot; class(d) ## [1] &quot;Date&quot; Если преобразовать число c плавающей точкой до целого, то дробная часть будет отброшена: as.integer(2.7) ## [1] 2 После преобразования типа данных, разумеется, к переменной будут применимы только те функции, которые определены для данного типа данных: a = 2.5 b = as.character(a) b + 2 ## Error in b + 2: нечисловой аргумент для бинарного оператора nchar(b) ## [1] 3 1.8 Проверка типов данных и пустых значений Для проверки типа данных можно использовать функции семейства is.&lt;datatype&gt;: is.integer(2.7) ## [1] FALSE is.numeric(2.7) ## [1] TRUE is.character(&#39;Привет!&#39;) ## [1] TRUE Особое значение имеют функции проверки пустых переменных (имеющих значение NA - not available), которые могут получаться в результате несовместимых преобразований или соответствовать пропускам в исходных данных: as.integer(&#39;Привет!&#39;) ## [1] NA is.na(as.integer(&#39;Привет!&#39;)) ## [1] TRUE 1.9 Ввод и вывод данных в консоли Для ввода данных через консоль можно воспользоваться функцией readline(), которая будет ожидать пользовательский ввод и нажатие клавиши Enter, после чего вернет введенные данные в виде строки. Предположим, пользователь вызывает эту функцию и вводит с клавиатуры 1024: a = readline() Выведем результат на экран: a ## [1] &quot;1024&quot; Функция readline() всегда возвращает строку, поэтому если вы ожидаете ввод числа, полученное значение необходимо явным образом преобразовать к числовому типу. Для вывода данных в консоль можно воспользоваться тремя способами: Просто напечатать название переменной с новой строки (не работает при запуске программы командой Source) Вызвать функцию print() Вызвать функцию cat() Заключить выражение в круглые скобки () Первый способ мы уже регулярно использовали ранее в настоящей главе. Следует обратить внимание на то, что он хорош для отладки программы, но выглядит некрасиво в рабочих программах, поскольку просто печатая название переменной с новой строки вы как бы явно не говорите о том, что хотите вывести ее значение в консоль, а лишь подразумеваете это. Более того, если скрипт запускается командой Source, данный метод вывода переменной просто не сработает, интерпретатор его проигнорирует. Поэтому после отладки следует убрать из программы все лишние выводы в консоль, а оставшиеся (действительно нужные) оформить с помощью функций print() или cat(). Функция print() работает точно так же, как и просто название переменной с новой строки, отличаясь лишь двумя особенностями: print() явным образом говорит о том, что вы хотите вывести в консоль некую информацию print() работает при любых методах запуска программы, в том числе методом Source. Например: a = 1024 a ## [1] 1024 print(a) ## [1] 1024 b = &quot;Fourty winks in progress&quot; b ## [1] &quot;Fourty winks in progress&quot; print(b) ## [1] &quot;Fourty winks in progress&quot; print(paste(&quot;2 в степени 10 равно&quot;, 2^10)) ## [1] &quot;2 в степени 10 равно 1024&quot; print(paste(&quot;Сегодняшняя дата - &quot;, Sys.Date())) ## [1] &quot;Сегодняшняя дата - 2018-09-04&quot; Функция cat() отличается от print() следующими особенностями: cat() выводит значение переменной, и не печатает ее измерения и внешние атрибуты типа двойных кавычек вокруг строки. Это означает, что cat() можно использовать и для записи данных в файл (на практике этим мало кто пользуется, но знать такую возможность надо). cat() принимает множество аргументов и может осуществлять конкатенацию строк аналогично функции paste() cat() не возвращает никакого значений, в то время как print() возвращает значение, переданное ей в качестве аргумента. cat() можно использовать только для атомарных типов данных. Для классов (таких как Date) она будет выводит содержимое объекта, которое может не совпадать с тем, что пользователь ожидает вывести Например: cat(a) ## 1024 cat(b) ## Fourty winks in progress cat(&quot;2 в степени 10 равно&quot;, 2^10) ## 2 в степени 10 равно 1024 cat(&quot;Сегодняшнаяя дата -&quot;, Sys.Date()) ## Сегодняшнаяя дата - 17778 Можно видеть, что в последнем случае cat() напечатала отнюдь не дату в ее привычном представлении, а некое число, которое является внутренним представлением даты в типе данных Date. Такие типы данных являются классами объектов в R, и у них есть своя функция print(), которая и выдает содержимое объекта в виде, который ожидается пользователем. Поэтому пользоваться функцией cat() надо с некоторой осторожностью. Заключительная возможность — вывод с помощью заключения выражения в круглые скобки — очень удобна на стадии отладки программы. При этом переменная, которая создается в выражении, остается доступной в программе: (a = rnorm(5)) # сгенерируем 5 случайных чисел, запишем их в переменную a и выведем на экран ## [1] 0.4988179 1.4729426 -1.1708522 1.4483193 1.5375462 (b = 2 * a) # переменная a доступна, ее можно использовать и далее для вычислений ## [1] 0.9976358 2.9458852 -2.3417045 2.8966386 3.0750924 1.10 Условный оператор Проверка условий позволяет осуществлять так называемое ветвление в программе. Ветвление означает, что при определенных условиях (значениях переменных) будет выполнен один программный код, а при других условиях — другой. В R для проверки условий используется условный оператор if — else if — else следующего вида: if (condition) { statement1 } else if (condition) { statement2 } else { statement3 } Сначала проверяется условие в выражении if (condition), и если оно истинно, то выполнится вложенный в фигурные скобки программный код statement1, после чего оставшиеся условия не будут проверяться. Если первое условие ложно, программа перейдет к проверке следующего условия else if (condition). Далее, если оно истинно, то выполнится вложенный код statement2, если нет — проверка переключится на следующее условие и так далее. Заключительный код statement3, следующий за словом else, выполнится только если ложными окажутся все предыдущие условия. Конструкций else if может быть произвольное количество, конструкции if и else могут встречаться в условном операторе только один раз, в начале и конце соответственно. При этом условный оператор может состоять только из конструкции if, а else if и else не являются обязательными. Например, сгенерируем случайное число, округлим его до одного знака после запятой и проверим относительно нуля: (a = round(rnorm(1), 1)) ## [1] 1.3 if (a &lt; 0){ cat(&#39;Получилось отрицательное число!&#39;) } else if (a &gt; 0) { cat(&#39;Получилось положительное число!&#39;) } else { cat(&#39;Получился нуль!&#39;) } ## Получилось положительное число! Условия можно использовать, в частности, для того чтобы обрабатывать пользовательский ввод в программе. Например, охарактеризуем положение точки относительно Полярного круга: cat(&#39;Введите широту вашей точки:&#39;) phi = as.numeric(readline()) Пользователь вводит 68, а мы оцениваем результат: if (!is.na(phi)) { # проверяем, является ли введенное значение числом if (abs(phi) &gt;= 66.562 &amp; abs(phi) &lt;= 90) { # выполняем проверку на заполярность cat(&#39;Точка находится в Заполярье&#39;) } else { cat(&#39;Точка не находится в Заполярье&#39;) } } else { cat(&#39;Необходимо ввести число!&#39;) # оповещаем о некорректном вводе } ## Точка находится в Заполярье 1.11 Оператор переключения Оператор переключения (switch) является удобной заменой условному оператору в тех случаях, когда надо вычислить значение переменной в зависимости от значения другой переменной, которая может принимать ограниченное (заранее известное) число значений. Например: cat(&#39;Введите название федерального округа:&#39;) name = readline() Пользователь вводит: Приволжский # Определим центр в зависимости от названия: capital = switch(name, &#39;Центральный&#39; = &#39;Москва&#39;, &#39;Северо-Западный&#39; = &#39;Санкт-Петербург&#39;, &#39;Южный&#39; = &#39;Ростов-на-Дону&#39;, &#39;Северо-Кавказский&#39; = &#39;Пятигорск&#39;, &#39;Приволжский&#39; = &#39;Нижний Новгород&#39;, &#39;Уральский&#39; = &#39;Екатеринбург&#39;, &#39;Сибирский&#39; = &#39;Новосибирск&#39;, &#39;Дальневосточный&#39; = &#39;Хабаровск&#39;) print(capital) ## [1] &quot;Нижний Новгород&quot; 1.12 Краткий обзор knitr::include_url(&#39;https://github.com/tsamsonov/r-geo-course/blob/master/slides/01-Basics_slides.html&#39;) 1.13 Контрольные вопросы и упражнения 1.13.1 Вопросы Какие типы данных поддерживаются в R? Каковы их англоязычные наименования? Что такое переменная? Какой оператор используется для записи значения в переменную? С помощью какой функции можно узнать тип переменной? С помощью какого семейства функций можно преобразовывать типы переменных? Можно ли использовать ранее созданное имя переменной для хранения новых данных другого типа? Можно ли записать в переменную результат выполнения выражения, в котором она сама же и участвует? Какая функция позволяет прочитать пользовательский ввод с клавиатуры в консоли? Какой тип данных будет иметь возвращаемое значение? Какую функцию можно использовать для вывода значения переменной в консоль? Чем отличается использование этой функции от случая, когда вы просто пишете название переменной в строке программы? Какой символ является разделителем целой и дробной части при записи чисел с плавающей точкой? Что такое операторы и операнды? Приведите примеры бинарных и унарных операторов. Какое значение будет имет результат деления на ноль? Какие функции выполняют операторы %%, %/%, ^, **? Как проверить, является ли число четным? Как определить количество символов в строке? Как называется операция состыковки нескольких строк и с помощью какой функции она выполняется? Как добиться того, чтобы при этом не добавлялись пробелы между строками? С помощью какой функции можно создать дату из строки? Как извлечь из даты год? Месяц? День? Какая функция позволяет получить дату сегодняшнего дня? Можно ли складывать даты и числа? Если да, то в каких единицах измерения будет выражен результат? Какова краткая форма записи логических значений TRUE и FALSE? Каким числам соответствуют логические значения TRUE и FALSE? Сколько операндов должно быть верно, чтобы оператор логического И (&amp;&amp;) принял значение TRUE? Что можно сказать в этом отношении об операторе ИЛИ (||)? Можно ли применять арифметические операции к логическим переменным? Что произойдет, если прибавить или вычесть из числа a значение TRUE? А если заменить TRUE на FALSE? Что такое условный оператор и для каких сценариев обработки данных необходимы условные операторы? Перечислите ключевые слова, которые могут быть использованы для организации условных операторов При каких сценариях целесообразно использовать оператор переключения? 1.13.2 Упражнения Запишите условие неравенства чисел a и b, не используя оператор !=. Напишите программу, которая проверяет, является ли введенное целое число четным или нечетным, предварительно проверяя, является ли пользовательский ввод числом. Известны координаты населенного пункта А (x1, y1), а также азимут (дирекционный угол, если быть точнее) D и расстояние L до населенного пункта B. Определите координаты населенного пункта B (x2, y2). Используйте аналогичные названия переменных в своей работе. Функция atan2() позволяет найти математический азимут (полярный угол), если известны координаты вектора между двумя точками. Используя эту функцию, напишите программу, которая вычисляет географический азимут между точками А (x1, y1) и B (x2, y2). Математический азимут отсчитывается от направления на восток против часовой стрелки. Географический азимут отсчитывается от направления на север по часовой стрелке). Напишите программу, которая считывает из консоли введенную пользователем строку и выводит в консоль количество символов в этой строке. Вывод оформите следующим образом: &quot;Длина введенной строки равняется ... символам&quot;, где вместо многоточия стоит вычисленная длина. Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 ISO/IEC/IEEE 24765-2010 Systems and software engineering — Vocabulary↩ "],
["data-structures.html", "Глава 2 Структуры данных и циклы 2.1 Векторы 2.2 Матрицы 2.3 Массивы 2.4 Фреймы данных 2.5 Списки 2.6 Факторы 2.7 Векторизованный условный оператор 2.8 Циклы 2.9 Контрольные вопросы и задачи", " Глава 2 Структуры данных и циклы Программный код главы Структура данных — это программная единица, позволяющая хранить и обрабатывать множество однотипных и/или логически связанных данных. Структуры данных также являются типами данных, но не простыми, а составными. Поэтому обычно, когда говорят “тип данных”, подразумевают именно простые типы данных, рассмотренные в предыдущей главе. В R общеупотребительны следующие структуры данных: векторы, матрицы, массивы, фреймы данных, списки и факторы. Последний тип данных не всегда относят к структурам, хотя это логично, поскольку факторы построены по принципу ассоциативных массивов. 2.1 Векторы Вектор представляет собой упорядоченную последовательность объектов одного типа. Вектор может состоять только из чисел, только из строк, только из дат или только из логических значений и т.д. Числовой вектор легко представить себе в виде набора цифр, выстроенных в ряд и пронумерованных согласно порядку их расстановки. Вектор является простейшей и одновременно базовой структурой данных в R. Понимание принципов работы с векторами необходимо для дальнейшего знакомства с более сложными структурами данных, такими как матрицы, массивы, фреймы данных, тибблы, списки и факторы. 2.1.1 Создание вектора Существует множество способов создания векторов. Среди них наиболее употребительны: Явное перечисление элементов Создание пустого вектора (“болванки”), состоящего из заданного числа элементов Генерация последовательности значений Для создания вектора путем перечисления элементов используется функция c(): # вектор из строк — цвета некоторых веток Московского метро colors = c(&quot;Красная&quot;, &quot;Зеленая&quot;, &quot;Синяя&quot;, &quot;Коричневая&quot;, &quot;Оранжевая&quot;) colors ## [1] &quot;Красная&quot; &quot;Зеленая&quot; &quot;Синяя&quot; &quot;Коричневая&quot; &quot;Оранжевая&quot; # вектор из чисел — длина веток в километрах (в той же последовательности) lengths = c(28, 40, 45, 19, 38) lengths ## [1] 28 40 45 19 38 # вектор из булевых переменных — наличие открытых наземных участков (в той же последовательности) opens = c(FALSE, TRUE, TRUE, FALSE, FALSE) opens ## [1] FALSE TRUE TRUE FALSE FALSE Внимание: не используйте латинскую букву ‘c’ в качестве названия переменной! Это приведет к конфликту названия встроенной функции c() и определенной вами переменной Помимо этого, распространены сценарии, когда вам нужно создать вектор, но заполнять его значениями вы будете по ходу выполнения программы — скажем, при последовательной обработке строк таблицы. В этом случае вам известно только предполагаемое количество элементов вектора и их тип. Здесь лучше всего подойдет создание пустого вектора, которое выполняется функцией vector(). Функция принимает 2 параметра: mode отвечает за тип данных и может принимать значения равные &quot;logical&quot;, &quot;integer&quot;, &quot;numeric&quot; (или &quot;double&quot;), &quot;complex&quot;, &quot;character&quot; и &quot;raw&quot; length отвечает за количество элементов Например: # Вектор из 5 элементов, который предполагается заполнить целыми числами intvalues = vector(mode = &quot;integer&quot;, length = 5) intvalues # по умолчанию заполнен нулями ## [1] 0 0 0 0 0 # Вектор из 10 элементов, который предполагается заполнить символьными данными (строками) charvalues = vector(&quot;character&quot;, 10) charvalues # по умолчанию заполнен пустыми строками ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Обратите внимание на то, что в первом случае подстановка параметров произведена в виде параметр = значение, а во втором указаны только значения. В данном примере оба способа эквивалентны. Однако первый способ безопаснее и понятнее. Если вы указываете только значения параметров, нужно помнить, что интерпретатор будет подставлять их именно в том порядке, в котором они перечислены в описании функции. Описание функции можно посмотреть, набрав ее название в консоли ее название со знаком вопроса в качестве префикса. Например, для вышеуказанной функции надо набрать ?vector Наконец, третий распространенный способ создания векторов — это генерация последовательности. Чтобы сформировать вектор из натуральных чисел от M до N, можно воспользоваться специальной конструкцией: M:N: index = 1:5 # эквивалентно c(1,2,3,4,5) index ## [1] 1 2 3 4 5 index = 2:4 # эквивалентно c(2,3,4) index ## [1] 2 3 4 Существует и более общий способ создания последовательности — функция seq(), которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом: seq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы ## [1] 1 3 5 7 9 11 13 15 17 19 seq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится) ## [1] 2 5 8 11 14 17 20 seq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2 ## [1] 20 18 16 14 12 10 8 6 4 2 Как видно, параметры функции seq() можно комбинировать различными способами и указывать в произвольном порядке (при условии, что вы используете полную форму (параметр = значение). Главное, чтобы их совокупность однозначно описывала последовательность. Хотя, скажем, последний пример убывающей последовательности нельзя признать удачным с точки зрения наглядности. Аналогичным образом можно создавать последовательности дат: seq(from = as.Date(&#39;2016/09/01&#39;), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года ## [1] &quot;2016-09-01&quot; &quot;2016-09-02&quot; &quot;2016-09-03&quot; &quot;2016-09-04&quot; &quot;2016-09-05&quot; ## [6] &quot;2016-09-06&quot; &quot;2016-09-07&quot; seq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня ## [1] &quot;2018-09-04&quot; &quot;2018-09-11&quot; &quot;2018-09-18&quot; &quot;2018-09-25&quot; &quot;2018-10-02&quot; 2.1.2 Работа с элементами вектора К отдельным элементам вектора можно обращаться по их индексам: colors[1] # первый элемент вектора ## [1] &quot;Красная&quot; colors[3] # третий элемент ## [1] &quot;Синяя&quot; ВНИМАНИЕ: элементы векторов и других структур данных в языке R индексируются от 1 до N, где N — это длина вектора. Это отличает R от широко распространенных Си-подобных языков программирования (C, C++, C#, Java) и Python, в которых индексы элементов начинаются с 0 и заканчиваются N-1. Например, первый элемент списка (аналог вектора в R) на языке Python извлекался бы как colors[0]. За этим нужно внимательно следить, особенно если вы программируете на нескольких языках. Количество элементов (длину) вектора можно узнать с помощью функции length(): length(colors) ## [1] 5 Последний элемент вектора можно извлечь, если мы знаем его длину: n = length(colors) colors[n] ## [1] &quot;Оранжевая&quot; Последовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем: lengths[1:4] ## [1] 28 40 45 19 Индексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе: m = 1 n = 4 index = m:n lengths[index] ## [1] 28 40 45 19 Обратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например: index = c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка lengths[index] ## [1] 28 45 19 index = c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке lengths[index] ## [1] 38 28 19 40 2.1.3 Анализ и преобразования векторов К числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда — минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма: min(lengths) # минимум ## [1] 19 max(lengths) # максимум ## [1] 45 range(lengths) # размах вариации = максимум - минимум ## [1] 19 45 mean(lengths) # среднее арифметическое ## [1] 34 median(lengths) # медиана ## [1] 38 var(lengths) # дисперсия (по английски - вариация, variation) ## [1] 108.5 sd(lengths) # среднеквадратическое отклонение (standard deviation) ## [1] 10.41633 sum(lengths) # сумма ## [1] 170 Одной из мощнейших особенностей R является то что он не проводит различий между числами и векторами чисел. Поскольку R является матричным языком, каждое число представляется как вектор длиной 1 (или матрица \\(1х1\\)). Это означает, что любая математическая функция, применимая к числу, будет применима и к вектору: lengths * 1000 # преобразуем длины линий в метры ## [1] 28000 40000 45000 19000 38000 sqrt(lengths) # квадратный корень из длины каждого элемента ## [1] 5.291503 6.324555 6.708204 4.358899 6.164414 stations = c(20, 21, 22, 12, 24) # количество станций dens = stations / lengths # плотность станций по веткам метро = кол-во станций / длина dens ## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789 2.1.4 Поиск и сортировка элементов К важнейшим преобразованиям векторов относится их сортировка: lengths2 = sort(lengths) # сортировка по возрастанию значений lengths2 # отсортированный вектор ## [1] 19 28 38 40 45 lengths # сравним с исходным ## [1] 28 40 45 19 38 lengths2 = sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing lengths2 # отсортированный вектор ## [1] 45 40 38 28 19 lengths # сравним с исходным ## [1] 28 40 45 19 38 Другая распространенная задача — это поиск индекса элемента по его значению. Например, вы хотите узнать, какая ветка Московского метро (среди рассматриваемых) является самой длинной. Вы, конечно, легко найдете ее длину с помощью функции max(lengths). Однако это не поможет вам узнать ее название, поскольку оно находится в другом векторе, и его индекс в массиве неизвестен. Поскольку векторы упорядочены одинаково, нам достаточно узнать, под каким индексом в массиве lengths располагается максимальный элемент, и затем извлечь цвет линии метро под тем же самым индексом. Дл поиска индекса элемента используется функция match(): l = max(lengths) # находим максимальное значение idx = match(l, lengths) # находим индекс элемента, равного l, в списке lengths color = colors[idx] # извлекаем цвет ветки метро color ## [1] &quot;Синяя&quot; Здесь непохо бы лишний раз потренироваться в конкатенации строк, чтобы вывести результат красиво! s = paste(color, &quot;ветка Московского метро — самая длинная. Ее протяженность составляет&quot;, l, &quot;км&quot;) s ## [1] &quot;Синяя ветка Московского метро — самая длинная. Ее протяженность составляет 45 км&quot; Ну и напоследок пример “матрешки”&quot; из функций — как найти название самой плотной линии одним выражением: colors[match(max(dens),dens)] ## [1] &quot;Красная&quot; 2.2 Матрицы Матрица — это обобщение понятия вектора на 2 измерения. С точки зрения анализа данных матрицы ближе к реальным данным, посколько каждая матрица по сути представляет собой таблицу со столбцами и строками. Однако матрица, как и вектор, может содержать только элементы одного типа (числовые, строковые, логические и т.д.). Позже мы познакомимся с фреймами данных, которые не обладают подобным ограничением. А пока рассмотрим, как работать с двумерными данными на примере матриц. Матрица, как правило, создается с помощью функции matrix, которая принимает 3 обязательных аргумента: вектор исходных значений, количество строк и количество столбцов: v = 1:12 # создадим вектор из натуральных чисел от 1 до 12 m = matrix(v, nrow = 3, ncol = 4) m ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 По умолчанию матрица заполняется данными вектора по столбцам, что можно видеть в выводе программы. Если вы хотите заполнить ее по строкам, необходимо указать параметр byrow = TRUE: m = matrix(v, nrow = 3, ncol = 4, byrow = TRUE) m ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Доступ к элементам матрицы осуществляется аналогично вектору, за исключением того что нужно указать положение ячейки в строке и столбце: m[2,4] # 2 строка, 4 толбец ## [1] 8 m[3,1] # 3 строка, 1 столбец ## [1] 9 Помимо этого, из матрицы можно легко извлечь одну строку или один столбец. Для этого достаточно указать только номер строки или столбца, а номер второго измерения пропустить до или после запятой. Результат является вектором: m[2,] # 2 строка ## [1] 5 6 7 8 m[,3] # 3 cтолбец ## [1] 3 7 11 К матрицам можно применять операции, аналогичные операциям над векторами: log(m) # натуральный логарифм ото всех элементов ## [,1] [,2] [,3] [,4] ## [1,] 0.000000 0.6931472 1.098612 1.386294 ## [2,] 1.609438 1.7917595 1.945910 2.079442 ## [3,] 2.197225 2.3025851 2.397895 2.484907 sum(m) # сумма всех элементов матрицы ## [1] 78 median(m) # медиана ## [1] 6.5 А вот сортировка матрицы приведет к тому что будет возвращен обычный вектор: sort(m) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 К матрицам также применимы специальные функции, известные из линейной алгебры, такие как транспонирование и вычисление определителя: t(m) # транспонированная матрица ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 m2=matrix(-3:3,nrow = 3, ncol = 3) ## Warning in matrix(-3:3, nrow = 3, ncol = 3): длина данных [7] не является ## множителем количества строк [3] m2 ## [,1] [,2] [,3] ## [1,] -3 0 3 ## [2,] -2 1 -3 ## [3,] -1 2 -2 det(m2) # определитель матрицы ## [1] -21 det(m) # ошибка! определитель вычисляется только для квадратных матриц ## Error in determinant.matrix(x, logarithm = TRUE, ...): &#39;x&#39; должен быть квадратной матрицей Матрицы также можно перемножать с помощью специального оператора %*%. При этом, как мы помним, число столбцов в первой матрице должно равняться числу строк во второй: m2 %*% m ## [,1] [,2] [,3] [,4] ## [1,] 24 24 24 24 ## [2,] -24 -28 -32 -36 ## [3,] -9 -10 -11 -12 m %*% m2 # ошибка! ## Error in m %*% m2: неподобные аргументы Функция match(), которую мы использовали для поиска элементов в векторе, не работает для матриц. Вместо этого необходимо использовать функцию which(). Если мы хотим найти в матрице m позицию числа \\(8\\), то вызов функции будет выглядеть так: which(m == 8, arr.ind = TRUE) ## row col ## [1,] 2 4 В данном случае видно, что результат возвращен в виде матрицы \\(1 \\times 2\\). Обратите внимание на то, что колонки матрицы имеют названия. Попробуем использовать найденные индексы, чтобы извлечь искомый элемент: indexes = which(m == 8, arr.ind = TRUE) row = indexes[1,1] col = indexes[1,2] m[row,col] ## [1] 8 Ура! Найденный элемент действительно равен \\(8\\). Еще один полезный способ создания матрицы — это собрать ее из нескольких векторов, объединив их по строкам. Для этого можно использовать функции cbind() и rbind(). На предыдущем занятии мы создали векторы с длиной и количеством станций на разных ветках метро. Можно объединить их в одну матрицу: lengths = c(28, 40, 45, 19, 38) stations = c(20, 21, 22, 12, 24) cbind(lengths, stations) # соединим вектора в качестве столбцов ## lengths stations ## [1,] 28 20 ## [2,] 40 21 ## [3,] 45 22 ## [4,] 19 12 ## [5,] 38 24 rbind(lengths, stations) # соединим вектора в качестве строк ## [,1] [,2] [,3] [,4] [,5] ## lengths 28 40 45 19 38 ## stations 20 21 22 12 24 Cтроки и столбцы матрицы можно использовать как векторы при выполнении арифметических операций: mm = cbind(lengths, stations) mm[,2]/mm[,1] # количество станций на 1 км пути ## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789 Результат можно присоединить к уже созданной матрице: dens = mm[,2]/mm[,1] mm=cbind(mm, dens) mm ## lengths stations dens ## [1,] 28 20 0.7142857 ## [2,] 40 21 0.5250000 ## [3,] 45 22 0.4888889 ## [4,] 19 12 0.6315789 ## [5,] 38 24 0.6315789 Содержимое матрицы можно просмотреть в более привычном табличном виде для этого откройте вкладку Environment и щелкните на строку с матрицей в разделе Data Матрицы, однако, не дотягивают по функциональности до представления таблиц, и, в общем-то, не предназначены для объединения разнородных данных в один набор (как мы это сделали). Если вы присоедините к матрице столбец с названиями веток метро, система не выдаст сообщение об ошибке, но преобразует матрицу в текстовую, так как текстовый тип данных способен представить любой другой тип данных: colors = c(&quot;Красная&quot;, &quot;Зеленая&quot;, &quot;Синяя&quot;, &quot;Коричневая&quot;, &quot;Оранжевая&quot;) mm2=cbind(mm,colors) mm2 # обратите внимание на то, что вокруг чисел добавились кавычки ## lengths stations dens colors ## [1,] &quot;28&quot; &quot;20&quot; &quot;0.714285714285714&quot; &quot;Красная&quot; ## [2,] &quot;40&quot; &quot;21&quot; &quot;0.525&quot; &quot;Зеленая&quot; ## [3,] &quot;45&quot; &quot;22&quot; &quot;0.488888888888889&quot; &quot;Синяя&quot; ## [4,] &quot;19&quot; &quot;12&quot; &quot;0.631578947368421&quot; &quot;Коричневая&quot; ## [5,] &quot;38&quot; &quot;24&quot; &quot;0.631578947368421&quot; &quot;Оранжевая&quot; При попытке выполнить арифметическое выражение над прежде числовыми полями, вы получите сообщение об ошибке: mm2[,2]/mm2[,1] ## Error in mm2[, 2]/mm2[, 1]: нечисловой аргумент для бинарного оператора 2.3 Массивы Массивы (arrays) — это многомерные структуры данных, с колчеством измерений 3 и более. Трехмерный массив представляет собой куб однородных данных. Массивы возникают тогда, например, когда имеются временные данные, зафиксированные в неких географических локациях. При этом 2 измерения отвечают за местоположение, а третье измерение — за временной срез. 2.4 Фреймы данных Фреймы данных — это обобщение понятия матрицы на данные смешанных типов. Фреймы данных - наиболее распространенный формат представления табличных данных. Для краткости мы иногда будем называть их просто фреймами. Мы специально не используем для перевода слова data.frame термин ‘таблица’, поскольку таблица — это достаточно общая категория, которая описывает концептуальный способ упорядочивания данных. В том же языке R для представления таблиц могут быть использованы как минимум две структуры данных: фрейм данных (data.frame) и тиббл (tibble), доступный в соответствующем пакете. Мы не будем использовать тибблы в настоящем курсе, но после его освоения вы вполне сможете ознакомиться с ними самостоятельною Для создания фреймов данных используется функция data.frame(): df = data.frame(colors,lengths,stations) df # как мы видим, уже никаких кавычек вокруг чисел ## colors lengths stations ## 1 Красная 28 20 ## 2 Зеленая 40 21 ## 3 Синяя 45 22 ## 4 Коричневая 19 12 ## 5 Оранжевая 38 24 К фреймам также можно пристыковывать новые столбцы: df = cbind(df, dens) df ## colors lengths stations dens ## 1 Красная 28 20 0.7142857 ## 2 Зеленая 40 21 0.5250000 ## 3 Синяя 45 22 0.4888889 ## 4 Коричневая 19 12 0.6315789 ## 5 Оранжевая 38 24 0.6315789 Когда фрейм данных формируется посредством функции data.frame() и cbind(), названия столбцов берутся из названий векторов. Обратите внимание на то, что листинге выше столбцы имеют заголовки, а строки — номера. Как и прежде, к столбцам и строкам можно обращаться по индексам: df[2,2] ## [1] 40 df[,3] ## [1] 20 21 22 12 24 df[4,] ## colors lengths stations dens ## 4 Коричневая 19 12 0.6315789 Вы можете обращаться к отдельным столбцам фрейма данных по их названию, используя оператор $ (доллар): df$lengths ## [1] 28 40 45 19 38 df$stations ## [1] 20 21 22 12 24 Так же как и ранее, можно выполнять различные операции над столбцами: max(df$stations) ## [1] 24 df$lengths / df$stations ## [1] 1.400000 1.904762 2.045455 1.583333 1.583333 Названия столбцов можно получить с помощью функции colnames() colnames(df) ## [1] &quot;colors&quot; &quot;lengths&quot; &quot;stations&quot; &quot;dens&quot; Чтобы присоединить строку, сначала можно создать фрейм данных из одной строки: row = data.frame(&quot;Фиолетовая&quot;, 40.5, 22, 22/45) Далее нужно убедиться, что столбцы в этом мини-фрейме называются также как и в том фрейме, куда мы хотим присоединить строку. Для этого нужно перезаписать результат, возвращаемый функцией colnames(): colnames(row) = colnames(df) Обратите внимание на синтаксис вышеприведенного выражения. Когда функция возвращает результат, она обнаруживает свойство самого объекта, и мы можем его перезаписать. После того как столбцы приведены в соответствие, можно присоединить новую строку: df = rbind(df,row) Поскольку названия столбцов хранятся как вектор из строк, мы можем их переделать: colnames(df) = c(&quot;Цвет&quot;,&quot;Длина&quot;,&quot;Станции&quot;,&quot;Плотность&quot;) colnames(df) ## [1] &quot;Цвет&quot; &quot;Длина&quot; &quot;Станции&quot; &quot;Плотность&quot; Обратимся по новому названию столбца: df$Длина ## [1] 28.0 40.0 45.0 19.0 38.0 40.5 df ## Цвет Длина Станции Плотность ## 1 Красная 28.0 20 0.7142857 ## 2 Зеленая 40.0 21 0.5250000 ## 3 Синяя 45.0 22 0.4888889 ## 4 Коричневая 19.0 12 0.6315789 ## 5 Оранжевая 38.0 24 0.6315789 ## 6 Фиолетовая 40.5 22 0.4888889 2.5 Списки Список — это наиболее общий тип контейнера в R. Список отличается от вектора тем, что он может содержать набор объектов произвольного типа. В качестве элементов списка могут быть числа, строки, вектора, матрицы, фреймы данных — и все это в одном контейнере. Списки используются чтобы комбинировать разрозненную информацию. Результатом выполнения многих функций является список. Например, можно создать список из текстового описания фрейма данных, самого фрейма данных и обобщающей статистики по нему: d = &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; s = summary(df) # summary() выдает обобщающую статистику вектору, матрице или фрейму данных Сооружаем список из трех элементов: metrolist = list(d, df, s) metrolist ## [[1]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; ## ## [[2]] ## Цвет Длина Станции Плотность ## 1 Красная 28.0 20 0.7142857 ## 2 Зеленая 40.0 21 0.5250000 ## 3 Синяя 45.0 22 0.4888889 ## 4 Коричневая 19.0 12 0.6315789 ## 5 Оранжевая 38.0 24 0.6315789 ## 6 Фиолетовая 40.5 22 0.4888889 ## ## [[3]] ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Можно дать элементам списка осмысленные названия при создании: metrolist = list(desc = d, table = df, summary = s) metrolist ## $desc ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; ## ## $table ## Цвет Длина Станции Плотность ## 1 Красная 28.0 20 0.7142857 ## 2 Зеленая 40.0 21 0.5250000 ## 3 Синяя 45.0 22 0.4888889 ## 4 Коричневая 19.0 12 0.6315789 ## 5 Оранжевая 38.0 24 0.6315789 ## 6 Фиолетовая 40.5 22 0.4888889 ## ## $summary ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Теперь можно обратиться к элементу списка по его названию: metrolist$summary ## Цвет Длина Станции Плотность ## Зеленая :1 Min. :19.00 Min. :12.00 Min. :0.4889 ## Коричневая:1 1st Qu.:30.50 1st Qu.:20.25 1st Qu.:0.4979 ## Красная :1 Median :39.00 Median :21.50 Median :0.5783 ## Оранжевая :1 Mean :35.08 Mean :20.17 Mean :0.5800 ## Синяя :1 3rd Qu.:40.38 3rd Qu.:22.00 3rd Qu.:0.6316 ## Фиолетовая:1 Max. :45.00 Max. :24.00 Max. :0.7143 Поскольку summary сама является фреймом данных, из нее можно извлечь столбец: metrolist$summary[,3] ## ## &quot;Min. :12.00 &quot; &quot;1st Qu.:20.25 &quot; &quot;Median :21.50 &quot; &quot;Mean :20.17 &quot; ## ## &quot;3rd Qu.:22.00 &quot; &quot;Max. :24.00 &quot; К элементу списка можно также обратиться по его порядковому номеру или названию, заключив их в двойные квадратные скобки: metrolist[[1]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; metrolist[[&quot;desc&quot;]] ## [1] &quot;Этот фрейм данных содержит данные по 6 линиям Московского метро&quot; Использование двойных скобок отличает списки от векторов. 2.6 Факторы Факторы используются для представления качественных переменных. В отношении качественных переменных не определены арифметические операции: их сложение, вычитание, деление и умножение приводит к получению бессмысленных значений. К качественным переменным относятся номинльные и порядковые переменные. Примеры номинальных переменных: пол человека, тип климата. Примеры порядковых переменных - административный статус населенного пункта, сила землетрясения по шкале Рихтера. Фактор является надстройкой над вектором, и пожет быть как упорядоченным, так и неупорядоченным. # df$colors = as.factor(df$colors) # df 2.7 Векторизованный условный оператор Для векторов существует специальная форма векторизованного условного оператора – функция ifelse(), которая позволяет изменять значение каждого элемента вектора в зависимости от того, удовлетворяет ли оно заданному условию. Например, если нас интересует доля проживающих в 2.8 Циклы Цикл — это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В R циклы наиболее часто используются для пакетной обработки данных, ввода и вывода. Типичными примерами использования циклов являются чтение множества файлов входных данных, а также построение серий графиков и карт одного типа по различным данным. При этом обработка множества строк таблиц в R обычно организуется не средствами циклов, а средствами функций семейства lapply, о которых мы поговорим отдельно. Циклы обычно связаны с проходом по элементам списка/вектора либо с созданием такого списка/вектора. Поэтому они излагаются в настоящей главе. В R, как и во многих других языках программирования, существует несколько вариантов циклов. Первый вид циклов — это конструкция for с синтаксисом for (x in X) statement. Она означает, что: переменная x должна пробежать по всем элементам последовательности X. В качестве последовательности может выступать любой вектор или список. каждый раз, когда x будет присвоено значение очередного элемента из X, будет выполнено выражение statement, которое называют телом цикла. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности X. Выполнение тела цикла на каждом проходе называют итерацией. Например, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки: ## ЦИКЛЫ for (i in 1:10) print(i) ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Если тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки, иначе выполнится только первое выражение, а оставшиеся будут запущены один раз после выхода из цикла: for (i in 1:10) { a = factorial(i) # факториал i b = exp(i) # e в степени i print(a/b) # факториал растет быстрее экспоненты } ## [1] 0.3678794 ## [1] 0.2706706 ## [1] 0.2987224 ## [1] 0.4395753 ## [1] 0.8085536 ## [1] 1.784702 ## [1] 4.595885 ## [1] 13.52585 ## [1] 44.78295 ## [1] 164.7473 Другой вариант цикла организуется с помощью конструкции while, имеющей синтаксис while (condition) statement. Такая конструкция означает, что тело цикла будет выполняться, пока значение выражения condition (условия) равно TRUE. Как правило, в теле цикла обновляется некоторая переменная, которая участвует в проверке условия, и предполагается, что рано или поздно оно станет равным FALSE, что приведет к выходу из цикла. Например, вышеприведенный цикл, печатающий числа от 1 до 10, можно переписать на while следуюшим образом: i = 0 while(i &lt; 10) { i = i+1 print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Обратите внимание на то, что мы внутри цикла обновляем значение переменной i. Увеличение значения переменной цикла называется инкрементом, а уменьшение — декрементом Одной из самых распространенных ошибок программистов (особенно начинающих, но и професионалы ее не избегают) является забытая инструкция инкремента (или деккремента) переменной цикла, в результате чего цикл становится бесконечным. В этом плане конструкция for более надежна. 2.9 Контрольные вопросы и задачи 2.9.1 Вопросы Что такое вектор в языке R? Какие способы создания векторов существуют? Можно ли хранить в векторе данные разных типов? Как определить длину вектора? Как извлечь из вектора элемент по его индексу? Как извлечь из вектора множество элементов по их индексам? Как извлечь из вектора последний элемент? С помощью какой функции можно сгенерировать последовательность чисел или дат с заданным шагом? Как сгенерировать последовательность целых чисел с шагом 1, не прибегая к функциям? Можно ли применять к векторам арифметические операторы? Что будет результатом их выполнения? С помощью какой функции можно отсортировать вектор? Как изменить порядок сортировки на противоположный? С помощью какой функции можно найти индекс элемента вектора по его значению? Что вернет функция, если этот элемент встречается в векторе несколько раз? Что такое матрица, массив, фрейм данных и список? Чем отличаются эти структуры данных? Какие из рассмотренных в этой главе структур данных могут содержать элементы разного типа, а какие только один? Какая функция позволяет создать матрицу? По строкам или по столбцам заполняется матрица при использовании вектора как источника данных по умолчанию? Как извлечь элемент по его индексам из матрицы, массива, фрейма данных, списка? Как извлечь строку или столбец из матрицы или фрейма данных? С помощью какого специального символа можно обратиться к столбцу фрейма данных по его названию? Как получить или записать названия столбцов фрейма данных? Как получить или записать названия строк фрейма данных? Какая структура данных является результатом сортировки матрицы? Какая функция позволяет осуществить транспонирование матрицы? Какой оператор используется для умножения матриц? Каким критериям должны отвечать перемножаемые матрицы, чтобы эта операция была осуществима? Как добавить новый столбец в фрейм данных? Опишите несколько вариантов. Как добавить новую строку в фрейм данных? Что произойдет, если к целочисленной матрице прибавить столбец, заполненный строками? Какая функция позволяет находить индексы элементов матрицы или фрейма данных по их значениям? Что такое цикл и для каких сценариев обработки данных могут быть полезны циклы? Перечислите несколько способов организации циклов в R, необходимые ключевые слова и параметры. Что такое инкремент и декремент? Какое ключевое слово позволяет прервать цикл и выйти из него принудительно? Какое ключевое слово позволяет прекратить текущую итерацию цикла и перейти сразу к новой итерации? Являются ли необходимыми фигурные скобки в случае когда цикл или условный оператор содержит только одно выражение? Что говорит об этом стиль программирования на R? 2.9.2 Задачи Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "],
["tables.html", "Глава 3 Таблицы 3.1 Чтение таблиц 3.2 Просмотр таблицы 3.3 Работа со столбцами 3.4 Сортировка и фильтрация 3.5 Пропущенные значения 3.6 Преобразование типов и поиск ошибок 3.7 Сохранение таблиц 3.8 Правила подготовки таблиц для чтения в R 3.9 Контрольные вопросы и задачи", " Глава 3 Таблицы Программный код главы Необходимые пакеты: openxlsx, readxl, readr, xlsx, dplyr Таблица представляет собой один из способов структурирования данных. Большинство научных данных представляется именно в виде таблиц. В настоящем модуле рассмотрены базовые процедуры обработки таблиц, такие как чтение, сортировка, фильтрация, отбор столбцов (переменных), добавление и вычисление новых строк и столбцов, поиск и исправление ошибок в данных, запись таблиц в файл. Показано, как одни и те же процедуры могут быть реализованы стандартными средствами R и с помощью пакета dplyr. Напомним, что для представления таблиц в R используются фреймы данных. В рамках данной главы мы будем использовать оба понятия как взаимозаменяемые, предполагая, что речь идет о таблице, представленной в виде фрейма данных. 3.1 Чтение таблиц Существует множество файловых форматов представления табличных данных. Мы рассмотрим одни из наиболее распространенных — CSV и Microsoft Excel. 3.1.1 Таблицы CSV CSV (Comma-separated value) — общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу: Каждая строка в файле соответствует строке в таблице Ячейки отделяются друг от друга символом-разделителем. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов. Стандартным разделителем ячеек является запятая (,), а десятичным разделителем — точка (.). Однако это не является строгим правилом. Например, вот так выглядит таблица в формате CSV, с которой мы дальше будем работать: Год;Всего;Балтийское;Черное;Азовское;Каспийское;Карское;Белое;Прочие 1993;27,2;2,5;0,4;4,3;12,1;5,3;1,0;1,6 1994;24,6;2,3;0,4;3,2;11,0;5,0;0,9;1,8 1995;24,5;2,3;0,4;3,5;10,4;5,2;0,9;1,8 1996;22,4;2,2;0,3;3,1;9,8;4,7;0,8;1,5 1997;23,0;2,2;0,3;3,8;9,8;4,4;0,8;1,7 Видно, что первая строка в файле занята заголовками столбцов. Формат CSV этот момент не обговаривает, поэтому при чтении таблицы нужно явным образом указывать, что данные начинаются со второй строки, а первую строку следует интерепретировать как заголовочную. Также следует отметить, что в данном файле в качестве символа-разделителя ячеек используется точка с запятой (;), поскольку в русской локали запятая (,) зарезервирована под десятичный разделитель. Разделитель ячеек и десятичный разделитель также должны быть указаны при открытии файла, если они не соответствуют стандартным. Таблицы в формате CSV (Comma-Separated Values) можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета readr. Рассмотрим оба варианта. Для чтения таблиц с разделителем существует функция стандартной бибилиотеки read.table(). Ее основные параметры следующие: file — название файла sep — разделитель ячеек dec — десятичный разделитель header — содержится ли в первой строке заголовок — encoding — кодировка символов, в которой сохранен файл (чаще всего UTF-8 или CP1251) Стандартной кодировкой для представления текста в UNIX-подобных системах (Ubuntu, macOS и т.д.) является UTF-8 (Unicode), в русскоязычных версиях Windows — CP1251 (Windows-1251). Текстовый файл CSV, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в R вы видите вместо текста нечитаемые символы — кракозябры — то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Попробуйте поменять UTF-8 на CP1251 или наоборот. Если вы не знаете, что такое кодировка и Юникод, то вам сюда. Прочтем таблицу с данными Росстата по объему сброса сточных вод в бассейны некоторых морей России (в млн. м\\(^3\\)): # Чтение таблиц CSV tab = read.table(&quot;oxr_vod.csv&quot;, sep = &#39;;&#39;, dec = &#39;,&#39;, header = TRUE, encoding = &#39;UTF-8&#39;) str(tab) # Посмотрим на структуру таблицы ## &#39;data.frame&#39;: 22 obs. of 9 variables: ## $ Год : int 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ... ## $ Всего : num 27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ... ## $ Балтийское: num 2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ... ## $ Черное : num 0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ... ## $ Азовское : num 4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ... ## $ Каспийское: num 12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ... ## $ Карское : num 5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ... ## $ Белое : num 1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ... ## $ Прочие : num 1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ... Существуют также специальные функции для чтения таблиц CSV: read.csv() и read.csv2(). По сути они являются “обертками” (wrappers) функции read.table() и выполняют ее вызов с автоматической подстановкой параметров sep, dec и header. Обе функции по умолчанию предполагают, что в файле имеется заголовок. read.csv() удобна для чтения таблиц с десятичной точкой и запятой-разделителем, а read.csv2() — для таблиц с десятичной запятой и точкой-с-запятой в качестве разделителя. Используем для чтения read.csv2(): tab = read.csv2(&quot;oxr_vod.csv&quot;, encoding = &#39;UTF-8&#39;) str(tab) # Посмотрим на структуру таблицы ## &#39;data.frame&#39;: 22 obs. of 9 variables: ## $ Год : int 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ... ## $ Всего : num 27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ... ## $ Балтийское: num 2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ... ## $ Черное : num 0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ... ## $ Азовское : num 4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ... ## $ Каспийское: num 12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ... ## $ Карское : num 5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ... ## $ Белое : num 1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ... ## $ Прочие : num 1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ... Данная таблица не отличается от предыдущей, но ее чтение с помощью функции read.csv2() более компактно. Помимо стандартной библиотеки вы можете читать таблицы CSV (и другие текстовые форматы) с помощью пакета readr. Одним из его преимуществ является то, что он читает таблицы примерно в 10 раз быстрее стандартной библиотеки. Аналогично стандартной библиотеки можно воспользоваться функцией read_csv2(). Отличие заключается только в том, что данная функция возвращает объект типа tibble, который является расширением фрейма данных. Если рабочий процесс предполагает использование фреймов данных, небходимо преобразовать результат к данному типу: library(readr) tab = as.data.frame(read_csv2(&quot;oxr_vod.csv&quot;)) str(tab) # Посмотрим на структуру таблицы ## &#39;data.frame&#39;: 22 obs. of 9 variables: ## $ Год : int 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ... ## $ Всего : num 27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ... ## $ Балтийское: num 2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ... ## $ Черное : num 0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ... ## $ Азовское : num 4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ... ## $ Каспийское: num 12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ... ## $ Карское : num 5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ... ## $ Белое : num 1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ... ## $ Прочие : num 1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ... ## - attr(*, &quot;spec&quot;)=List of 2 ## ..$ cols :List of 9 ## .. ..$ Год : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Всего : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## .. ..$ Балтийское: list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## .. ..$ Черное : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## .. ..$ Азовское : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## .. ..$ Каспийское: list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## .. ..$ Карское : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## .. ..$ Белое : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## .. ..$ Прочие : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_double&quot; &quot;collector&quot; ## ..$ default: list() ## .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_guess&quot; &quot;collector&quot; ## ..- attr(*, &quot;class&quot;)= chr &quot;col_spec&quot; 3.1.2 Таблицы Microsoft Excel Чтение таблиц Microsoft Excel не входит в возможности стандартной библиотеки R. В то же время, для этих целей существует ряд пакетов, таких как xlsx, openxlsx и readxl. Пакет xlsx требует наличия установленной среды Java на компьютере, что несколько усложняет его использование. В нашей работе мы будем пользоваться пакетом readxl. Для чтения таблиц Excel с помощью этого пакета необходимо указать путь к файлу и номер листа: library(readxl) sewage = read_excel(&quot;sewage.xlsx&quot;, 1) str(sewage) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 97 obs. of 6 variables: ## $ X__1: chr &quot;Российская Федерация&quot; &quot;Центральный федеральный округ&quot; &quot;Белгородская область&quot; &quot;Брянская область&quot; ... ## $ 2005: num 17727 4341 11 89 155 ... ## $ 2010: num 16516 3761 77 78 129 ... ## $ 2011: num 15966 3613 72 75 126 ... ## $ 2012: num 15678 3651 71 71 124 ... ## $ 2013: num 15189 3570 71 68 120 ... 3.1.3 Типы данных столбцов Особого внимания при чтении таблиц заслуживает тема управления типами данных столбцов. В процессе чтения таблицы R будет пытаться привести каждый столбец к одному из базовых типов, рассмотренных в первой главе. Как правило, столбцы приводятся либо к числовому (numeric), либо к текстовому (character) типу. В то же время, в таблицах часто бывают пропущенные значения (нет данных), которые выражаются в виде пустых ячеек или специальных символов (например, -). Также могут быть опечатки и неверно заданные разделители десятичного разряда (например, запятая вместо точки). В этом контексте при чтении таблиц действуют следующие правила: По умолчанию типы данных столбцов определяются автоматически, если не задано иное. По умолчанию текстовые столбцы преобразуются функциями стандартной библиотки в факторы, а функциями из пакетов readr, openxlsx и readxl — остаются текстовыми столбцами. Если типы данных определяются автоматически, и в процессе чтения в текущем столбце обнаруживается хотя бы один нечисловой символ, столбец будет автоматически преобразован к текстовому типу. Если тип данных столбца задан пользователем как числовой, и в процессе чтения в нем обнаруживается хотя бы один нечисловой символ, импорт таблицы будет прерван и вы получите сообщение об ошибке. Управлять типами данных в фрейме данных гораздо проще на стадии чтения таблицы, чем уже после того, как она прочитана неправильно (см. раздел исправление ошибок в конце настоящей главы). Отсюда вытекают следующие рекомендации при чтении таблиц: Если вы пользуетесь стандартной библиотекой для чтения таблиц с текстовыми столбцами, запретите интерпретировать их как факторы, если это нежелательное поведение. Если вам известна структура таблицы, и вы не уверены в полноте и корректности ее наполнения, определите сразу при ее чтении типы столбцов, так вы поймете, все ли в порядке с данными. В качестве примера неправильно прочитанной таблицы приведем данные о типах землепользования на Сатинском учебном полигоне географического факультета МГУ: # ТИПЫ ДАННЫХ СТОЛБЦОВ tab2 = read.csv2(&quot;SatinoLanduse.csv&quot;, dec = &#39;.&#39;) str(tab2) # посмотрим, какова структура данных ## &#39;data.frame&#39;: 160 obs. of 6 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Type : Factor w/ 12 levels &quot;Выгоны&quot;,&quot;Вырубки&quot;,..: 11 1 1 9 5 1 5 12 9 10 ... ## $ Administration: Factor w/ 7 levels &quot;&quot;,&quot;РФ&quot;,&quot;Совьяковская администрация&quot;,..: 5 5 5 1 1 5 1 5 5 6 ... ## $ Comment : Factor w/ 35 levels &quot;&quot;,&quot;АО \\&quot;Родина\\&quot;&quot;,..: 30 1 1 1 1 1 1 3 2 1 ... ## $ Perimeter : num 2396 922 2181 3948 279 ... ## $ Area : Factor w/ 160 levels &quot;0.238070145845919&quot;,..: 73 49 121 100 63 72 88 128 99 24 ... Видно, что правильно прочитаны только три столбца: ID, хранящий идентификаторы, Type, хранящий тип землепользования, являющийся номинальной переменной, а также Perimeter, хранящий периметр участка. Текстовые столбцы Administration и Comment были также преобразованы в факторы, поскольку это стандартное поведение базовых функций R, хотя номинальными переменными по сути не являются. А последний столбец с площадью и вовсе не был прочитан правильно, так как содержит опечатки. Запретить интерепретировать строки как факторы можно с помощью параметра stringsAsFactors=FALSE: tab2 = read.csv2(&quot;SatinoLanduse.csv&quot;, dec = &#39;.&#39;, stringsAsFactors = FALSE) str(tab2) # посмотрим, какова структура данных ## &#39;data.frame&#39;: 160 obs. of 6 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Type : chr &quot;Территории населенных пунктов&quot; &quot;Выгоны&quot; &quot;Выгоны&quot; &quot;Пашни&quot; ... ## $ Administration: chr &quot;Совьяковская сельская администрация&quot; &quot;Совьяковская сельская администрация&quot; &quot;Совьяковская сельская администрация&quot; &quot;&quot; ... ## $ Comment : chr &quot;Село Беницы&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Perimeter : num 2396 922 2181 3948 279 ... ## $ Area : chr &quot;286159.158855028570000&quot; &quot;21651.963989321295000&quot; &quot;56826.463220403260000&quot; &quot;450293.758854912190000&quot; ... Функции из пакета readr делают это по умолчанию: tab2 = as.data.frame(read_csv2(&quot;SatinoLanduse.csv&quot;)) str(tab2) # посмотрим, какова структура данных ## &#39;data.frame&#39;: 160 obs. of 6 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Type : chr &quot;Территории населенных пунктов&quot; &quot;Выгоны&quot; &quot;Выгоны&quot; &quot;Пашни&quot; ... ## $ Administration: chr &quot;Совьяковская сельская администрация&quot; &quot;Совьяковская сельская администрация&quot; &quot;Совьяковская сельская администрация&quot; NA ... ## $ Comment : chr &quot;Село Беницы&quot; NA NA NA ... ## $ Perimeter : num 2.40e+18 9.22e+17 2.18e+18 3.95e+18 2.79e+17 ... ## $ Area : chr &quot;286159.158855028570000&quot; &quot;21651.963989321295000&quot; &quot;56826.463220403260000&quot; &quot;450293.758854912190000&quot; ... ## - attr(*, &quot;spec&quot;)=List of 2 ## ..$ cols :List of 6 ## .. ..$ ID : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_integer&quot; &quot;collector&quot; ## .. ..$ Type : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Administration: list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Comment : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_character&quot; &quot;collector&quot; ## .. ..$ Perimeter : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_number&quot; &quot;collector&quot; ## .. ..$ Area : list() ## .. .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_character&quot; &quot;collector&quot; ## ..$ default: list() ## .. ..- attr(*, &quot;class&quot;)= chr &quot;collector_guess&quot; &quot;collector&quot; ## ..- attr(*, &quot;class&quot;)= chr &quot;col_spec&quot; Надежны надежный способ убедиться, что все данные прочитаны с нужным типом — определить типы данных в столбцах. Для функций базовой библиотеки R названия типов совпадают с названиями стандартных типов данных. Необходимо сформировать вектор из названий типов (по количеству столбцов) и передать его в качестве параметра colClasses: classes = c(&quot;integer&quot;, &quot;character&quot;, &quot;character&quot;, &quot;character&quot;, &quot;numeric&quot;, &quot;numeric&quot;) tab2 = read.csv2(&quot;SatinoLanduse.csv&quot;, dec = &#39;.&#39;, stringsAsFactors = FALSE, colClasses = classes) ## Error in scan(file = file, what = what, sep = sep, quote = quote, dec = dec, : &#39;scan()&#39; ожидает &#39;a real&#39;, а не &#39;89499,573298880117000&#39; В данном случае последний столбец вызывает ошибку, что говорит о том, что содержищиеся в нем данные надо исправлять (см. параграф “Исправление ошибок” в конце главы). 3.2 Просмотр таблицы Для просмотра фрейма данных в консоли RStudio вы можете использовать несколько опций. Пусть наш фрейм данных называется tab. Тогда: print(tab) — выводит фрейм в консоль целиком (можно написать просто tab в консоли). head(tab, n) — отбирает первые \\(n\\) строк фрейма tail(tab, n) — отбирает последние \\(n\\) строк фрейма По умолчанию для функций head() и tail() \\(n=6\\). Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли head(tab) или tail(tab), то для выбранных строк будет вызвана функция print(), аналогично выводу всего фрейма: # ПРОСМОТР ТАБЛИЦЫ print(tab) ## Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие ## 1 1993 27.2 2.5 0.4 4.3 12.1 5.3 1.0 1.6 ## 2 1994 24.6 2.3 0.4 3.2 11.0 5.0 0.9 1.8 ## 3 1995 24.5 2.3 0.4 3.5 10.4 5.2 0.9 1.8 ## 4 1996 22.4 2.2 0.3 3.1 9.8 4.7 0.8 1.5 ## 5 1997 23.0 2.2 0.3 3.8 9.8 4.4 0.8 1.7 ## 6 1998 22.0 2.2 0.3 3.2 9.5 4.2 0.8 1.8 ## 7 1999 20.7 2.2 0.3 2.5 9.1 4.1 0.8 1.7 ## 8 2000 20.3 2.2 0.3 2.0 9.2 4.2 0.9 1.5 ## 9 2001 19.8 2.1 0.3 1.9 8.9 4.2 0.9 1.5 ## 10 2002 19.8 2.0 0.2 2.0 9.2 4.1 0.8 1.5 ## 11 2003 19.0 2.0 0.2 2.1 8.4 4.0 0.8 1.5 ## 12 2004 18.5 2.0 0.2 2.1 8.3 3.8 0.8 1.3 ## 13 2005 17.7 2.0 0.2 1.6 8.0 3.8 0.8 1.3 ## 14 2006 17.5 1.9 0.2 1.7 7.8 3.8 0.8 1.3 ## 15 2007 17.2 1.9 0.2 1.7 7.4 3.8 0.8 1.4 ## 16 2008 17.1 1.9 0.2 1.6 7.5 3.9 0.8 1.2 ## 17 2009 15.9 1.8 0.2 1.5 6.8 3.5 0.7 1.4 ## 18 2010 16.5 2.0 0.2 1.6 7.3 3.3 0.7 1.4 ## 19 2011 16.0 1.9 0.2 1.6 7.1 3.2 0.7 1.3 ## 20 2012 15.7 1.8 0.2 1.6 7.0 3.0 0.7 1.4 ## 21 2013 15.2 1.8 0.2 1.6 6.9 3.0 0.6 1.1 ## 22 2014 14.8 1.7 0.2 1.5 6.4 3.2 0.6 1.2 head(tab) ## Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие ## 1 1993 27.2 2.5 0.4 4.3 12.1 5.3 1.0 1.6 ## 2 1994 24.6 2.3 0.4 3.2 11.0 5.0 0.9 1.8 ## 3 1995 24.5 2.3 0.4 3.5 10.4 5.2 0.9 1.8 ## 4 1996 22.4 2.2 0.3 3.1 9.8 4.7 0.8 1.5 ## 5 1997 23.0 2.2 0.3 3.8 9.8 4.4 0.8 1.7 ## 6 1998 22.0 2.2 0.3 3.2 9.5 4.2 0.8 1.8 tail(tab) ## Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие ## 17 2009 15.9 1.8 0.2 1.5 6.8 3.5 0.7 1.4 ## 18 2010 16.5 2.0 0.2 1.6 7.3 3.3 0.7 1.4 ## 19 2011 16.0 1.9 0.2 1.6 7.1 3.2 0.7 1.3 ## 20 2012 15.7 1.8 0.2 1.6 7.0 3.0 0.7 1.4 ## 21 2013 15.2 1.8 0.2 1.6 6.9 3.0 0.6 1.1 ## 22 2014 14.8 1.7 0.2 1.5 6.4 3.2 0.6 1.2 RStudio, разумеется, имеет “человеческий” интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать. Чтобы его активировать, надо вызвать функцию View(): View(tab) Поскольку функции head() и tail() возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции View(): View(head(sewage, 3)) Как правило, не следует оставлять вызовы функции View() в тексте законченной программы. Это приведет к тому, что при запуске будут открываться новые вкладки с просмотром таблиц, что может раздражать пользователя (в том числе и вас самих). Используйте View() для вывода окончательного результата в конце программы или при отладке программы. Все вызовы View() в программе можно легко закомментировать или раскомментировать, выполнив поиск с заменой 'View(' на '# View(' и наоборот. 3.3 Работа со столбцами 3.3.1 Названия столбцов Для просмотра и изменения названий столбцов фрейма данных следует использовать функцию colnames(): # РАБОТА СО СТОЛБЦАМИ # Просмотрим текущие названия colnames(sewage) ## [1] &quot;X__1&quot; &quot;2005&quot; &quot;2010&quot; &quot;2011&quot; &quot;2012&quot; &quot;2013&quot; colnames(tab) ## [1] &quot;Год&quot; &quot;Всего&quot; &quot;Балтийское&quot; &quot;Черное&quot; &quot;Азовское&quot; ## [6] &quot;Каспийское&quot; &quot;Карское&quot; &quot;Белое&quot; &quot;Прочие&quot; # Заменим их на новые colnames(sewage) = c(&quot;Region&quot;, &quot;Year05&quot;, &quot;Year10&quot;, &quot;Year11&quot;, &quot;Year12&quot;, &quot;Year13&quot;) colnames(tab) = c(&quot;Year&quot;, &quot;Total&quot;, &quot;Baltic&quot;, &quot;Black&quot;, &quot;Azov&quot;, &quot;Caspian&quot;, &quot;Kara&quot;, &quot;White&quot;, &quot;Other&quot;) # Проверим результат colnames(sewage) ## [1] &quot;Region&quot; &quot;Year05&quot; &quot;Year10&quot; &quot;Year11&quot; &quot;Year12&quot; &quot;Year13&quot; colnames(tab) ## [1] &quot;Year&quot; &quot;Total&quot; &quot;Baltic&quot; &quot;Black&quot; &quot;Azov&quot; &quot;Caspian&quot; &quot;Kara&quot; ## [8] &quot;White&quot; &quot;Other&quot; 3.3.2 Обращение к столбцам К столбцу можно обращаться по номеру и названию (с помощью оператора $ или в кавычках внутри скобок). Если вы указываете в квадратных скобках номер без запятой, он трактуется именно как номер столбца, а не строки. Тип возвращаемого значения зависит от синтаксиса: обращение через $ возвращает вектор; обращение в скобках с запятой к одному столбцу возвращает вектор; обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных; обращение в скобках без запятой возвращает фрейм данных. Несколько примеров: a = head(sewage) # Один столбец - результат зависит от запятой a$Year05 # столбец в виде вектора ## [1] 17727 4341 11 89 155 169 a[, &quot;Year05&quot;] # столбец в виде вектора ## # A tibble: 6 x 1 ## Year05 ## &lt;dbl&gt; ## 1 17727 ## 2 4341 ## 3 11 ## 4 89 ## 5 155 ## 6 169 a[, 2] # столбец в виде вектора ## # A tibble: 6 x 1 ## Year05 ## &lt;dbl&gt; ## 1 17727 ## 2 4341 ## 3 11 ## 4 89 ## 5 155 ## 6 169 a[&quot;Year05&quot;] # столбец в виде фрейма данных ## # A tibble: 6 x 1 ## Year05 ## &lt;dbl&gt; ## 1 17727 ## 2 4341 ## 3 11 ## 4 89 ## 5 155 ## 6 169 a[2] # столбец в виде фрейма данных ## # A tibble: 6 x 1 ## Year05 ## &lt;dbl&gt; ## 1 17727 ## 2 4341 ## 3 11 ## 4 89 ## 5 155 ## 6 169 # Несколько столбцов - всегда фрейм данных a[, c(1, 4)] # столбцы в виде фрейма данных ## # A tibble: 6 x 2 ## Region Year11 ## &lt;chr&gt; &lt;dbl&gt; ## 1 Российская Федерация 15966 ## 2 Центральный федеральный округ 3613 ## 3 Белгородская область 72 ## 4 Брянская область 75 ## 5 Владимирская область 126 ## 6 Воронежская область 135 a[, c(&quot;Region&quot;, &quot;Year11&quot;)]# столбцы в виде фрейма данных ## # A tibble: 6 x 2 ## Region Year11 ## &lt;chr&gt; &lt;dbl&gt; ## 1 Российская Федерация 15966 ## 2 Центральный федеральный округ 3613 ## 3 Белгородская область 72 ## 4 Брянская область 75 ## 5 Владимирская область 126 ## 6 Воронежская область 135 a[c(&quot;Region&quot;, &quot;Year11&quot;)] # столбцы в виде фрейма данных ## # A tibble: 6 x 2 ## Region Year11 ## &lt;chr&gt; &lt;dbl&gt; ## 1 Российская Федерация 15966 ## 2 Центральный федеральный округ 3613 ## 3 Белгородская область 72 ## 4 Брянская область 75 ## 5 Владимирская область 126 ## 6 Воронежская область 135 a[c(1, 4)] # столбцы в виде фрейма данных ## # A tibble: 6 x 2 ## Region Year11 ## &lt;chr&gt; &lt;dbl&gt; ## 1 Российская Федерация 15966 ## 2 Центральный федеральный округ 3613 ## 3 Белгородская область 72 ## 4 Брянская область 75 ## 5 Владимирская область 126 ## 6 Воронежская область 135 Использование необходимой формы зависит от контекста и ваших целей. 3.3.3 Выбор и исключение столбцов Можно создать новую таблицу, выбрав необходимые столбцы, как это показано выше: # Создадим новый фрейм данных из трех необходимых столбцов: caspian = tab[c(&quot;Year&quot;, &quot;Total&quot;, &quot;Caspian&quot;)] str(caspian) ## &#39;data.frame&#39;: 22 obs. of 3 variables: ## $ Year : int 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ... ## $ Total : num 27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ... ## $ Caspian: num 12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ... Иногда проще создать новый фрейм данных, исключив из оригинала ненужные столбцы. Исключение делается с помощью знака ‘-’, который ставится перед номером столбца. Например, вот так можно исключить из таблицы tab столбцы Total (2-й) и Other (9-й): cleaned = tab[c(-2, -9)] str(cleaned) ## &#39;data.frame&#39;: 22 obs. of 7 variables: ## $ Year : int 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ... ## $ Baltic : num 2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ... ## $ Black : num 0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ... ## $ Azov : num 4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ... ## $ Caspian: num 12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ... ## $ Kara : num 5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ... ## $ White : num 1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ... Есть также способ удалить столбец целиком (им пользуются довольно редко). Для этого необходимо записать в него значение NULL: cleaned$Azov = NULL str(cleaned) ## &#39;data.frame&#39;: 22 obs. of 6 variables: ## $ Year : int 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ... ## $ Baltic : num 2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ... ## $ Black : num 0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ... ## $ Caspian: num 12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ... ## $ Kara : num 5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ... ## $ White : num 1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ... 3.3.4 Добавление и вычисление столбцов {col_add} Существует простой способ создать новый столбец в таблице — достаточно указать его название после значка $. Если среда R не обнаруживает столбец с таким названием, она его создаст: caspian$CaspianRatio = round(caspian$Caspian / caspian$Total, 3) View(caspian) Тем не менее, такой метод добавления столбцов нельзя считать правильным. Главный его недостаток — из формы записи неочевидно, что мы добавляем новый столбец, а не перевычисляем уже существующий. Пакет dplyr, который мы рассмотрим в конце настоящей главы, решает эту и многие другие стилистические проблемы работы с фреймами данных. Помимо того что вы можете вычислять столбцы традиционным способом как функцию от других столбцов, есть удобные функции-агрегаторы, позволяющие сделать вычисления по всем столбцам. Это rowSums() (сумма всех столбцов в строке) и rowMeans() (среднее по всем столбцам в строке). На тот случай, когда в ячейках есть пропущенные значения, в функциях предусмотрен параметр na.rm = TRUE. years = sewage[c(-1, -2)] # оставим данные с 2010 по 2013 гг colSums(years) # сколько всего было сброшено в каждом регионе за эти года ## Year10 Year11 Year12 Year13 ## NA NA NA NA rowMeans(years) # сколько было сброшено в среднем за каждый год ## [1] 15837.250 3648.750 72.750 73.000 124.750 132.250 96.500 ## [8] 89.250 45.250 37.000 84.000 1234.500 52.750 86.000 ## [15] 67.500 25.800 93.000 188.750 224.750 922.000 2906.750 ## [22] 190.500 118.000 374.000 NA 0.175 373.750 152.750 ## [29] 96.000 260.000 345.750 87.250 44.000 1239.250 1399.250 ## [36] 27.750 27.250 878.500 62.000 155.250 248.500 389.000 ## [43] 77.750 3.825 31.000 47.000 93.250 0.000 2860.750 ## [50] 319.500 55.750 40.500 483.750 115.250 29.250 381.750 ## [57] 180.250 477.250 125.250 106.000 376.250 59.500 110.250 ## [64] 1745.750 44.750 733.000 184.000 NA 53.250 35.500 ## [71] 95.250 784.500 2094.500 0.275 29.000 8.375 34.500 ## [78] 10.775 73.500 427.250 582.250 632.750 107.250 166.000 ## [85] 22.750 792.250 82.500 36.250 327.500 183.250 79.000 ## [92] 21.500 42.250 15.000 4.975 NA NA Существуют также аналогичные им функции colSums() и colMeans(), осуществляющие агрегирование данных по столбцам, а не по строкам. Перечисленные функции являются укороченной версией универсальных функций семейства apply, с которыми мы познакомимся далее. 3.4 Сортировка и фильтрация 3.4.1 Сортировка Распространенные операции с таблицами — это упорядочение по определенному столбцу и фильтрация по значениям. Мы уже знаем что из вектора, матрицы или таблицы можно извлекать элементы: tab[V, ], где tab — имя таблицы, V — это вектор из номеров элементов. Например, извлечь 5, 2 и 4 строку таблицы можно так: tab[c(5,2,4), ] ## Year Total Baltic Black Azov Caspian Kara White Other ## 5 1997 23.0 2.2 0.3 3.8 9.8 4.4 0.8 1.7 ## 2 1994 24.6 2.3 0.4 3.2 11.0 5.0 0.9 1.8 ## 4 1996 22.4 2.2 0.3 3.1 9.8 4.7 0.8 1.5 Логично предположить, что таким же образом можно извлечь элементы таблицы в порядке, обеспечивающем возрастание или убывание значений в каком-то столбце. Для этого нужно правильным образом расставить индексы в векторе c(...). Существует специальная функция order(), которая позволяет это сделать. Например, отсортируем таблицу по возрастанию сбросов в Каспийское море: indexes=order(tab$Caspian) head(tab[indexes, ]) ## Year Total Baltic Black Azov Caspian Kara White Other ## 22 2014 14.8 1.7 0.2 1.5 6.4 3.2 0.6 1.2 ## 17 2009 15.9 1.8 0.2 1.5 6.8 3.5 0.7 1.4 ## 21 2013 15.2 1.8 0.2 1.6 6.9 3.0 0.6 1.1 ## 20 2012 15.7 1.8 0.2 1.6 7.0 3.0 0.7 1.4 ## 19 2011 16.0 1.9 0.2 1.6 7.1 3.2 0.7 1.3 ## 18 2010 16.5 2.0 0.2 1.6 7.3 3.3 0.7 1.4 Если упорядочение несложное, программист его скорее всего вставит непосредственно в инструкцию обращения к таблице: head(tab[order(tab$Caspian), ]) ## Year Total Baltic Black Azov Caspian Kara White Other ## 22 2014 14.8 1.7 0.2 1.5 6.4 3.2 0.6 1.2 ## 17 2009 15.9 1.8 0.2 1.5 6.8 3.5 0.7 1.4 ## 21 2013 15.2 1.8 0.2 1.6 6.9 3.0 0.6 1.1 ## 20 2012 15.7 1.8 0.2 1.6 7.0 3.0 0.7 1.4 ## 19 2011 16.0 1.9 0.2 1.6 7.1 3.2 0.7 1.3 ## 18 2010 16.5 2.0 0.2 1.6 7.3 3.3 0.7 1.4 3.4.2 Фильтрация Схожим образом реализована фильтрация данных по значению. Например, вы хотите извлечь из таблицы только те года, в которых объем сбросов в Каспийское море составил более 10 млн м\\(^3\\). Здесь используется еще одна возможность извлечения элементов таблицы — с помощью вектора логических значений TRUE/FALSE. Число элементов в этом векторе должно быть равно числу элементов в индексируемом векторе, а значение указывает на то, нужно ли извлекать (TRUE) или нет (FALSE) элемент с текущим индексом. Вектор логических значений получается естественным путем с помощью операции сравнения: # ФИЛЬТРАЦИЯ condition = tab$Caspian &gt; 10 condition # посмотрим что получилось ## [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE tab[condition, ] # используем его для фильтрации строк таблицы: ## Year Total Baltic Black Azov Caspian Kara White Other ## 1 1993 27.2 2.5 0.4 4.3 12.1 5.3 1.0 1.6 ## 2 1994 24.6 2.3 0.4 3.2 11.0 5.0 0.9 1.8 ## 3 1995 24.5 2.3 0.4 3.5 10.4 5.2 0.9 1.8 Опять же, весьма часто используется запись одним выражением: tab[tab$Caspian &gt; 10, ] ## Year Total Baltic Black Azov Caspian Kara White Other ## 1 1993 27.2 2.5 0.4 4.3 12.1 5.3 1.0 1.6 ## 2 1994 24.6 2.3 0.4 3.2 11.0 5.0 0.9 1.8 ## 3 1995 24.5 2.3 0.4 3.5 10.4 5.2 0.9 1.8 Часто бывает необходимо отобрать данные из таблицы, содержащей разнородные данные. В частности, в нашей таблице смешаны данные по субъектам и федеральным округам. Предположим, необходимо выгрузить в отдельную таблицу данные по федеральным округам. Для этого нужно найти строки, в которых столбец Region содержит фразу &quot;федеральный округ&quot;. Для поиска по текстовым эталонам импользуется функция grep(), выдающая номера элементов, или ее разновидность grepl(), выдающая список логических констант # Первый параметр - искомое выражение, второй параметр - где искть rows = grep(&quot;федеральный округ&quot;,sewage$Region) rows # посмотрим, какие элементы столбца Region ему соответствуют ## [1] 2 21 35 42 49 64 73 86 okruga = sewage[rows,] # отфильтруем найденные строки View(okruga) Наоборот — для исключения найденных объектов удобнее воспользоваться разновидностью grepl(), которая возвращает вектор из логических значений: rows2 = grepl(&quot;федеральный округ&quot;, sewage$Region) rows2 # вот так выглядит результат grepl ## [1] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE ## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [34] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [45] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE ## [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [67] FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE ## [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE neokruga = sewage[!rows2, ] View(neokruga) Обратите внимание на восклицательный знак перед rows2. Он меняет все значения TRUE на FALSE и наоборот, что позволяет исключить найденные объекты В полученной таблице все еще содержится текстовая шелуха типа &quot;в том числе&quot;, &quot;Данные за...&quot;, а также строка &quot;Российская Федерация&quot;. К счастью, функция grep() достаточо умна и возволяет искать сразу по нескольким образцам строк. Для этого их нужно разделить вертикальной чертой — пайпом (|): rows2 = grepl(&quot;федеральный|числе|Российская|за|ѕ&quot;, sewage$Region) rows2 ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [12] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE ## [23] FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [34] FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [45] FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE FALSE FALSE ## [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [67] FALSE TRUE FALSE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE ## [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE TRUE neokruga = sewage[!rows2, ] # обратите внимание на восклицательный знак перед rows2 View(neokruga) 3.5 Пропущенные значения Можно ли осуществлять обработку таблицы sewage? Попробуем в качестве примера найти минимум сбросов за 2012 год: # ПРОПУЩЕННЫЕ ЗНАЧЕНИЯ max(sewage$Year12) ## [1] NA Результат имеет тип NA, потому что в данном столбце имеются пропуски. В некоторых статистических задачах это недопустимо. Если вы хотите проигнорировать значения пропусков, следует в вызываемой статистической функции указать дополнительный параметр na.rm = TRUE: max(sewage$Year12, na.rm = TRUE) ## [1] 15678 Еще один вариант — исключить из таблицы те строки, в которых имеются пропущенные значения (хотя бы одно!). Для этого существует функция complete.cases(), возвращающая вектор логических значений: filter=complete.cases(sewage) filter # посмотрим что получилось. Там где видим FALSE - есть пропуски в строках ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [12] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [23] TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [34] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [45] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [56] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [67] TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [78] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [89] TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE sewage.complete = sewage[filter, ] # отфильтруем полные строки View(sewage.complete) 3.6 Преобразование типов и поиск ошибок Достаточно часто при работе с реальными данными возникает необходимость преобразования их типов. Например, вам необходимо перевести строки в даты, чтобы оперировать ими соответствующим образом. Или принудительным образом указать, что столбец со строками не хранит номинальную переменную (фактор), а его нужно интерпретировать именно как строковый столбец (обычно это полезно, когда столбец содержит какую-то текстовую информацию в виде комментариев по каждому измерению). Наконец, в данных могут быть ошибки, опечатки и так далее, которые могут препятствовать правильному их чтению. В этом разделе мы рассмотрим, как можно: Найти и исправить множественные варианты одного названия с опечатками Исправить ошибки в числовых данных Преобразовать факторы в строки и наоборот Преобразовать строки в числа и наоборот Рассмотрим возможные манипуляции с данными на примере таблицы о землепользовании на территории Сатинского учебного полигоны Географического факультета МГУ: # ПОИСК ОШИБОК tab = read.csv2(&quot;SatinoLanduse.csv&quot;, encoding = &#39;UTF-8&#39;) str(tab) # посмотрим, какова структура данных ## &#39;data.frame&#39;: 160 obs. of 6 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Type : Factor w/ 12 levels &quot;Выгоны&quot;,&quot;Вырубки&quot;,..: 11 1 1 9 5 1 5 12 9 10 ... ## $ Administration: Factor w/ 7 levels &quot;&quot;,&quot;РФ&quot;,&quot;Совьяковская администрация&quot;,..: 5 5 5 1 1 5 1 5 5 6 ... ## $ Comment : Factor w/ 35 levels &quot;&quot;,&quot;АО \\&quot;Родина\\&quot;&quot;,..: 30 1 1 1 1 1 1 3 2 1 ... ## $ Perimeter : Factor w/ 160 levels &quot;1014.155593894044800&quot;,..: 67 155 51 104 78 153 17 19 108 57 ... ## $ Area : Factor w/ 160 levels &quot;0.238070145845919&quot;,..: 73 49 121 100 63 72 88 128 99 24 ... View(tab) Видно, что все столбцы, кроме двух, хранящих идентификаторы, были прочитаны как строки и преобразованы в факторы (номинальные переменные). Это означает, что мы не сможем работать привычным образом со столбцами периметра и площади, а столбец комментариев теперь также является номинальной переменной, что противоречит здравому смыслу (он вообще переменной не является). Когда вы отображаете таблицу в консоли или графическом интерфейсе, факторы выглядят и ведут себя как обычные строки. Подвох заключается в том, что хранятся они в виде пар “ключ — значение” (об этом мы говорили выше) и все операции преобразования осуществляются над ключами, а не значениями. Рассмотрим, как следует правильно преобразовывать номинальные переменные в R. Чтобы привести столбцы к нужному типу, необходимо использовать преобразования типов. Для этого можно воспользоваться функциями семейства as, описанными в Главе 1. Для начала преобразуем столбец Comment к обычному символьному представлению: tab$Comment = as.character(tab$Comment) str(tab) ## &#39;data.frame&#39;: 160 obs. of 6 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Type : Factor w/ 12 levels &quot;Выгоны&quot;,&quot;Вырубки&quot;,..: 11 1 1 9 5 1 5 12 9 10 ... ## $ Administration: Factor w/ 7 levels &quot;&quot;,&quot;РФ&quot;,&quot;Совьяковская администрация&quot;,..: 5 5 5 1 1 5 1 5 5 6 ... ## $ Comment : chr &quot;Село Беницы&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Perimeter : Factor w/ 160 levels &quot;1014.155593894044800&quot;,..: 67 155 51 104 78 153 17 19 108 57 ... ## $ Area : Factor w/ 160 levels &quot;0.238070145845919&quot;,..: 73 49 121 100 63 72 88 128 99 24 ... Посмотрим теперь, что произойдет, если мы попытаемся преобразовать столбец Perimeter к числовому виду: as.numeric(tab$Perimeter) ## [1] 67 155 51 104 78 153 17 19 108 57 7 3 158 159 156 50 91 ## [18] 143 6 58 4 5 131 148 113 128 147 114 9 18 118 132 84 134 ## [35] 81 40 130 98 83 157 42 95 71 141 8 100 34 1 87 77 160 ## [52] 93 119 90 74 35 125 150 101 136 31 109 110 103 75 14 32 63 ## [69] 145 56 102 25 65 88 72 53 92 30 117 73 43 54 121 44 52 ## [86] 27 115 149 120 45 26 41 2 60 36 123 29 151 144 106 127 12 ## [103] 116 94 82 146 142 69 21 48 139 105 154 124 47 61 33 80 97 ## [120] 64 10 76 111 11 112 89 28 129 68 39 49 86 96 59 24 137 ## [137] 46 152 55 15 99 85 22 126 16 122 79 66 133 23 107 38 138 ## [154] 13 135 37 140 70 20 62 Вместо значений перметра мы получили загадочные числа, которых в таблице нет. Это и есть ключи факторов. Чтобы получить их значения, необходимо использовать функцию levels() (для краткости выведем первые 10 значений): levels(tab$Perimeter)[1:10] ## [1] &quot;1014.155593894044800&quot; &quot;1019.457949256323400&quot; &quot;1020.278536197552200&quot; ## [4] &quot;1021.109926202218700&quot; &quot;1041.122684298658400&quot; &quot;1060.678503301135200&quot; ## [7] &quot;1081.964408568060900&quot; &quot;1094.945610298295600&quot; &quot;114.701418496307100&quot; ## [10] &quot;1155.916232728818800&quot; Обратите внимание на то, что значения фактора отсортированы в алфавитном порядке, без учете порядка их встречаемости в исходной таблице. Для корректного преобразования факторов в числа необходимо сначала привести их к обычному строковому виду: tab$Perimeter = as.numeric(as.character(tab$Perimeter)) str(tab) ## &#39;data.frame&#39;: 160 obs. of 6 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Type : Factor w/ 12 levels &quot;Выгоны&quot;,&quot;Вырубки&quot;,..: 11 1 1 9 5 1 5 12 9 10 ... ## $ Administration: Factor w/ 7 levels &quot;&quot;,&quot;РФ&quot;,&quot;Совьяковская администрация&quot;,..: 5 5 5 1 1 5 1 5 5 6 ... ## $ Comment : chr &quot;Село Беницы&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Perimeter : num 2396 922 2181 3948 279 ... ## $ Area : Factor w/ 160 levels &quot;0.238070145845919&quot;,..: 73 49 121 100 63 72 88 128 99 24 ... # Теперь попробуем преобразовать столбец Area temp = as.numeric(as.character(tab$Area)) ## Warning: в результате преобразования созданы NA temp[1:10] ## [1] 286159.159 21651.964 56826.463 450293.759 2612.615 ## [6] 28608.401 3469445.793 62299.631 450291.261 147943.134 Все прошло вроде бы успешно, но с предупреждением, что некоторые значения были преобразованы в NA (Not Available) — отсутствующие значения. По всей видимости, данные в соответствущих ячейках не соответствуют представлениям R о том, как должно выглядеть число: ячейка или пустая, или число набрано с ошибкой/опечаткой. Чтобы найти и исправить все неверно заданные данные, необходимо выполнить следующие действия: Получить индексы всех элементов, имеющих значение NA. Просмотреть, какие значения были в исходных данных под этими индексами Исправить ошибки в этих значениях, если это поддается автоматизации Повторить конвертацию в числовой тип данных Проверку на отсутствующие данные осуществляют с помощью функции is.na(). Передав ей в качестве аргумента вектор значений, вы получите вектор булевых значений, в котором TRUE будет стоять для пустых элементов. Проверим с помощью него, какие элементы столюца Area привели к ошибкам конвертации данных: tab[is.na(temp), &quot;Area&quot;] ## [1] 89499,573298880117000 11922,638460079328000 5153,570673500797100 ## 160 Levels: 0.238070145845919 ... 9865.323033935605100 Видно, что R не справился с преобразованием типов там, где содержится опечатка в десятичном разделителе — вместо точки указана запятая. Для исправления этой ошибки мы можем воспользоваться стандартной функцией замены символа gsub(pattern, replacement, x). Ее стандартные параметры означают соответственно: что искать, на что заменять, где искать: tab$Area = gsub(&#39;,&#39;, &#39;.&#39;, tab$Area) # заменим запятые на точки tab$Area = as.numeric(as.character(tab$Area)) # Теперь можно преобразовать в числа str(tab) ## &#39;data.frame&#39;: 160 obs. of 6 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Type : Factor w/ 12 levels &quot;Выгоны&quot;,&quot;Вырубки&quot;,..: 11 1 1 9 5 1 5 12 9 10 ... ## $ Administration: Factor w/ 7 levels &quot;&quot;,&quot;РФ&quot;,&quot;Совьяковская администрация&quot;,..: 5 5 5 1 1 5 1 5 5 6 ... ## $ Comment : chr &quot;Село Беницы&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## $ Perimeter : num 2396 922 2181 3948 279 ... ## $ Area : num 286159 21652 56826 450294 2613 ... Теперь необходимо навести порядок в значениях факторов, убедившись, что и там нет опечаток. Выведем все уникальные значения с помощью функции levels(): levels(tab$Type) ## [1] &quot;Выгоны&quot; &quot;Вырубки&quot; ## [3] &quot;Гидрологические объекты&quot; &quot;Заболоченные земли&quot; ## [5] &quot;Леса&quot; &quot;Лесные поляны&quot; ## [7] &quot;Луга&quot; &quot;Нет данных&quot; ## [9] &quot;Пашни&quot; &quot;Сады&quot; ## [11] &quot;Территории населенных пунктов&quot; &quot;Фермерские хозяйства&quot; levels(tab$Administration) ## [1] &quot;&quot; ## [2] &quot;РФ&quot; ## [3] &quot;Совьяковская администрация&quot; ## [4] &quot;Совьяковская сельскаая администрация&quot; ## [5] &quot;Совьяковская сельская администрация&quot; ## [6] &quot;Совьяковская сельская Администрация&quot; ## [7] &quot;Совьяковская сельская админитрация&quot; Видно, что если с типами все в порядке, то в данных об административном подчинении содержится 5 вариантов названия одной и той же Совьяковской сельской администрации. Помимо этого, пустые ячейки хорошо бы заменить на значение &quot;Прочее&quot;. Чтобы найти все строчки, относящиеся к одному и тому же объекту, можно воспользоваться уже знакомой нам функцией grep(), передав ей подстроку, которая является для них общей. Например, &quot;Совьяковская&quot; (хотя в данном случае было бы вообще достаточно одной буквы &quot;с&quot;). filter = grep(&quot;Совьяковская&quot;, tab$Administration) # Найдем все записи tab[filter, &quot;Administration&quot;] = &quot;Совьяковская сельская администрация&quot; # Заменим их одним значением tab$Administration = droplevels(tab$Administration) # Удаляем неиспользуемые уровни levels(tab$Administration) ## [1] &quot;&quot; ## [2] &quot;РФ&quot; ## [3] &quot;Совьяковская сельская администрация&quot; Пустые строки можно также найти c помощью grep(), но мы этого делать не будем, так как это требует дополнительных знаний о регулярных выражениях. Вместо этого воспользуемся тем, что пустые строки имеют длину 0. Обратите внимание ниже, что преобразование в вектор столбца Administration необходимо, т.к. nchar() не понимает объекты типа data.frame, которыми являются не только таблицы, но и их столбцы: filter = nchar(as.vector(tab$Administration)) == 0 # TRUE если длина равна 0 # Пробуем заменить: tab[filter, &quot;Administration&quot;] = &quot;Прочее&quot; ## Warning in `[&lt;-.factor`(`*tmp*`, iseq, value = c(&quot;Прочее&quot;, &quot;Прочее&quot;, : ## неправильный уровень фактора, получились NA Ошибка выше связана с тем, что R строго следит за неизменностью набора значений фактора для того чтобы избежать всевозможных ошибок при работе с данными (опечаток и т.д.). Предыдущий раз мы заменили все значаниея одним из существующих. В данном случае необходимо ввести новое значение фактора. Чтобы это сделать, придется преобразовать данные в символьные, произвести замену срок и после этого снова конвертировать столбец в фактор: tab$Administration = as.character(tab$Administration) tab[filter, &quot;Administration&quot;] = &quot;Прочее&quot; tab$Administration = as.factor(tab$Administration) levels(tab$Administration) ## [1] &quot;Прочее&quot; ## [2] &quot;РФ&quot; ## [3] &quot;Совьяковская сельская администрация&quot; Теперь таблица готова к работе. Можно, например, подсчитать по ней сводную статистику: summary(tab) ## ID Type ## Min. : 1.00 Леса :52 ## 1st Qu.: 40.75 Выгоны :27 ## Median : 80.50 Фермерские хозяйства :22 ## Mean : 80.50 Пашни :15 ## 3rd Qu.:120.25 Луга :11 ## Max. :160.00 Территории населенных пунктов: 8 ## (Other) :25 ## Administration Comment ## Прочее :76 Length:160 ## РФ : 3 Class :character ## Совьяковская сельская администрация:81 Mode :character ## ## ## ## ## Perimeter Area ## Min. : 3.087 Min. : 0 ## 1st Qu.: 421.431 1st Qu.: 5087 ## Median : 939.369 Median : 21260 ## Mean : 1761.654 Mean : 125002 ## 3rd Qu.: 2135.987 3rd Qu.: 83019 ## Max. :23920.945 Max. :3469446 ## Обратите внимание, что строки, интервальные и номинальные (факторы) переменные обрабатываются функцией summary() по-разному. 3.7 Сохранение таблиц Одной из завершающих стадий анализа данных, помимо графиков и отчетов, часто являются новые табличные представления, которые было бы неплохо сохранить в виде файлов. К счастью, сохранение таблиц в R столь же просто, как и чтение. Для текстовых файлов в формате CSV можно использовать функции write.table(), write.csv() и write.csv2(). Для файлов Microsoft Excel используйте функцию write.xlsx() из пакета openxlsx соответственно. По умолчанию функции write.table(), write.csv() и write.csv2() записывают в таблицы в качестве первого столбца названия (номера) строк таблиц. Если вы не хотите, чтобы это происходило, укажите дополнительный параметр row.names=FALSE. Сохраним таблицы okruga и neokruga, раздельно хранящие статистику по объему сброса сточных в поверхностные водные объекты по федеральным округам и субъектам соответственно: # СОХРАНЕНИЕ ТАБЛИЦ library(writexl) write.csv2(okruga, &quot;okruga.csv&quot;, fileEncoding = &#39;UTF-8&#39;) # Сохраним первую таблицу в CSV в кодировке Unicode write_xlsx(neokruga, &quot;neokruga.xlsx&quot;) # Сохраним вторую таблицу в XLSX без названий строк # Проверим, все ли в порядке с сохраненными таблицами: okruga.saved = read.csv2(&quot;okruga.csv&quot;, encoding = &#39;UTF-8&#39;) head(okruga.saved) ## X Region Year05 Year10 Year11 Year12 Year13 ## 1 1 Центральный федеральный округ 4341 3761 3613 3651 3570 ## 2 2 Северо-Западный федеральный округ 3192 3088 2866 2877 2796 ## 3 3 Южный федеральный округ 1409 1446 1436 1394 1321 ## 4 4 Северо-Кавказский федеральный округ 496 390 397 395 374 ## 5 5 Приволжский федеральный округ 3162 2883 2857 2854 2849 ## 6 6 Уральский федеральный округ 1681 1860 1834 1665 1624 neokruga.saved = read_xlsx(&quot;neokruga.xlsx&quot;,1) head(neokruga.saved) ## # A tibble: 6 x 6 ## Region Year05 Year10 Year11 Year12 Year13 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Белгородская область 11 77 72 71 71 ## 2 Брянская область 89 78 75 71 68 ## 3 Владимирская область 155 129 126 124 120 ## 4 Воронежская область 169 134 135 131 129 ## 5 Ивановская область 144 102 99 97 88 ## 6 Калужская область 99 92 88 84 93 Видно, что в файле CSV присутствует также дополнительный столбец с названиями строк, а в файле XLSX его нет. Если вы не задавали названия строк явным образом и они не несут какого-то смысла, всегда указывайте параметр row.names=FALSE Вы можете дать строкам таблицы названия и извлечь их, используя функцию row.names() аналогично функции colnames() для столбцов 3.8 Правила подготовки таблиц для чтения в R С таблицами, которые мы использовали в настоящем модуле, все прошло относительно гладко, поскольку они были подготовлены специальным образом. Несмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу: В первой строке таблицы должны располагаться названия столбцов. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: Валовый внутренний продукт за 2015 г.. Хорошее название столбца: GDP2015. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в R. Следование этим правилам значительно облегчит работу с табличными данными. 3.9 Контрольные вопросы и задачи 3.9.1 Вопросы Назовите принципы формата CSV Какие пакеты позволяют читать файлы в формате Microsoft Excel? Какие их них позволяют еще и записывать такие файлы? В каких кодировках сохраняются файлы в операционных системах Windows и UNIX/Linux/macOS? Что делать, чтобы правильно прочесть таблицу, сохраненную не в кодировке вашей операционной системы? Можно ли изменять типы данных столбцов после чтения таблицы? Если да, то какими средствами это можно сделать? Как просмотреть в консоли шапку или конец таблицы? Можно ли при этом определить количество отображаемых строк? Как просмотреть таблицу в графическом интерфейсе RStudio? Какая форма обращения к столбцу вызвращает вектор? Какая форма обращения к столбцу возвращает фрейм данных? Какие существуют способы обратиться к столбцу фрейма данных по его названию? Как удалить столбец в фрейме данных? Как выбрать требуемые столбцы фрейма данных, указав ненужные столбцы? Как отсортировать фрейм данных по одному столбцу? Нескольким столбцам? Какие функции-агрегаторы стандартной библиотеки позволяют считать суммы по столбцам и строкам? К каким компонентам фрейма данныз применяются операции фильтрации (filter) и выборки (select)? Что применяется к строкам, а что — к столбцам? Какую функцию стандартной библиотеки можно использовать для поиска строк и их фрагментов? Перечислите основные функции пакета dplyr для преобразования таблиц. Какие задачи они помогают решать? Для чего нужен пайп-оператор %&gt;%? Какие виды рабочих процессов он позволяет упростить? 3.9.2 Задачи Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "],
["controls.html", "Глава 4 Техники программирования 4.1 Функциональное программирование 4.2 Метапрограммирование 4.3 Векторизованые вычисления 4.4 Грамматика табличных преобразований 4.5 Пайпирование 4.6 Контрольные вопросы и задачи", " Глава 4 Техники программирования Программный код главы В предыдущих разделах мы обходились базовыми средствами языка R и применяли стандартные функции для решения простых задач (аналогичных тем, что традиционно решаются в табличных редакторах типа Excel). В данном модуле рассматриваются техники программирования, которые упрощают решение вычислительных задач, такие как: Функциональное программирование Метапрограммирование Трансляция переменных (пайп-оператор) 4.1 Функциональное программирование Функции в R можно использовать для структурирования кода на логически завершенные, автономные фрагменты кода, каждый из которых выполняет конкретную задачу. Чем сильнее разрастается ваш программный код, тем больше проявляется потребность в наличии функций. Функции позволяют использовать один и тот же код в разных местах программы, не повторяя его. Синтаксис функции выглядит следующим образом: functionName &lt;- function(parameter1, parameter2, ...){ ... return(result) } Функция создается c помощью ключевого слова function, за которым в круглых скобках заключается произвольное количество параметров (столько, сколько вам нужно: от нуля и более). С помощью этих параметров вы сможете передавать внутрь функции значения переменных. Созданной функции необходимо дать имя, используя оператор присвоения &lt;-. После того как выполнится код внутри функции, результат можно вернуть, используя ключевого слово return. R не поддерживает возврат множественных результатов. Если вам необходимо вернуть несколько объектов (переменных, векторов, таблиц и т.д.), создайте список (list), включите в него все возвращаемые объекты и верните из функции этот список. В вышеприведенном примере мы использовали проверку условия для того чтобы вычислить рекомендуемый цвет гистограммы. С одной стороны, это некая вспомогательная процедура, не имеющая непосредственного отношения к построению гистограммы. С другой стороны, это полезная процедура, которой мы захотим воспользоваться в дальнейшем — всегда приятно, когда программа тебе с выбором стилей оформления данных2. Оформим выбор цвета в виде функции, которая принимает в каестве параметра число (температуру), а возвращает название цвета. ## ФУНКЦИИ library(foreign) # для чтения dbf необходима библиотека foreign files &lt;- list.files(&quot;dbf&quot;) # прочитаем список файлов в директории dbf files &lt;- files[grep(&quot;.dbf&quot;, files, fixed = TRUE)] # отфильтруем файлы с расширением .dbf names &lt;- sub(&quot;.dbf&quot;,&quot;&quot;,files) # получим названия месяцев, избавившись от расширений i &lt;- 1 # Создадим дополнительно переменную цикла, чтобы выбирать i-е название месяца # Создадим функцию, возвращающую цвет в зависимости от температуры selectColor &lt;- function(value) { hist.col &lt;- &quot;white&quot; if (tmean &lt; 0){ hist.col &lt;- &quot;steelblue&quot; } else if (tmean &lt; 10){ hist.col &lt;- &quot;yellow&quot; } else { hist.col &lt;- &quot;orange&quot; } return(hist.col) } i &lt;- 1 par(mfrow = c(2,2)) for (file in files) { temp &lt;- read.dbf(file) tmean &lt;- mean(temp$Temp) # выберем цвет с помощью нашей функции hist.col &lt;- selectColor(tmean) # построим гистограмму hist(temp$Temp, col = hist.col, main = names[i]) # добавим линию среднего abline(v = tmean, lwd = 2, col = &quot;red&quot;) # подпишем среднее text(tmean, 1000, labels = round(tmean,1), pos = 4, col = &quot;red&quot;) i &lt;- i+1 } Усложним задачу, чтобы показать, как работать с несколькими аргументами функции. Например, мы хотим не одноцветные диаграммы, а чтобы цвет менялся плавным градиентом от первого столбика гистограммы до последнего. Соответственно, количество возвращаемых цветов должно быть равно количеству столбиков в гистограмме. Нашей функции не важно, столбики это или нет, но ей надо знать, сколько цветов надо вернуть. Для этого добавим в нее второй параметр ncolors. Это позволит пользователю при желании не задвать этот параметр, если необходим только один цвет. # ГИСТОГРАММЫ С ГРАДИЕНТОМ selectColor2 &lt;- function(value, ncolors){ # передаем в качестве дополнительного параметра количество цветов hist.col &lt;- &quot;white&quot; # генерируем ncolors цветов из соответствующей палитры if (tmean &lt; 0){ hist.col &lt;- colorRampPalette(c(&quot;darkslateblue&quot;, &quot;steelblue1&quot;))(ncolors) } else if (tmean &lt; 10){ hist.col &lt;- colorRampPalette(c(&quot;steelblue1&quot;, &quot;yellow&quot;))(ncolors) } else { hist.col &lt;- colorRampPalette(c(&quot;yellow&quot;, &quot;red&quot;))(ncolors) } return(hist.col) } i &lt;- 1 par(mfrow = c(2,2)) ncells &lt;- 25 # установим фиксированное количество столбцов гистограммы for (file in files){ temp &lt;- read.dbf(file) tmean &lt;- mean(temp$Temp) # получим для раскраски требуемое количество цветов hist.col &lt;- selectColor2(tmean, ncells) # построим гистограмму hist(temp$Temp, col = hist.col, main = names[i], breaks = ncells) # добавим линию среднего abline(v = tmean, lwd = 2, col = &quot;red&quot;) # подпишем среднее text(tmean, 1000, labels = round(tmean,1), pos = 4, col = &quot;red&quot;) i &lt;- i+1 } 4.2 Метапрограммирование 4.3 Векторизованые вычисления Данные (в том числе географические) практически всегда носят множественный характер и организованы в определенные структуры (см. главу 2). Эта особенность данных выдвигает логичное желание иметь процедуры, которые можно применять к полному набору данных, а не к его отдельным компонентам. Это и есть процедуры векторизованных высчислений. Предположим, вам необходимо что-то вычислить для каждой строки таблицы, при этом порядок вычисления зависит от содержимого ячеек данной строки. Вы можете организовать подобные вычисления с помощью циклов, однако в R существуют специальные функции семейста apply, которые позволяют решать подобные задачи более элегантно и с высокой скоростью. Это достигается за счет того, что функции apply написаны на языке C (как и многие другие функции R), в то время как при организации цикла ваши данные будут обрабатываться стандартными средствами языка. Функция Назначение apply() применить функцию ко всем строкам или столбцам матрицы lapply() применить функцию к каждому компоненту вектора или списка и получить результат также в виде списка (l — list) sapply() применить функцию к каждому компоненту вектора или списка и получить результат в виде вектора (s — simplify) vapply() аналогична vapply, но требует явного задания типа данных возвращаемого вектора, за счет чего работает быстрее (v — velocity) mapply() применить функцию к каждому компоненту нескольких векторов или списков и вернуть результат в виде списка (m — multivariate) rapply() применить функцию рекурсивно ко всем элементам переданного списка и вернуть результат в аналогичной структур (r — recursive) tapply() применить функцию ко всем компонентам вектора или списка, сгруппировав их по значению переданного фактора Функции семейства apply, принимающие на вход списки, могут работать и с фреймами данных. В этом случае фрейм внутри функции будет преобразован с помощью функции as.list() в список, элементами которого являются столбцы (переменные) входного фрейма данных. Данные при этом не потеряются, их типы тоже не изменятся. Базовая функция apply() имеет следующие аргументы: X — массив любой размерности (включая вектор) MARGIN — измерения по которым необходимо вести вычисления. Для матрицы 1 означает строку, 2 означает столбец, c(1, 2) будет означать, что вычисления производятся по всем комбинациям строк и столбцов FUN — функция, которая будет применяться к каждому элементу указанных измерений Рассмотрим, как можно вычислять значения по строкам. У нас есть подготовленная таблица Росстата Выбросы в атмосферу загрязняющих веществ, отходящих от стационарных источников, по видам экономической деятельности. Рассчитаем, какой тип источника занимает максимальное и минимальное место среди газообразных и жидких. Обратите внимание, что в первом случае используется заранее созданная функция, а во втором мы определяем анонимную функцию непосредственно при вызове apply(): ## ВЕКТОРИЗОВАННЫЕ ВЫЧИСЛЕНИЯ library(dplyr) ## ## Присоединяю пакет: &#39;dplyr&#39; ## Следующие объекты скрыты от &#39;package:stats&#39;: ## ## filter, lag ## Следующие объекты скрыты от &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union df &lt;- read.csv2(&quot;atm_emissions.csv&quot;) head(df) ## YEAR TOTAL SOLID FLGAS SO NO CO CH ORG ## 1 1992 28207.6 5609.1 22598.5 8171.3 2718.1 6813.0 2583.9 1608.9 ## 2 1993 24788.3 4746.1 20042.2 7217.9 2462.0 5894.0 2386.7 1604.8 ## 3 1994 21929.1 3870.2 18058.9 6512.5 2085.2 5140.8 2609.3 1238.0 ## 4 1995 21269.6 3600.4 17669.2 6424.8 1996.6 5005.6 2735.7 1110.9 ## 5 1996 20274.1 3233.4 17040.8 6156.7 1920.4 4876.6 2531.3 1161.8 ## 6 1997 19332.9 3041.8 16291.1 5991.1 1799.7 4653.0 2554.2 989.9 find.max &lt;- function(x) { return(names(x)[which.max(x)]) } df$MAXSRC &lt;- apply(df[5:9], 1, find.max) df$MINSRC &lt;- apply(df[5:9], 1, function(x) names(x)[which.min(x)]) print(df) ## YEAR TOTAL SOLID FLGAS SO NO CO CH ORG MAXSRC ## 1 1992 28207.6 5609.1 22598.5 8171.3 2718.1 6813.0 2583.9 1608.9 SO ## 2 1993 24788.3 4746.1 20042.2 7217.9 2462.0 5894.0 2386.7 1604.8 SO ## 3 1994 21929.1 3870.2 18058.9 6512.5 2085.2 5140.8 2609.3 1238.0 SO ## 4 1995 21269.6 3600.4 17669.2 6424.8 1996.6 5005.6 2735.7 1110.9 SO ## 5 1996 20274.1 3233.4 17040.8 6156.7 1920.4 4876.6 2531.3 1161.8 SO ## 6 1997 19332.9 3041.8 16291.1 5991.1 1799.7 4653.0 2554.2 989.9 SO ## 7 1998 18661.8 2864.4 15797.4 5679.3 1753.3 4562.9 2571.6 921.9 SO ## 8 1999 18539.7 2768.4 15771.2 5505.5 1716.4 4663.9 2767.7 831.0 SO ## 9 2000 18819.8 2972.2 15847.6 5407.1 1698.4 4997.9 2685.4 850.4 SO ## 10 2001 19123.6 2973.2 16150.4 5254.0 1678.9 5148.1 2723.6 1130.8 SO ## 11 2002 19481.2 2882.8 16598.4 4987.4 1646.2 5857.5 2733.2 1164.8 CO ## 12 2003 19829.4 2868.0 16961.4 4959.6 1661.8 5929.4 2834.1 1356.5 CO ## 13 2004 20491.3 2855.7 17635.6 4768.4 1628.9 6774.4 2786.8 1448.2 CO ## 14 2005 20425.4 2802.0 17623.3 4675.0 1666.8 6521.2 2868.1 1650.6 CO ## 15 2006 20568.4 2842.8 17725.6 4764.7 1703.1 6338.3 2815.0 1863.1 CO ## 16 2007 20636.9 2743.4 17893.5 4573.1 1732.8 6448.4 2992.4 1908.6 CO ## 17 2008 20103.3 2704.2 17399.0 4534.1 1816.6 6091.5 3217.5 1532.0 CO ## 18 2009 19021.2 2341.1 16680.1 4370.6 1730.5 5500.5 3347.3 1546.0 CO ## 19 2010 19115.6 2381.2 16734.4 4385.3 1855.2 5565.1 3135.9 1605.3 CO ## 20 2011 19162.3 2283.1 16879.2 4342.7 1880.0 5753.5 3105.8 1622.8 CO ## 21 2012 19630.3 2249.4 17380.9 4340.9 1937.5 6001.8 3293.3 1638.2 CO ## 22 2013 18446.5 2008.5 16438.0 4173.3 1874.2 5350.9 3424.8 1455.8 CO ## 23 2014 17451.9 1922.2 15529.7 4036.3 1805.5 4938.4 3251.0 1340.0 CO ## 24 2015 17295.7 1820.4 15475.3 4099.4 1787.4 4799.6 3323.0 1294.5 CO ## 25 2016 17349.3 1723.9 15625.4 4011.4 1830.1 4907.1 3406.1 1304.6 CO ## MINSRC ## 1 ORG ## 2 ORG ## 3 ORG ## 4 ORG ## 5 ORG ## 6 ORG ## 7 ORG ## 8 ORG ## 9 ORG ## 10 ORG ## 11 ORG ## 12 ORG ## 13 ORG ## 14 ORG ## 15 NO ## 16 NO ## 17 ORG ## 18 ORG ## 19 ORG ## 20 ORG ## 21 ORG ## 22 ORG ## 23 ORG ## 24 ORG ## 25 ORG Другие функции семейства apply в приложении к фреймам данных будут работать со столбцами (переменными), интерпретируя их как элементы списка. Наиболее часто из них используются lapply(), sapply() и vapply().В отличие от apply(), они уже не принимаеют номера измерений и работают только с элементами переданного списка. Например, мы можем посчитать среднее значение объема выбросов по каждому источнику. Поскольку функция среднего уже есть в составе базовых средств R, достаточно указать ее при вызове sapply(): sapply(df, mean) ## Warning in mean.default(X[[i]], ...): аргумент не является числовым или ## логическим: возвращаю NA ## Warning in mean.default(X[[i]], ...): аргумент не является числовым или ## логическим: возвращаю NA ## YEAR TOTAL SOLID FLGAS SO NO CO ## 2004.000 19998.208 2884.316 17113.884 5173.696 1855.424 5541.336 ## CH ORG MAXSRC MINSRC ## 2907.348 1367.176 NA NA В данном случае для первого столбца было возвращено значение NA, что логично, поскольку он имеет строковый тип. В качестве альтернативы функциям apply можно также воспользоваться вычислениями посредством функций семейства map из пакета purrr (еще один пакет из tidyverse). Эти функции работают аналогично lapply() и поддерживают последовательности с помощью пайп-оператора: map() возвращает список. map_lgl() возвращает вектор логических значений. map_int() возвращает вектор целочисленных значений. map_dbl() возвращает вектор чисел с плавающей точкой. map_chr() возвращает вектор строк. Например, предыдущая задача с помощью purrr решались бы так: library(purrr) map_dbl(df, mean) ## Warning in mean.default(.x[[i]], ...): аргумент не является числовым или ## логическим: возвращаю NA ## Warning in mean.default(.x[[i]], ...): аргумент не является числовым или ## логическим: возвращаю NA ## YEAR TOTAL SOLID FLGAS SO NO CO ## 2004.000 19998.208 2884.316 17113.884 5173.696 1855.424 5541.336 ## CH ORG MAXSRC MINSRC ## 2907.348 1367.176 NA NA 4.4 Грамматика табличных преобразований Пакет dplyr был разработан для того чтобы сделать стандартные операции обработки фреймов данных, такие как сортировка, фильтрация, выбор и добавление переменных (столбцов), агрегирование данных более простым и наглядным. Пакет очень включает в себя 5 базовых функций: Функция Назначение mutate() Вычисление новых переменных select() Выбор переменных по их названиям filter() Выбор строк по заданному критерию (запросу) summarise() Агрегирование значений переменных arrange() Упорядочение фрейма данных по указанным переменным Данные функции можно комбинировать также с функцией group_by() чтобы выполнять операции не надо всеми строками сразу, а над их группами, сгруппированными по значению выбранной переменной. Предположим, нам необходимо отобрать из уже знакомой нам таблицы tab столбцы Year, Total, Caspian, далее вычислить долю Каспийского моря в суммарном объеме сточных вод, отобрать строки, в которых эта доля больше \\(0.45\\) и упорядочить получившуюся таблицу по возрастанию этой доли. Дополнительно еще посчитаем суммарный сброс и среднюю долю Каспийского мор: library(dplyr) tab &lt;- read.csv2(&quot;oxr_vod.csv&quot;) colnames(tab) &lt;- c(&quot;Year&quot;, &quot;Total&quot;, &quot;Baltic&quot;, &quot;Black&quot;, &quot;Azov&quot;, &quot;Caspian&quot;, &quot;Kara&quot;, &quot;White&quot;, &quot;Other&quot;) # Выбор переменных Year, Total, Caspian caspian &lt;- select(tab, Year, Total, Caspian) head(caspian) ## Year Total Caspian ## 1 1993 27.2 12.1 ## 2 1994 24.6 11.0 ## 3 1995 24.5 10.4 ## 4 1996 22.4 9.8 ## 5 1997 23.0 9.8 ## 6 1998 22.0 9.5 # Вычисление нового столбца caspianRatio caspian &lt;- mutate(caspian, caspianRatio = round(Caspian / Total, 3)) head(caspian) ## Year Total Caspian caspianRatio ## 1 1993 27.2 12.1 0.445 ## 2 1994 24.6 11.0 0.447 ## 3 1995 24.5 10.4 0.424 ## 4 1996 22.4 9.8 0.438 ## 5 1997 23.0 9.8 0.426 ## 6 1998 22.0 9.5 0.432 # Фильтрация по значению caspianRatio caspian &lt;- filter(caspian, caspianRatio &gt; 0.445) head(caspian) ## Year Total Caspian caspianRatio ## 1 1994 24.6 11.0 0.447 ## 2 2000 20.3 9.2 0.453 ## 3 2001 19.8 8.9 0.449 ## 4 2002 19.8 9.2 0.465 ## 5 2004 18.5 8.3 0.449 ## 6 2005 17.7 8.0 0.452 # Сортировка по значению caspianRatio caspian &lt;- arrange(caspian, caspianRatio) head(caspian) ## Year Total Caspian caspianRatio ## 1 2006 17.5 7.8 0.446 ## 2 2012 15.7 7.0 0.446 ## 3 1994 24.6 11.0 0.447 ## 4 2001 19.8 8.9 0.449 ## 5 2004 18.5 8.3 0.449 ## 6 2005 17.7 8.0 0.452 # Агрегирование данных stats &lt;- summarise(caspian, total.sum = sum(Total), mean.ratio = mean(caspianRatio)) print(stats) ## total.sum mean.ratio ## 1 169.1 0.4512222 Обратите внимание на то, что названия столбцов указываются без кавычек! Использование dplyr целым обладает рядом преимуществ по сравнению с применением стандартных средств R: вызов функций с говорящими названиями операции более понятными; код выглядит более чистым и легко читаемым за счет отсутствия обращений к фреймам данных через квадратные скобки и доллары; код с использованием функций dplyr часто оказывается короче, чем его традиционные аналоги; операции dplyr можно выстраивать в последовательности с помощью пайп-оператора %&gt;%, доступного в R через пакет magrittr (устанавливается вмете с dplyr. 4.5 Пайпирование Пайп-оператор %&gt;% предназначен для компактной и наглядной записи последовательностей обработки данных. Например, выше мы применили целых 4 операции к исходной таблице (select, mutate, filter, arrange), прежде чем получить искомый результат. Промежуточные результаты нас мало интересовали, при этом мы каждый раз перезаписывали исходную таблицу (могли и новую делать каждый раз, что сделало бы код еще более громоздким). С помощью пайп-оператора %&gt;% вышеприведенный код можно записать так: result &lt;- tab %&gt;% select(Year, Total, Caspian) %&gt;% mutate(caspianRatio = round(Caspian / Total, 3)) %&gt;% filter(caspianRatio &gt; 0.445) %&gt;% arrange(caspianRatio) head(result) ## Year Total Caspian caspianRatio ## 1 2006 17.5 7.8 0.446 ## 2 2012 15.7 7.0 0.446 ## 3 1994 24.6 11.0 0.447 ## 4 2001 19.8 8.9 0.449 ## 5 2004 18.5 8.3 0.449 ## 6 2005 17.7 8.0 0.452 Обратите внимание, что мы уже не подставляли исходный фрейм данных в качестве первого параметра при вызове функций dplyr, а направляли его посредством пайп-оператора. Этот оператор работает следующим образом: x %&gt;% f эквивалентно f(x) x %&gt;% f(y) эквивалентно f(x, y) x %&gt;% f %&gt;% g %&gt;% h эквивалентно h(g(f(x))) В частности, первая операция select(tab, Year, Total, Caspian) была нами переписана в виде tab %&gt;% select(Year, Total, Caspian). Если бы мы попытались написать ту же последовательность операций одним выражением в традиционной парадигме, это выглядело бы вот так: result &lt;- arrange( filter( mutate( select(tab, Year, Total, Caspian), caspianRatio = round(Caspian / Total, 3) ), caspianRatio &gt; 0.445 ), caspianRatio ) Согласитесь, ненаглядно и несколько устрашающе? К тому же, читать такой код надо задом наперед (изнутри наружу), чтобы понять последовательность действий. Синтаксис с использованием пайп-оператора позволяет: упорядочить операции по обработке данных слева направо (в противоположность направлению изнутри наружу); избежать вложенных вызовов функций (матрёшки); минимизировать количество переменных для храненния промежуточных результатов; упростить добавление новых операций по обработке данных в любое место последовательности. Таким образом, можно рекомендовать пакет dplyr в качестве стандартного средства манипуляции фреймами данных, особенно когда речь идет о большом количестве преобразований. При этом последовательности преобразований, в которых промежуточные результаты нигде больше не используются, следует оформлять одним выражением с использованием пайп-оператора %&gt;%. Пайп-оператор %&gt;% можно быстро набрать в RStudio, нажав клавиатурное сочетание Ctrl + Shift + M (Cmd + Shift + M на компьютерах Mac) 4.6 Контрольные вопросы и задачи Что такое функция и для каких сценариев обработки данных могут быть полезны функции? Может ли функция возвращать более одного значения? Что необходимо сделать, чтобы реализовать такую возможность? Что такое векторизованные вычисления? Перечислите функции семейства apply и задачи, которые они позволяют решить. Какая функция семейства apply позволяет выполнять вычисления не только по столбцам, но и по строкам? Можно ли передавать в функции семейства apply фреймы данных? Если да, то как интерпретируются такие данные? Какой пакет R позволяет выполнять векторизованные вычисления в более простой и быстрой форме, чем функции семейства apply? Можно ли с помощью него выполнять вычисления по строкам? 4.6.1 Вопросы 4.6.2 Задачи Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 в картографии это называется “smart mapping”, что переводят как “умное картографирование”, хотя это и не самый удачный вариант перевода↩ "],
["graphics.html", "Глава 5 Базовая графика в R 5.1 Стандартные графики 5.2 Гистограммы 5.3 Столбчатые графики 5.4 Круговые (секторные) диаграммы 5.5 Цвет и прозрачность 5.6 Настройки отображения 5.7 Легенда 5.8 Контрольные вопросы и задачи", " Глава 5 Базовая графика в R Программный код главы Данный модуль посвящен введению в работу с графическим представлением информации в R. Построение графиков на языке R сродни работе с конструктором: вы собираете изображение по кирпичикам из множества настроек и компонент. Поняв основные принципы базовой графической подсистемы R из пакета graphics, вы сможете освоить дополнительные библиотеки lattice, ggplot2 и plotly, предоставляющие еще более интересные возможности с точки зрения функциональности и дизайна. Прежде чем мы приступим к построению графиков, необходимо подготовить исходные данные. Мы будем работать с теми же таблицами, что и в предыдцщей лекции: экспорт/импорт продукции по регионам России (млн долл. США) и объем сброса сточных вод по морям России (млрд м\\(^3\\)). На этот раз мы воспользуемся пакетом readxl, который возволяет задать типы столбцов при чтении: library(readxl) # Прочтем таблицу по экспорту/импорту продукции в регионах России types &lt;- c(&quot;text&quot;, rep(&quot;numeric&quot;, 12)) tab &lt;- as.data.frame(read_excel(&quot;ExpImp.xlsx&quot;, 1, col_types = types)) str(tab) ## &#39;data.frame&#39;: 96 obs. of 13 variables: ## $ Регион : chr &quot;Российская Федерация&quot; &quot;Центральный федеральный округ&quot; &quot;Белгородская область&quot; &quot;Брянская область&quot; ... ## $ ПродЭкспорт: num 16196.2 4552.9 221.9 28.5 177.9 ... ## $ ПродИмпорт : num 43076 22954 614 650 454 ... ## $ ТЭКЭкспорт : num 371791.8 204331.7 64.7 5 0.9 ... ## $ ТЭКИмпорт : num 3613.6 1660.3 24.1 20.5 16.7 ... ## $ ХимЭкспорт : num 30739.2 8442.7 33.3 24.5 87.7 ... ## $ ХимИмпорт : num 50129.5 34870.4 242.8 71.7 419 ... ## $ ДревЭкспорт: num 10965.8 1101.6 6.2 23.4 57.1 ... ## $ ДревИмпорт : num 6641.5 3942.6 43.3 44.9 9 ... ## $ МетЭкспорт : num 40859.3 9877 2014.1 50.5 29 ... ## $ МетИмпорт : num 22017.4 11763.6 1207.3 68.3 56.6 ... ## $ МашЭкспорт : num 28338.5 12845.9 84.1 143.2 286.1 ... ## $ МашИмпорт : num 154371 96196 1710 823 469 ... # Выгрузим данные по федеральным округам в отдельную таблицу filter &lt;- grep(&quot;федеральный округ&quot;, tab$Регион) okr &lt;- tab[filter, ] # Отсортируем данные по федеральным округам в алфавитном порядке: okr &lt;- okr[order(okr$Регион), ] # Выгрузим данные по субъектам в отдельную таблицу filter &lt;- grepl(&quot;федеральный округ|Федерация|числе&quot;,tab$Регион) sub &lt;- tab[!filter, ] 5.1 Стандартные графики Графики (точечные и линейные) – базовый и наиболее часто используемый способ визуализации. Универсальная функция plot() позволяет строить графики по координатам \\(X\\) и \\(Y\\), которые передаются, соответственно, в первый и второй аргумент. Если переменные \\(X\\) и \\(Y\\) не связаны друг с другом явным образом, то такой график называется диаграммой рассеяния. 5.1.1 Диаграммы рассеяния Диаграмма рассеяния позволяет установить, есть ли зависимость между переменными, а также понять, как объекты дифференцируются по значениям переменных. par(mar=c(4,4,3,2)) # Диаграмма рассеяния по экспорту и импорту: plot(sub$МетЭкспорт, sub$МетИмпорт, col=&quot;red&quot;, xlab=&quot;Экспорт, млн. долл. США&quot;, ylab = &quot;Импорт, млн. долл. США&quot;, main = &quot;Экспорт/импорт металлов и изделий из них по субъектам РФ&quot;) В данном случае четко выделяется группа субъектов вблизи начала координат, не отличающихся интенсивным экспортом и импортом продукции металлургии, а также очевидно преобладание экспорта над импортом при больших объемах товарооборота. При построении диаграмм рассеяния важно сохранить одинаковый масштаб по осям \\(X\\) и \\(Y\\). Чтобы обеспечить это условие, необходимо использовать параметр asp = 1: plot(sub$МетЭкспорт, sub$МетИмпорт, col=&quot;red&quot;, xlab=&quot;Экспорт, млн. долл. США&quot;, ylab = &quot;Импорт, млн. долл. США&quot;, main = &quot;Экспорт/импорт металлов и изделий из них по субъектам РФ&quot;, asp = 1) Попробуйте изменить размер окна на вкладке Plots. Вы увидите, что масштаб по осям сохраняется пропорциональным. Размер и тип значка можно изменить, используя параметры pch = и cex =. Размеры масштабируются параметром cex относительно условной единицы — стандартного размер значка. Сам значок можно выбрать, используя его код в соответствии с нижеприведенным рисунком (на самом деле, вы можете выбирать произвольные символы для визуализации точек): Типы символов R plot(sub$МетЭкспорт, sub$МетИмпорт, col=&quot;red&quot;, xlab=&quot;Экспорт, млн. долл. США&quot;, ylab = &quot;Импорт, млн. долл. США&quot;, main = &quot;Экспорт/импорт металлов и изделий из них по субъектам РФ&quot;, asp = 1, pch = 2, cex = 0.5) plot(sub$МетЭкспорт, sub$МетИмпорт, col=&quot;red&quot;, xlab=&quot;Экспорт, млн. долл. США&quot;, ylab = &quot;Импорт, млн. долл. США&quot;, main = &quot;Экспорт/импорт металлов и изделий из них по субъектам РФ&quot;, asp = 1, pch = 20, cex = 1.2) 5.1.2 Линейные графики Линейные графики отражают связь между зависимой и независимой переменной. Существует два способа нанесения линий на график: явное рисование линий поверх уже построенного графика с помощью функции lines(), или создание нового линейного графика с помощью функции plot() с дополнительным параметром type =. Для иллюстрации принципов работы первого способа откроем еще раз данные по объему сброса загрязненных сточных вод по морям России (млрд куб. м): tab &lt;- read.csv2(&quot;oxr_vod.csv&quot;, encoding = &#39;UTF-8&#39;) plot(tab$Год, tab$Каспийское, pch=20) # для начала нанесем точки lines(tab$Год, tab$Каспийское) # теперь нанесем линии По умолчанию функция plot() рисует именно точки. Однако если точки не нужны, а достаточно только линий, или требуется иной подход к построению графиков, можно задать параметр type =, который принимает следующие значения: &quot;p&quot; for points, &quot;l&quot; for lines, &quot;b&quot; for both, &quot;c&quot; for the lines part alone of “b”, &quot;o&quot; for both ‘overplotted’, &quot;h&quot; for ‘histogram’ like (or ‘high-density’) vertical lines, &quot;s&quot; for stair steps, &quot;S&quot; for other steps, see ‘Details’ below, &quot;n&quot; for no plotting. Попробуем разные методы визуализации: plot(tab$Год, tab$Карское,pch=20) plot(tab$Год, tab$Каспийское, type=&quot;p&quot;) plot(tab$Год, tab$Каспийское, type=&quot;l&quot;) plot(tab$Год, tab$Каспийское, type=&quot;b&quot;) plot(tab$Год, tab$Каспийское, type=&quot;c&quot;) plot(tab$Год, tab$Каспийское, type=&quot;o&quot;) plot(tab$Год, tab$Каспийское, type=&quot;h&quot;) plot(tab$Год, tab$Каспийское, type=&quot;s&quot;) Толщину и тип линии можно изменить, используя параметры lwd = и lty = соответственно. Работают они аналогично параметрам pch и cex для точечных символов. Типов линий по умолчанию в стандартной библиотеке R не так много, но в сочетании с цветовым кодированием и толщиной их оказывается вполне достаточно: Попробуем разные варианты представления линий: plot(tab$Год, tab$Каспийское, type=&quot;l&quot;, lwd = 2, lty = 1) plot(tab$Год, tab$Каспийское, type=&quot;l&quot;, lwd = 3, lty = 2) plot(tab$Год, tab$Каспийское, type=&quot;l&quot;, lwd = 1, lty = 3) 5.1.3 Совмещение графиков Часто бывает необходимо совместить на одном графике несколько рядов данных. Для этого можно поступить двумя путями: Нарисовать один ряд данных c помощью функции plot(), а затем добавить к нему другие ряды с помощью функций points() и lines(). Нарисовать пустой график, а затем добавить к нему все ряды данных с помощью функций points() и lines(). При совмещении нескольких рядов данных на одном графике в первом же вызове функции plot() необходимо заложить диапазон значений по осям \\(X\\) и \\(Y\\), охватывающий все ряды данных. В противном случае будет учтен только разброс значений первого ряда данных, и остальные ряды могут не поместиться в поле графика. Вариант №1 реализуется следующим образом: plot(tab$Год, tab$Каспийское, pch=20, type=&quot;o&quot;, ylim = c(0,12), col=&quot;red3&quot;) # Добавим теперь на существующий график новый ряд данных, используя функции points() и lines(): points(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) lines(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) Обратите внимание на то, что если бы мы вызвали еще одну инструкцию plot() с новым рядом данных, это привело бы к построению нового графика, а не к добавлению его на существующий. Теперь рассмотрим второй вариант. Заодно устраним недостаток предыдущего кода, в котором диапазон значений по оси \\(Y\\) указывался вручную. xrange = range(tab$Год) # вычислим диапазон по оси X yrange = range(tab$Каспийское, tab$Карское, tab$Азовское) # вычислим диапазон по оси Y # Построим пустой график, охватывающий полный диапазон данных, и имеющий все необходимые сопроводительные элементы plot(xrange, yrange, main=&quot;Объем сброса загрязненных сточных вод&quot;, xlab=&quot;Год&quot;, ylab=&quot;млрд.куб.м&quot;, type = &quot;n&quot;) # n означает, что ряд данных рисоваться не будет # Теперь добавим на график ряды данных points(tab$Год, tab$Каспийское, pch=20, col=&quot;red3&quot;) lines(tab$Год, tab$Каспийское, pch=20, col=&quot;red3&quot;) points(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) lines(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) points(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;) lines(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;) 5.1.4 Функциональные параметры Графические параметры при построении графиков на самом деле могут быть не константами, а функцией данных. Например, вы можете сказать, что размер точки при построении диаграммы рассеяния должен быть функцией отношения экспорта к импорту, что усилит наглядность отображения: plot(okr$МетЭкспорт, okr$МетИмпорт, col=rgb(1,0,0,0.5), xlab=&quot;Экспорт, млн. долл. США&quot;, ylab = &quot;Импорт, млн. долл. США&quot;, main = &quot;Экспорт/импорт металлов и изделий из них по ФО РФ (2013 г.)&quot;, asp = 1, pch = 20, cex = 2+log(sub$МетИмпорт/sub$МетЭкспорт)) # размер кружка зависит от соотношения импорта и экспорта 5.2 Гистограммы Гистограммы распределения строятся с помощью функции hist(). Чтобы изменить ширину кармана (столбца) гистограммы, необходимо задать параметр breaks =, а цвет задается в параметре col: hist(sub$ПродЭкспорт) # Карманы будут от 0 до 3000 через 100. Заодно добавим цвет: hist(sub$ПродЭкспорт, breaks = seq(0,3000,100), col=&quot;olivedrab3&quot;) При построении гистограммы (как и любого другого типа графика) вы можете использовать не весь массив данных, а только его подмножество Например, можно посмотреть гистограмму только для субъектов с объемом эспорта менее 300: hist(sub$ПродЭкспорт[sub$ПродЭкспорт &lt; 300], col = &quot;olivedrab3&quot;, breaks = seq(0, 300, 20)) Наконец, вы можете осуществить преобразование ряда данных перед построением гистограммы. Например, взять логарифм, чтобы проверить,похоже ли распределение на логнормальное: hist(log(sub$ПродЭкспорт), col = &quot;olivedrab3&quot;) 5.3 Столбчатые графики Столбчатые графики — barplot — отображают вектор числовых данных в виде столбиков. Это простейший вид графика (наряду с dotchart), который используется для сравнения асболютных величин. Для построения необходимо вызвать функцию barplot() и передать ей столбец таблицы: barplot(okr$ХимЭкспорт) # Или даже просто вектор натуральных чисел от -5 до 5: barplot(-5:5) # Если у каждого столбика есть название, # нужно передать вектор названий в аргумент names.arg = barplot(okr$ХимЭкспорт, names.arg = okr$Регион) # при наличии длинных подписей удобнее столбчатую диаграмму разместить горизонтально, используя параметр horiz = TRUE. barplot(okr$ХимЭкспорт, names.arg = okr$Регион, horiz=TRUE) Чтобы развернуть подписи перпендикулярно столбцам, следует использовать параметр las =. Справка__R__говорит нам о том, что этот параметр дает следующее поведение подписей: 0: всегда параллельно осям (по умолчанию), 1: всегда горизонтально, 2: всегда перпендикулярно осям, 3: всегда вертикально. Выберем вариант, при котором подписи всегда горизонтальны: barplot(okr$ХимЭкспорт, names.arg = okr$Регион, horiz=TRUE, las = 1) В данном случае очень массивные названия федеральных не умещаются в пространство графика. Можно было бы вполне убрать словосочетание “федеральный округ”. Для этого используем уже знакомую нам sub(). names &lt;- sub(&quot;федеральный округ&quot;, &quot;&quot;, okr$Регион) # &quot;&quot; - означает пустая строка barplot(okr$ХимЭкспорт, names.arg = names, horiz = TRUE, las = 1) И снова содержимое не поместилось в поле графика. Проблема в том, что вокруг любого графика резервируются поля ограниченного размера для размещения подписей координат и т.д. Автоматически эти поля не пересчитываются, зарезервировать их — ваша задача. Наберите в консоли ?par. Откроется список всевозможных графических параметров, которые управляют компоновкой и порядком построения графиков. Эти параметры можно установить, вызвав функцию par(). Все дальнейшие вызовы инструкций построения графиков будут учитывать установленные параметры Пролистайте страницу справки вниз и найдите параметр mar = — он отвечает за установку полей в условных единицах. Есть также параметр mai =, который позволяет установить поля графика в дюймах. Обратите внимание на то, что означают параметры этой функции: # mar=c(bottom, left, top, right) # The default is c(5, 4, 4, 2) + 0.1. Поскольку в нашем примере проблемы возникают в левым полем, необходимо увеличить второй параметр. margins.default &lt;- par(&quot;mar&quot;) # запишем текущее значение, чтобы восстановить его потом par(mar = c(5, 10, 4, 2)) # увеличим поле left до 10 условных единиц barplot(okr$ХимЭкспорт, names.arg = names, horiz=TRUE, las = 1) Добавим заголовок с помощью параметра main =, а подпись единиц измерения по оси \\(X\\) — с помощью параметра xlab =. Поскольку количество параметров функции уже достаточно велико, введем каждый из них с новой строчки, чтобы улучшить читаемость кода: barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1) # Чтобы увеличить диапазон оси X, можно использовать параметр xlim = c(min, max): barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0,12000)) Работа с цветом на столбчатых диаграммах рассмотрена ниже в отдельном разделе. 5.4 Круговые (секторные) диаграммы Круговые диаграммы (англ. piechart) строятся с помощью функции pie(): par(mar = c(5, 5, 5, 5)) # установим поля pie(okr$ХимЭкспорт) # вместо номеров можно использовать подписи секторов, добавив второй параметр: pie(okr$ХимЭкспорт, names) # в каждую метку можно добавить процент данного округа в общей массе. Для этого его нужно сначала посчитать: percentage &lt;- 100 * okr$ХимЭкспорт / sum(okr$ХимЭкспорт) # и округлить до 1 знака после запятой: percentage &lt;- round(percentage, digits = 1) Можно присоединить проценты к названиям округов, добавив обрамляющие скобки. Чтобы функция paste не добавляля пробелы между присоединяемыми строками, необходимо задать параметр sep = , передав ему пустую строку — “”: names2&lt;-paste(names, &quot; (&quot;, percentage, &quot;%)&quot;, sep = &quot;&quot;) # Используем для аннотирования круговых секторов: pie(okr$ХимЭкспорт, names2) # Добавить заголовок можно также с помощью параметра main = pie(okr$ХимЭкспорт, names2, main = &quot;Доля федеральных округов в экспорте продукции химической промышленности&quot;) Чтобы перенести часть заголовка на вторую строку, вы можете использовать управляющий символ перевода строки \\n, вставив его в требуемое место: pie(okr$ХимЭкспорт, names2, main = &quot;Доля федеральных округов в экспорте \\n продукции химической промышленности&quot;) Управляющие символы играют большое значение в программировании и используются для управления поведением текстового вывода. Нотация \\n называется escape-последовательностью. Помимо перевода строки, есть и другие полезные управляющие символы. Кстати, именно из-за того, что escape-последовательности начинаются с обратной косой черты (\\), при указании системных путей в функции setwd() всегда следует использовать прямую косую черту (/). Например, следующий путь не будет найдет, поскольку он содержит управляющие последовательности \\n и \\t: C:\\data\\tables\\new. Наконец, при использовании секторных диаграмм важно уметь менять порядок секторов. По умолчанию сектора откладываются против часовой стрелки начиная с восточного направления. Чтобы сектора откладывались по часовой стрелке с северного направления, следует задать параметр clockwise = TRUE. pie(okr$ХимЭкспорт, names2, main = &quot;Доля федеральных округов в экспорте \\n продукции химической промышленности&quot;, clockwise = TRUE) Работа с цветом на круговых диаграммах рассмотрена ниже в отдельном разделе. 5.5 Цвет и прозрачность Цвет — одно из основных графических средств, используемых на графиках и диаграммах, поэтому данная тема рассмотрена более подробно в отдельном разделе. Определить цвет можно различными способами. Во-первых, в R есть палитра предопределенных цветов, которые можно выбирать по их названию). Список называний цветов можно посмотреть, вызвав функцию colors(): head(colors()) ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; &quot;antiquewhite1&quot; ## [5] &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; Основной цвет любого графика или диграмма задается параметром col =. Это цвет (или цвета) с помощью которых будут отображаться данные. Попробуем изменить цвет графика с серого на пастельно-синий: par(mar = c(5, 10, 4, 2)) # увеличим поле left до 10 условных единиц barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0,12000), col = &quot;steelblue&quot;) Помимо этого вы можете задать цвет с помощью цветовых компонент в различных пространствах. Для этого вы должны быть знакомы с основами теории цвета (посмотрите презентацию UsingColorInR.pdf. Например, фиолетовый цвет в пространстве RGB можно задать с помощью функции rgb(), смешав синюю и красную компоненты: violet = rgb(0.4, 0, 0.6) barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0,12000), col = violet) Чтобы сделать цвет полупрозрачным, есть две возможности: При создании нового цвета — передать в функцию rgb() дополнительный параметр alpha =, который задает долю прозрачности в диапазоне от 0 до 1. При модификации существующего цвета — вызвать функцию adjustcolor() с параметром alpha = Например: violet.transp = adjustcolor(violet, alpha = 0.5) barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0,12000), col = violet.transp) green.transp = rgb(0, 1, 0, 0.5) # появился четвертый параметр barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0,12000), col = green.transp) Функция adjustcolor() позволяет модифицировать все компоненты цвета, не только прозрачность. На графике типа barplot вы имеете фактически несколько переменных, которые представлены столбиками. А это означает что для них можно использовать различные цвета. Вы можете передать в параметр col = вектор из цветов, соответствующих столбикам: colors &lt;- c(&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;pink&quot;, &quot;white&quot;,&quot;black&quot;) barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0,12000), col = colors) На самом деле, такой винегрет из цветов на столбчатых диаграммах использовать не принято. Но вы должны понимать, что при необходимости можно поменять цвет отдельно выбранных столбиков. Например, мы можем показать красным цветом Wентральный и Приволжский округа, которые являются лидерами по экспорту продукции химической промышленности: colors &lt;- rep(&quot;gray&quot;, 8) # сделаем 8 серых цветов colors[2] &lt;- &quot;red&quot; colors[7] &lt;- &quot;red&quot; barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0,12000), col = colors) Еще одна интересная особенность использования цвета заключается в том, что количество указанных цветом может не совпадать с количеством рядов данных. Вы можете указать 2 или 3 цвета, и они будут циклически повторяться при визуализации данных: colors&lt;-c(&quot;gray&quot;,&quot;steelblue&quot;) barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz =TRUE, las = 1, xlim = c(0, 12000), col = colors) Наконец, вещь, которой совершенно необходимо уметь пользоваться при работе с цветом в R — это цветовые палитры. Палитры чрезвычайно удобны, когда необходимо сгенерировать множество цветов, зная лишь основные оттенки. Для этого нужно создать палитру, используя функцию colorRampPalette(): # задаем 2 опорных цвета: черный белый palet&lt;-colorRampPalette(c(&quot;black&quot;,&quot;white&quot;)) # и автоматически генерируем 8 цветов между ними: colors&lt;-palet(8) # используем их для отображения: barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz = TRUE, las = 1, xlim = c(0, 12000), col= colors) # вы можете включить в палитру произвольное количество цветов: palet&lt;-colorRampPalette(c(&quot;steelblue&quot;,&quot;white&quot;,&quot;purple4&quot;)) colors&lt;-palet(8) barplot(okr$ХимЭкспорт, names.arg = names, main = &quot;Экспорт продукции химической промышленности&quot;, xlab = &quot;млн долл. США&quot;, horiz=TRUE, las = 1, xlim = c(0, 12000), col= colors) В R cуществует множество стандартных палитр, их список можно найти в справке и документации. Наиболее полезные из них: colors() gray() rainbow() heat.colors() topo.colors() terrain.colors() Напрмер, вы можете изменить цвета диаграммы, взяв их из одной из палитр или выбрав случайным образом из полной палитры цветов, используя функцию sample(): pie(okr$ХимЭкспорт, names2, main = &quot;Доля федеральных округов в экспорте \\n продукции химической промышленности&quot;, col=rainbow(length(names2))) pie(okr$ХимЭкспорт, names2, main = &quot;Доля федеральных округов в экспорте \\n продукции химической промышленности&quot;, col=sample(colors(),5)) Более богатый набор палитр можно найти в библиотеке RColorBrewer, которая представляет собой интерпретацию палитр, доступных на сайте colorbrewer2.org library(RColorBrewer) # Откроем библиотеку RColorBrewer: display.brewer.all() # Посмотрим, какие в ней имеются палитры К каждой из этих палитр можно обратиться по названию с помощью функции brewer.pal(). Поскольку нам необходимы цвета для категориальных данных, следует использовать палитры из средней части (Set3 - Accent) # выберем цвета из палитры Set2 по количеству секторов в круге: colors &lt;- brewer.pal(length(names2),&quot;Set1&quot;) # И используем их при визуализации par(mar = c(5, 5, 5, 5)) # установим поля pie(okr$ХимЭкспорт, names2, main = &quot;Доля федеральных округов в экспорте \\n продукции химической промышленности&quot;, col=colors) # Попробуем палитру Accent: pie(okr$ХимЭкспорт, names2, main = &quot;Доля федеральных округов в экспорте \\n продукции химической промышленности&quot;, col=brewer.pal(length(names2),&quot;Accent&quot;)) 5.6 Настройки отображения 5.6.1 Графические параметры Изменять размеры элементов графика можно независимо друг от друга, используя следующие параметры: cex — общий масштаб элементов на графике cex.axis — масштаб подписей координат на оси cex.lab — масштаб подписей названий осей cex.main — масштаб заголовка графика cex.sub — масштаб подзаголовка графика cex.names — масштаб подписей факторов (для некоторых типов диаграмм) Например: plot(tab$Год, tab$Каспийское, pch=20, type=&quot;o&quot;, ylim = c(0,12), col=&quot;red3&quot;, main=&quot;Объем сброса загрязненных сточных вод&quot;, xlab=&quot;Год&quot;, ylab=&quot;млрд.куб.м&quot;, cex.axis=0.8, cex.lab=0.7, cex.main=0.9, cex = 0.8) points(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;,cex = 0.8) lines(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) points(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;,cex = 0.8) lines(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;) Аналогично происходит тонкая настройка цвета: col цвет графика col.axis цвет подписей координат col.lab цвет названий осей col.main цвет заголовка col.sub цвет подзаголовка fg цвет элементов переднего плана (оси, рамка и т.д.) bg цвет фона графика (background) plot(tab$Год, tab$Каспийское, pch=20, type=&quot;o&quot;, ylim = c(0,12), col=&quot;red3&quot;, main=&quot;Объем сброса загрязненных сточных вод&quot;, xlab=&quot;Год&quot;, ylab=&quot;млрд.куб.м&quot;, cex.axis=0.8, cex.lab=0.7, cex.main=0.9, col.lab = &quot;grey50&quot;, fg = &quot;grey40&quot;) points(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) lines(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) points(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;) lines(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;) 5.6.2 Разметка осей, рамка, сетка координат и произвольные линии По умолчанию R подбирает оптимальный с точки зрения него шаг разметки осей, в зависимости от разброса значений по осям \\(X\\) и \\(Y\\), а также размеров графического устройства, на котором производится рисование. Изменяя размер окна прорисовки, вы получите различную разметку осей. В то же время, часто возникает желание (или необходимость) самостоятельно управлять шагом разметки сетки. Для этого необходимо: Вызвать функцию plot(), передав ей дополнительно параметр axes = FALSE (убирает при рисовании обе оси) или один из параметров xaxt=&quot;n&quot; / yaxt=&quot;n&quot; (убирают оси \\(X\\) и \\(Y\\) соответственно) Вызвать столько раз функцию axis(), сколько вы хотите нарисовать осей, передав ей параметры для рисования каждой оси. Функция axis() принимает следующие параметры: side — сторона графика, на которой будет нарисована ось (1=bottom, 2=left, 3=top, 4=right) at — вектор значений, в которых должны быть нарисованы метки оси labels — вектор подписей, которые будут нарисованы в местоположениях, указанных в параметре at. Этот параметр можно пропустить, если подписи совпадают с местоположениями меток pos — координата, вдоль которой будет нарисована ось lty — тип линии col — цвет линии и меток las — расположение подписей параллельно (\\(0\\)) или перпендикулярно (\\(2\\)) оси tck — длина метки относительно размера графика. Отрицательные значения дают метки, выходящие за пределы графика. положительные — внутрь графика. \\(0\\) убирает метки, \\(1\\) рисует линии сетки. При ручном построении осей полезно сразу же нарисовать рамку вокруг графика, используя функцию box(). Например: plot(tab$Год, tab$Каспийское, type = &quot;l&quot;, axes = FALSE) axis(side = 1, at = seq(min(tab$Год), max(tab$Год), 1), tck = -0.02, labels = FALSE) # разметим ось X через 1 год, но рисовать подписи не будем axis(side = 1, at = seq(min(tab$Год), max(tab$Год), 3), # а подписи расставим через 3 года tck = 0) # но рисовать метки не будем # разметим ось Y через 1 млрд куб. м., округлив предварительно минимальное и максимальное значение до ближайшего целого снизу и сверху соответственно axis(side = 2, at = seq(floor(min(tab$Каспийское)), ceiling(max(tab$Каспийское)), 1), tck = -0.02) box() # добавим рамку для красоты Для размещения сетки координат существует функция grid(nx = NULL, ny = nx, col = &quot;lightgray&quot;, lty = &quot;dotted&quot;, lwd = par(&quot;lwd&quot;), equilogs = TRUE). Как видно из набора ее параметров, сетка определяется количеством линий в горизонтальном и вертикальном направлении. Это не всегда бывает удобно, поскольку как правило мы хотим задать шаг сетки конкретной величины. По умолчанию, однако, линии сетки выбираются автоматически, как и метки: plot(tab$Год, tab$Каспийское, type = &quot;l&quot;, col = &quot;red&quot;) grid() Вы, разумеется, можете поменять их количество, однако R не будет за вас согласовывать шаг сетки и шаг меток осей, поскольку метки генерируются на стадии рисования plot() или axis() и не запоминаются. plot(tab$Год, tab$Каспийское, type = &quot;l&quot;, col = &quot;red&quot;) grid(10, 5) Функция grid() на самом деле является оберткой функции abline(), которая позволяет рисовать произвольные линии на графике. Данна функция предоставляет следующие возможности построения линий и серий линий: a, b — коэффициенты уравнения \\(y = ax + b\\). Таким образом можно определить только одну линию. coef — принимает вектор из двух значений, которые интерпретируются как a и b. То есть, это альтернативная форма записи предыдущего случая. h — значение (значения) координат \\(y\\) для горизонтальной линии (серии горизонтальных линий). То есть, вы можете передать в этот параметр как одиночное значение, так и вектор значений. В зависимости это этого нарисуется одна горизонтальная линия или серия горизонтальных линий. v — значение (значения) координат \\(x\\) для вертикальной линии (серии веритикальных линий). Работает аналогично параметру h. reg — сюда можно передать объект, обладающий методом coef(). Этот способ можно использовать для рисования линий регрессии. Предположим теперь, что вы хотите нарисовать сетку с шагом в 1 год по горизонтальной оси и шагом 1 млрд. куб. м по оси вертикальной. При этом вы также хотите, чтобы линии сетки располагались под графиком, а не поверх его. Также необходимо выделить особым цветом значение в 10 млрд м\\(^3\\) по оси \\(Y\\). Для этого выполним следующую последовательность действий: plot(tab$Год, tab$Каспийское, type=&quot;n&quot;) # режим &#39;n&#39; позволяет ничего не рисовать, но заложить поле графика в соответствии с данными, указанными в параметрах x и y # Вычисляем линии сетки xlines &lt;- seq(min(tab$Год), max(tab$Год), 1) ylines &lt;- seq(ceiling(min(tab$Каспийское)), floor(max(tab$Каспийское)), 1) # Рисуем линии сетки abline(h = ylines, v = xlines, col = &quot;lightgray&quot;) # Рисуем график lines(tab$Год, tab$Каспийское, col=&quot;red3&quot;) points(tab$Год, tab$Каспийское, pch = 20, col=&quot;red3&quot;) # Выделяем значение 10 по оси Y: abline(h = 10, col = &quot;blue&quot;, lwd = 2) # Рисуем дополнительно рамку, т.к. сетку координат мы рисовали после графика box() 5.6.3 Аннотации данных (текст на графике) Аннотации данных добавляются на график с помощью функции text(). В качестве трех обязательных аргументов ей необходимо передать координаты точек размещения текста, и вектор подписей. Также полезным будет указать параметр pos=, отвечающий за размещение аннотации относительно точки. Значения pos, равные 1, 2, 3 и 4, соответствуют размещению снизу, слева, сверху и справа от точки: text(tab$Год, tab$Каспийское, labels = tab$Каспийское, cex = 0.75, pos = 3) К сожалению, стандартный механизм размещения аннотаций пакета graphics не обладает возможностью устранения конфликтов подписей. Однако это возможно для графиков, построенных с помощью библиотек lattice и ggplot2. Для этого можно воспользоваться пакетом directlabels или ggrepel. 5.7 Легенда Легенда к графику размещается с помощью функции legend(). Эта функция принимает несколько аргументов, включая: местоположение, заголовок, названия элементов, графические параметры. Местоположение может быть задано координатами \\((x,y)\\) в системе координат графика, но удобнее пользоваться следующими предопределенными константами: &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot;, &quot;center&quot;. Чтобы в легенде появились точки, необходимо задать параметр pch=. Для линейной легенды, следует задать, соответственно, параметр lty = и/или lwd =. Каждый из этих параметров должен быть вектором по количеству элементов легенды: par(mar = margins.default) # Найдем ограничивающий прямоугольник вокруг всех рядов данных xrange = range(tab$Год) yrange = range(tab$Каспийское, tab$Карское, tab$Азовское) # Построим пустой график с разметкой осей и всеми заголовками plot(xrange, yrange, type=&quot;n&quot;, main=&quot;Объем сброса загрязненных сточных вод&quot;, xlab=&quot;Год&quot;, ylab=&quot;млрд.куб.м&quot;, cex.axis=0.8, cex.lab=0.7, cex.main=0.9, col.lab = &quot;grey50&quot;, fg = &quot;grey40&quot;) # Добавим на график сетку координат grid() # Добавим на график данные points(tab$Год, tab$Каспийское, pch=20, col=&quot;red3&quot;) lines(tab$Год, tab$Каспийское, pch=20, col=&quot;red3&quot;) points(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) lines(tab$Год, tab$Карское, pch=20, col=&quot;forestgreen&quot;) points(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;) lines(tab$Год, tab$Азовское, pch=20, col=&quot;steelblue&quot;) # Определим положение, названия и цвета: main &lt;- &quot;Море&quot; location &lt;- &quot;topright&quot; labels &lt;- c(&quot;Каспийское&quot;, &quot;Карское&quot;, &quot;Азовское&quot;) colors &lt;- c(&quot;red3&quot;, &quot;forestgreen&quot;, &quot;steelblue&quot;) # Если цвет передать в параметр fill, то по умолчанию # нарисуются цветовые плашки: legend(location, labels, title = main, fill=colors) pts &lt;- c(20, 20, 20) # каждый элемент показывается точкой типа 20 lns &lt;- c(1, 1, 1) # каждый элемент показывается линией толщиной 1 # теперь посмотрим на легенду (она нарисуется поверх старой) legend(location, labels, title = main, col = colors, pch = pts, lwd = lns) Более подробно с разнообразными опциями размещения легенды на графике вы можете познакомиться, набрав в консоли команду ?legend. 5.8 Контрольные вопросы и задачи 5.8.1 Вопросы Какая функция базового пакета R отвечает за построение стандартных графиков (диаграмм рассеяния, линейных)? Какие функции стандартной библиотеки R позволяют построить: столбчатые диаграммы, круговые секторные диграммы, гистограммы? Как задать интервал или количество интервалов гистограммы? Можно ли разместить столбчатую диаграмму горизонтально? Если да, то как? Какая функция отвечает за установку параметров графической подсистемы? Как установить поля вокруг графиков? Как развернуть подписи на столбчатой диаграмме перпендикулярно оси? Как установить запрет на экспоненциальное представление больших чисел при рисовании графиков? Какой параметр отвечает за установку цвета в функциях построения графиков стандартной библиотеки R? Какие параметры отвечают за установку толщины и типа линии на графиках? Какие параметры отвечают за установку размера и типа значка на диаграммах рассеяния? Как совместить несколько графиков на одной сетке координат? Какая функция рисует рамку вокруг графика? Какая функция отвечат за рисование сетки координат? Как установить равный масштаб по осям графика? Какие параметры позволяют масштабировать текст элементов графика, таких как подписи координат, осей, заголовков и подзаголовков? Назовите способы задания цвета в R. Как сделать цвет в R полупрозрачным? Назовите стандартные цветовые палитры R. Как сгенерировать последовательность из нужного количества цветов между заданными опорными цветами? Какая функция повзоляет разместить легенду на графике? Как сделать так, чтобы в легенде показывались точки? Линии? Цветовые плашки? 5.8.2 Задачи Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "],
["advgraphics.html", "Глава 6 Продвинутая графика в R", " Глава 6 Продвинутая графика в R Программный код главы Раздел посвящен продвинутой графике в R с использованием системы grid и грамматик. [To be written…] "],
["stat-analysis.html", "Глава 7 Основы статистического анализа", " Глава 7 Основы статистического анализа Программный код главы Раздел посвящен базовым возможностям статистического анализа в R. [To be written…] "],
["circular.html", "Глава 8 Круговая статистика и визуализация 8.1 Введение 8.2 Вычисление статистических моментов 8.3 Определение модальных направлений 8.4 Визуализация круговой статистики", " Глава 8 Круговая статистика и визуализация Программный код главы 8.1 Введение В географии направления играют огромную роль. Ветер, морские течения, тектоника плит, миграция элементов в ландшафтно-геохимических катенах, миграции населения, перелеты птиц — все эти явления характеризуются прежде всего их направлением. Для того, чтобы эффективно анализировать такие данные, необходимо владеть специализированным математическим аппаратом. Обработкой данных о направлениях занимается особая область математической статистики — статистика направлений, или круговая (циркулярная) статистика (Mardia, Jupp, 2000; Pewsey et al., 2013). В круговой статистике каждое направление \\(\\theta\\) представляется в виде вектора \\(x = (\\cos \\theta, sin \\theta)\\). Все операции производятся над подобными векторами и их координатами. Аналогом нормального распределения для круговой случайной величины является распределение фон Мизеса (von Mises, 1918), которое задается функцией плотности вероятности: \\[ f(θ)=\\frac{1}{2 \\pi I_0(\\kappa)} e^{\\kappa \\cos (\\theta - \\mu)}, \\] где \\(\\kappa \\geq 0\\) — параметр концентрации, \\(\\mu\\) — среднее значение (для \\(\\kappa &gt; 0\\)) и \\[ I_p(\\kappa) = \\frac{1}{2π} \\int_{0}^{2\\pi} \\cos (p \\theta) e^{\\kappa \\cos θ} d \\theta \\] есть модифицированная функция Бесселя первого рода и порядка \\(p\\). Из формул видно, что по своему эффекту параметр концентрации противоположен среднеквадратическому отклонению \\(\\sigma\\), которое является параметром нормального распределения. Чем больше значение \\(\\kappa\\), тем более сконцентрировано распределение относительно среднего значения — отсюда идет название этого параметра. Распределение фон Мизеса можно использовать при вычислении основных направлений методом ядерной оценки плотности распределения (оценки по методу Парзена-Розенблатта. 8.2 Вычисление статистических моментов Для вычисления статистических моментов круговой случайной величины требуется найти средний равнодействующий вектор первого порядка \\(R = (C, S)\\), где \\(C = \\frac{1}{n} \\sum_{j=1}^{n} \\cos \\theta_j\\), \\(S = \\frac{1}{n} \\sum_{j=1}^{n} \\sin \\theta_j\\). Данный вектор имеет направление \\(\\bar\\theta\\), которое является выборочным средним направлением исследуемой величины. Выборочная средняя равнодействующая длина \\(\\bar R = \\sqrt{C^2 + S^2}\\) принимает значения в диапазоне \\([0, 1]\\) и показывает меру концентрации направлений относительно \\(\\theta\\). \\(\\bar R = 1\\) означает, что все исходные направления совпадают, \\(\\bar R = 0\\) — что данные равномерно распределены по кругу, либо распределение имеет несколько мод, которые уравновешивают друг друга. Стандартное отклонение направлений \\(v\\) в радианах может быть найдено как \\(v=\\sqrt{-2 \\ln \\bar R}\\) (Mardia, Jupp, 2000). Величина \\(\\bar R\\) дает важную информацию для предварительной диагностики картины направлений каньонов. Если значение \\(\\bar R\\) близко к единице, это означает, что распределение является унимодальным и в качестве основного направления можно принять значение \\(\\bar θ\\). На практике, однако, такая ситуация в городах достаточно редка, поскольку для каждого выбранного участка характерно как минимум две моды направлений каньонов, что требует их явного выделения статистическими методами. Данные о направлениях каньонов специфичны, поскольку противоположные направления эквивалентны. Такие данные в теории круговой статистики называются аксиальными (Mardia, Jupp, 2000). Для аксиальных данных возможный диапазон значений лежит в интервале \\([0, \\pi)\\). Поскольку методы круговой статистики рассчитаны на круговое замыкание данных, стандартный подход к обработке аксиальных данных предполагает переход от направлений к их удвоенным значениям \\(\\theta&#39; = 2\\theta\\), обработку полученных значений стандартными методами и отображение полученных значение обратно на интервал \\([0, \\pi)\\). Для среднего, медианы и моды распределения это означает простое деление полученного значения пополам (Pewsey et al., 2013). 8.3 Определение модальных направлений Модальные направления могут быть определены как по гистограмме распределения, так и методом ядерной оценки. Основной вопрос поиска эффективного ядра заключается в параметризации функции \\(K\\). Для распределения фон Мизеса таким параметром является концентрация \\(\\kappa\\). Чем больше этот параметр, тем более локализованной будет оценка, тем сильнее будут проявляться в ней существующие моды распределения, но также будут и выделяться новые моды, которые на самом деле не значимы. Малые значения \\(\\kappa\\) приведут, наоборот, к «размыванию» плотности распределения в пределах полного круга. Как и в случае с количеством интервалов гистограммы, избыточно малые и большие значения κ нежелательны. Показано, что оптимальное значение κ может быть подобрано также для оценки распределений, являющихся конечной суммой \\(M\\) распределений фон Мизеса, то есть, мультимодальных распределений, имеющих плотность (Oliveira et al., 2012): \\[ g(\\theta)=\\sum_{i=1}^{M} \\alpha_i \\frac{\\exp\\lbrace{\\kappa_i \\cos(\\theta - \\mu_i)\\rbrace}}{2 \\pi I_0 (\\kappa_i)}, \\] где \\(\\sum_{i=1}^{M} = 1\\). Поскольку в результате подбора определяется не только параметр концентрации, но и число компонент в сумме распределений (Oliveira et al., 2014), его можно также использовать для определения количества искомых мод, если это необходимо. Когда подобрана функция ядра и ее параметры, оценка плотности распределения (вычисление функции \\(\\circ f _h (x)\\)) для круговых данных делается либо для исходных направлений \\(\\theta_j\\), либо с равным (достаточно малым) интервалом — например, через 1 градус (Pewsey et al., 2013). После того как произведена оценка, для решения нашей задачи могут быть выбраны направления, в которых функция плотности распределения достигает локального максимума — первого и второго по величине. Эти направления и будут соответствовать первой и второй моде распределения направлений городских каньонов. 8.4 Визуализация круговой статистики "],
["spatial-data.html", "Глава 9 Пространственные данные в R 9.1 Модели пространственных данных 9.2 Пространственная привязка 9.3 Векторные данные 9.4 Растровые данные", " Глава 9 Пространственные данные в R Программный код главы Необходимые пакеты: sf, raster, dplyr Данный модуль посвящен введению в работу с пространственными данными в R. Рассмотрены общие вопросы моделирования реального мира средствами моделей пространственных данных. Рассматривается чтение векторных и растровых данных, их визуализация стандартными средствами. 9.1 Модели пространственных данных Пространственные данные — это данные о пространственных объектах и их наборах. В свою очередь, пространственный объект определяется как цифровая модель материального или абстрактного объекта реального или виртуального мира с указанием его идентификатора, координатных и атрибутивных данных.3 Если говорить по сути, то пространственные данные можно определить как данные о географических объектах или явлениях, фиксирующие их местоположение и/или распределение в системе координат, привязанной к телу Земли или любого другого небесного тела. Таким образом, отличительной особенностью пространственных данных перед непространственными является координатное описание местоположения. Важно знать отличия между векторной и растровой моделью пространственных данных. Векторная модель пространственных данных включает описание координатных данных пространственных объектов и, возможно, топологических отношений между ними. Векторные данные фиксируют местоположение и форму объектов в виде геометрических примитивов, таких как точки, линии, полигоны, объемные тела. Выбор модели объекта (например, представить город точкой или полигоном) зависит от масштаба анализа и целей исследования. Векторная модель данных является объектно-ориентированной. Растровая модель описывает не объекты, а пространственное распределение некоторой (выбранной исследователем) характеристики. Пространство разбивается регулярной сеткой ячеек, в каждой ячейке фиксируется значение исследуемого параметра (путем статистического осреднения, семплирования в центре ячейки и т.п.). Растровые данные могут быть как количественными (например, поле температуры), так и качественными (например, растр классифицированного снимка, каждая ячейка которого фиксирует принадлежность к тому или иному типу объекта). Таким образом, растровая модель является пространственно-ориентированной (или феномен-ориентированной). Существуют и другие модели пространственных данных, однако их рассмотрение выходит за рамки настоящей лекции. В настоящей лекции мы познакомимся с чтением и визуализацией пространственных данных в векторном и растровом формате, а также рассмотрим вопросы связанные с использованием картографических проекций. 9.1.1 Векторные данные Simple Features (официально Simple Features Access) — это стандарт OGC 06-103, разработанный Open Geospatial Consortium (OGC) и реализованный также в виде международного стандарта ISO 19125, который определяет общую модель хранения и доступа к векторным объектам (точка, линия, многоугольник, мульти точечные, мультилинии и т. д.), в географических информационных системах. Геометрическое представление пространственных объектов базируется на следующих принципах: Все геометрии состоят из точек. Точки являются координатами в 2-, 3- или 4-мерном пространстве. Все точки в геометрии имеют одинаковую размерность. В дополнение к координатам \\(X\\) и \\(Y\\) имеются два дополнительных дополнительных параметра: координата \\(Z\\), обозначающая высоту координата \\(M\\), обозначающая некоторую меру, связанную с точкой, а не с признаком в целом (в этом случае это будет атрибут объекта). Измерение \\(M\\) может быть использовано, например, для представления времени или линейных координат (для маршрутов). Координаты простой геометрии всегда содержат компоненты \\(X\\) и \\(Y\\), поэтому все разнообразие возможных представлений определяется наличием или отсутствием дополнительных измерений \\(Z\\) и \\(M\\) Таким образом, получаем четыре варианта геометрии: двумерные точки \\(XY\\) трехмерные точки \\(XYZ\\) трехмерные точки \\(XYM\\) четырехмерные точки \\(XYZM\\) В случае использования широт и долгот \\(X\\) соответствует долготе, \\(Y\\) соответствует широте. Всего стандарт Simple Features включает в себя 17 типов геометрий. Из них наиболее употребительными являются следующие 7: Тип Описание POINT нуль-мерная геометрия, содержащая одну точку LINESTRING последовательность точек, соединенных прямыми, несамопересекающимися отрезками; одномерная геометрия POLYGON геометрия с положительной площадью (двумерная); последовательность точек, отрезки между которыми формируют замкнутое кольцо без самопересечений; первое кольцо является внешним, ноль и более остальных колец представляют дырки внетри полигона MULTIPOINT множество точек; геометрия типа MULTIPOINT называется простой если ни одна пара точек в MULTIPOINT не совпадает MULTILINESTRING множество линий MULTIPOLYGON множество полигонов GEOMETRYCOLLECTION множество геометрий произвольного типа за исключением GEOMETRYCOLLECTION Примеры различных видов геометрий представлены на рисунке ниже: ## Linking to GEOS 3.6.1, GDAL 2.1.3, proj.4 4.9.3 Оставшиеся виды геометрий Simple Features включают: CIRCULARSTRING, COMPOUNDCURVE, CURVEPOLYGON, MULTICURVE, MULTISURFACE, CURVE, SURFACE, POLYHEDRALSURFACE, TIN, TRIANGLE. Существует два официально закрепленных формата представления SF: Well-Known Text (WKT) и Well-Known Binary (WKB), которые необходимы для чтения таких данных человеком и машиной соответственно. Well-Known Text (WKT) — стандарт представления геометрии в виде множества списков координат, в которых координаты вершин разделены пробелами, вершины разделены запятыми, а компоненты полигонов и мультигеометрий заключены в круглые скобки и также разделены запятыми. Вышеприведенной картинке соответствуют следующие строки WKT: ## MULTIPOINT (3.2 4, 3 4.6, 3.8 4.4, 3.5 3.8, 3.4 3.6, 3.9 4.5) ## LINESTRING (0 3, 0 4, 1 5, 2 5) ## MULTILINESTRING ((0 3, 0 4, 1 5, 2 5), (0.2 3, 0.2 4, 1 4.8, 2 4.8), (0 4.4, 0.6 5)) ## POLYGON ((0 0, 1 0, 3 2, 2 4, 1 4, 0 0), (1 1, 1 2, 2 2, 1 1)) ## MULTIPOLYGON (((0 0, 1 0, 3 2, 2 4, 1 4, 0 0), (1 1, 1 2, 2 2, 1 1)), ((3 0, 4 0, 4 1, 3 1, 3 0), (3.3 0.3, 3.3 0.8, 3.8 0.8, 3.8 0.3, 3.3 0.3)), ((3 3, 4 2, 4 3, 3 3))) ## GEOMETRYCOLLECTION (MULTIPOINT (3.2 4, 3 4.6, 3.8 4.4, 3.5 3.8, 3.4 3.6, 3.9 4.5), MULTIPOLYGON (((0 0, 1 0, 3 2, 2 4, 1 4, 0 0), (1 1, 1 2, 2 2, 1 1)), ((3 0, 4 0, 4 1, 3 1, 3 0), (3.3 0.3, 3.3 0.8, 3.8 0.8, 3.8 0.3, 3.3 0.3)), ((3 3, 4 2, 4 3, 3 3))), LINESTRING (0 3, 0 4, 1 5, 2 5)) Well-Known Binary (WKB) — бинарный формат хранения координат. Именно этот формат фактически используется в базах данных, поскольку он обеспечивает высокую скорость чтения и записи данных (в отлиие от текстового). Однако внешний вид данных в формате WKB мало о чем говорит человеку, поскольку он предназначен для чтения компьютером. Например, вышеприведенная строка LINESTRING будет выглядеть так: ## 01 02 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 10 40 00 00 00 00 00 00 f0 3f 00 00 00 00 00 00 14 40 00 00 00 00 00 00 00 40 00 00 00 00 00 00 14 40 9.1.2 Растровые данные Растр представляет из себя матрицу значений. Каждой ячейке матрицы соответствует прямоугольная пространственная область фиксированного размера, которая называется пикселом. Различают растры непрерывные и категориальные (классифицированные). Также необходимо разделять одноканальные и многоканальные растры. Примером одноканального растра является цифровая модель рельфа. В виде многоканальных растров часто представляют космические снимки. В отличие от векторных данных, которые требут указания координат для каждой вершины, регулярно-ячеистый характер растровой модели позволяет вычислять координаты пикселов на основе их индексов. Поэтому фактически растровые данные хранятся в виде линейно упорядоченного списка значений (raster values) и описания геометрии растра (raster geometry). Геометрия растра определяет, где именно располагаются в пространстве пикселы растра и может быть описана путем указания следующих компонент4: Параметр Назначение NCOLS Количество столбцов NROWS Количество строк XLLCENTER Координата \\(X\\) центра левой нижней ячейки растра YLLCENTER Координата \\(Y\\) центра левой нижней ячейки растра CELLSIZE Размер ячейки Иногда вместо параметров XLLCENTER/YLLCENTER указываются XLLCORNER/YLLCORNER, которые кодируют координаты левого нижнего угла, а не центра левой нижней ячейки растра. Выбор одного из двух этих вариантов определяет тип регистрации растра, а их значения указывают, в какое именно место необходимо “посадить” растр, чтобы его ячейки заняли соответствующие им области в системе координат. Если геометрия растра характеризуется анизотропией, то вместо одного значения CELLSIZE могут быть указаны разные размеры ячеек по осям координат CELLSIZEX и CELLSIZEY. В отличие от векторной модели, которая позволяет хранить данные только о нужных географических локациях, растровая модель такой свободы не предоставляет. Матрица ячеек растра всегда покрывает область данных целиком, и за простоту растровой структуры приходится расплачиваться ее неэкономичностью. Поскольку часто данные имеются не на всю территорию, возникает необходимость кодирования ячеек, для которых данные не известны, специальным числом (назовем его условно NODATA_VALUE). Значение этого числа хранится в метаданных растра и позволяет интерпретировать соответствующие ячейки как пустые. 9.2 Пространственная привязка 9.2.1 Компоненты пространственной привязки Пространственная привязка (spatial reference или georeference) — важнейшая составляющая пространственных данных, которая говорит нам о том, как правильно интерпретировать координаты объектов. Пространственная привязка в простейшем случае включает несколько фундаментальных компонент: Эллипсоид вращения — тело, по отношению к которому вычисляются геодезические координаты точек (широты и долготы) Исходные геодезические даты (датум) — параметры положения эллипсоида в теле Земли Географическая система координат — включает датум, положение начального меридиана и единицы измерения широт и долгот Проекция — математический спопоб перехода от географических координат на эллипсоиде к плоским прямоугольным координатам карты. Плоская прямоугольная система координат — включает проекцию, ее параметры и единицы измерения координат. Если точки имеют также координаты \\(Z\\), то для их правильной интерпретации необходимы дополнительные компоненты пространственной привязки: Система счета высот (геодезические, нормальные, ортометрические) - определяют содержательный смысл и порядок вычисления высот и глубин (координата Z) Модель геоида, квазигеоида или эллипсоида — определяет поверхность, относительно которой вычисляются высоты точек. Вертикальная система координат — фактическая реализация системы счета высот относительно конкретной поверхности относимости с заданным положением нулевого уровня. Например, в России это Балтийская система нормальных высот с нулем в г. Кронштадт. Аналогичным образом требуется введение системы счета дополнительных координат \\(M\\), если они используются в представлении координат. 9.2.2 Форматы описания пространственной привязки Существует три распространенных способа задания (хранения) пространственной привязки: PROJ.4 String — представление в виде строки. WKT (Well-Known Text) — представление в виде иерархического списка. EPSG (European Petroleum Survey Group) — представление в виде числового кода. Для поиска проекций в перечисленных форматах представления удобно воспользоваться порталом spatialreference.org. PROJ.4 String — строковый формат представления информации о пространственной привязки, используемый в библиотеке PROJ.4. Данная библиотека лежит в основе координатных систем пространственных данных, используется в R, Python, QGIS и прочих средах. Основные параметры строки: +datum Datum name (see `proj -ld`) +ellps Ellipsoid name (see `proj -le`) +lat_0 Latitude of origin +lat_1 Latitude of first standard parallel +lat_2 Latitude of second standard parallel +lat_ts Latitude of true scale +lon_0 Central meridian +proj Projection name (see `proj -l`) +units meters, US survey feet, etc. +vunits vertical units. +x_0 False easting +y_0 False northing +zone UTM zone Примеры записи координат в формате PROJ.4: Географические координаты в WGS84 (без проекции): ## +proj=longlat +datum=WGS84 +no_defs Координаты в проекции Web Mercator (проекция Google Maps, Яндекс.Карт и т.д.): ## +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs Координаты в конической равнопромежуточной проекции: ## +proj=eqdc +lat_0=0 +lon_0=0 +lat_1=60 +lat_2=60 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs Координаты в проекции UTM, зона 37: ## +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs Запись координат в формате WKT предполагает представление вышеуказанных компонент пространственной привязки к виде иерерхического списка. Например, так будет выглядеть информация о полярной стереографической проекции для карт России: PROJCS[&quot;WGS 84 / EPSG Russia Polar Stereographic&quot;, GEOGCS[&quot;WGS 84&quot;, DATUM[&quot;WGS_1984&quot;, SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563, AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]], AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]], PRIMEM[&quot;Greenwich&quot;,0, AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]], UNIT[&quot;degree&quot;,0.0174532925199433, AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]], AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]], PROJECTION[&quot;Polar_Stereographic&quot;], PARAMETER[&quot;latitude_of_origin&quot;,90], PARAMETER[&quot;central_meridian&quot;,105], PARAMETER[&quot;scale_factor&quot;,0.994], PARAMETER[&quot;false_easting&quot;,2000000], PARAMETER[&quot;false_northing&quot;,2000000], UNIT[&quot;metre&quot;,1, AUTHORITY[&quot;EPSG&quot;,&quot;9001&quot;]], AXIS[&quot;X&quot;,EAST], AXIS[&quot;Y&quot;,NORTH], AUTHORITY[&quot;EPSG&quot;,&quot;5940&quot;]] EPSG (European Petroleum Survey Group) — европейская рабочая группа нефтегазовой области, которая ведет реестр систем координат с уникальными цифровыми кодами вида EPSG:xxxxxx. Коды EPSG оказались настолько удобны, что используются повсеместно для быстрой инициализации проекций со стандартными параметрами. Например, вышеприведенные проекции имеют следующие коды EPSG: WGS84: EPSG:4326 Web Mercator: EPSG:3857 UTM: EPSG:326.. , например для UTM 37N: EPSG:32637 9.2.3 Преобразование координат Преобразование координат включает три различных операции: Трансформирование — пересчет географических координат с одного датума на другой Проецирование — переход от географических координат к плоским прямоугольным Обратное проецирование — переход от плоских координат к прямоугольным. Например, чтобы пересчитать координаты UTM в проекцию Гаусса-Крюгера, необходимо: Обратно проецировать координаты в географические WGS84 Трансформировать географические координаты c WGS84 в ГСК-2011 Проецировать координаты ГСК-2011 в проекцию Гаусса-Крюгера Несоответствие датумов часто является причиной того, что данные из разных наборов плохо совмещаются друг с другом 9.3 Векторные данные 9.3.1 Базовые библиотеки В R существует высоко развитая инфраструктура для работы с векторными данными, которая обеспечивается пакетом sf. Этот пакет появился сосвсем недавно (в 2016 году). Ранее поддержка пространственных данных обеспечивалась пакетом sp, который по прежнему активно используется, и на который “завязано” множество других библиотек. Существующая в настоящий момент инфраструктура кратко показана ниже: Архитектура программных библиотек для работы с пространственными данными в R Исторический пакет sp обеспечивал (и продолжает обеспечивать) поддержку пространственных данных в виде специальных классов данных типа Spatial, реализуя классы как для чисто геометрических объектов (SpatialPolygons), так и для пространственных объектов с атрибутами (SpatialPolygonsDataFrame). Во втором случае набор объектов имеет ассоциированную с ним таблицу атрибутов. С классами типа Spatial существут несколько проблем. Во-первых, они не являются объектами типа data.frame (не расширяют их), а являются самостоятельным классом объектов, поэтому к ним часто невозможно корректно применить стандартные операции трансформации таблиц (типа тех, что доступны в пакете dplyr). Во-вторых, объекты типа Spatial не реализуют существующие стандарты представления пространственных данных (типа Simple Features), что накладывает ограничения на их интероперабельность с современными форматами данных (например, GeoPackage). Пакет sf решает все эти проблемы. Множество функций, которые были раньше разбросаны по нескольким пакетам R (sp, rgdal, rgeos), теперь доступны в одном интерфейсе: library(sf) methods(class = &quot;sf&quot;) # Посмотрим, какие методы доступных для объектов класса sf ## [1] [ [[&lt;- $&lt;- ## [4] aggregate as.data.frame cbind ## [7] coerce dbDataType dbWriteTable ## [10] identify initialize merge ## [13] plot print rbind ## [16] show slotsFromS3 st_agr ## [19] st_agr&lt;- st_as_sf st_bbox ## [22] st_boundary st_buffer st_cast ## [25] st_centroid st_collection_extract st_convex_hull ## [28] st_coordinates st_crs st_crs&lt;- ## [31] st_difference st_geometry st_geometry&lt;- ## [34] st_intersection st_is st_line_merge ## [37] st_node st_point_on_surface st_polygonize ## [40] st_precision st_segmentize st_set_precision ## [43] st_simplify st_snap st_sym_difference ## [46] st_transform st_triangulate st_union ## [49] st_voronoi st_wrap_dateline st_write ## [52] st_zm ## see &#39;?methods&#39; for accessing help and source code Cо многими из этих функций мы познакомимся в последующих разделах нашего курса. Некоторые из них (такие как arrange, filter, mutate из пакета dplyr), должны быть уже знакомы вам по предыдущим лекциям. Можно обратить внимание на то, что практически все функции начинаются с префикса st_, что означает “spatiotemporal”. Данные префиксы были выбраны для унификации с аналогичными названиями функций, используемых в широко распространенной СУБД PostgreSQL для оперирования объектами Simple Features. 9.3.2 Чтение Существует большое множество форматов хранения пространственных данных. Но в общем и целом их можно разделить на две категории: файловые форматы (наиболее привычные пользователям) и хранение данных в СУБД — системах управления базами данных. Благодаря библиотеке GDAL пакет sf имеет возможность читать и записывать более 90 различных форматов векторных даных. Разумеется, не все из них общеупотребительны. Исторически наиболее распространенным форматом был (и остается) ESRI Shapefile. Данный формат, однако не отвечает современным техническим требованиям с точки зрения гибкости, соответствия стандартам и возможностям хранения разнообразных типов геометрий (напомним, что в стандарте Simple Features их 17, а с учетом четырех вариантов размерности точек получается целых 68 ). Современный формат, который позволяет делать это (и не только), это GeoPackage. Именно его мы и будем использовать в нашем практикуме. Для чтения данных средствами sf необходимо использовать функцию st_read(): countries &lt;- st_read(&#39;ne/countries.gpkg&#39;) ## Reading layer `admin_0_map_units&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/ne/countries.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 183 features and 72 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs Лог функции сообщил нам следующую информацию: Набор данных представляет собой коллекцию из 183 пространственных объектов с 72 атрибутами Тип геометрии MULTIPOLYGON Размерность геометрии \\(XY\\) Ограничивающий прямоугольник (разброс координат) по осям \\(X\\) и \\(Y\\) имеет диапазон \\([-180, 180] \\times [-90, 83.64513]\\) EPSG-код пространственной привязки равен 4326 PROJ.4-строка пространственной привязки равна +proj=longlat +datum=WGS84 +no_defs 9.3.3 Внутренняя структура Традиционно во всех ГИС-приложениях и базах пространственных данных множество пространственных объектов представляется в виде таблицы атрибутов, где каждая строка соответствует объекту, а каждый столбец — атрибуту объекта. С каждой строкой таблицы должна быть ассоциирована информация о геометрии объекта, которая, в зависимости от формата данных, может либо храниться непосредственно в таблице (в специальном столбце), либо быть вынесена в отдельную структуру данных, которая связана с таблицей атрибутов посредством ключа5. В R используется первый подход, в котором информация о геометрии хранится в специальном столбце таблицы. Каждая ячейка этого столбца соответствует геометрическому объекту Simple Features. Представление геометрических объектов реализовано стандартными средствами, такими как списки, матрицы и векторы. Эти структуры данных упорядоченным образом хранят координаты объектов и естественным образом соответствуют способу организации данных, который регламентируется стандартом Simple Features. Поскольку геометрический столбец хранит не обычные переменные, а структуры данных, он реализуется в виде так называемого списка-колонки (list-column), каждый элемент которой соответствует отдельному объекту. Исходя из этих соображений, представление пространственных объектов реализовано в R в виде иерархии из трех классов объектов: sf (simple features) — объект класса data.frame, представляющий множество пространственных объектов со списком-колонкой для хранения геометрии sfc (simple features geometry column) — список-колонка в объекте sf, представляющий множество геометрий пространственных объектов sfg (simple feature geometry) — геометрия пространственного объекта внутри списка sfc В соответствии с перечисленными спецификациями происходит работа с пространственными объектами. То что, объекты типа Simple Features реализованы в виде самых обычных фреймов данных, означает что любая операция, применимая к фрейму данных, будет также применима к объекту типа sf. Это очень важная особенность объектов типа sf, которой сильно не хватало в экосистеме исторического пакета sp. Посмотрим, как все это реализовано, на конкретном примере: class(countries) ## [1] &quot;sf&quot; &quot;data.frame&quot; Данная форма записи говорит о том, что прочитанный слой имеет класс sf, который, в свою очередь, является расширением класса data.frame. А теперь посмотрим на последние колонки в первых строках таблицы: head(countries[tail(colnames(countries))]) ## Simple feature collection with 6 features and 5 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## tiny homepart min_zoom min_label max_label ## 1 -99 1 0 3 7 ## 2 -99 1 0 3 7 ## 3 -99 1 0 5 10 ## 4 -99 1 0 4 9 ## 5 -99 1 0 2 7 ## 6 -99 1 0 5 10 ## geometry ## 1 MULTIPOLYGON (((61.21082 35... ## 2 MULTIPOLYGON (((23.90415 -1... ## 3 MULTIPOLYGON (((21.02004 40... ## 4 MULTIPOLYGON (((51.57952 24... ## 5 MULTIPOLYGON (((-66.95992 -... ## 6 MULTIPOLYGON (((43.58275 41... Видно, что геометрия пространственных объектов хранится в заключительном столбце с названием geometry. Данный столбец можно быстро извлечь, применив функцию st_geometry(). Полученный объект будет иметь тип sfc (Simple Feature Geometry Column) outlines &lt;- st_geometry(countries) class(outlines) ## [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot; Полученный вывод говорит нам о том, что наши объекты имеют класс sfc_MULTIPOLYGON, который является расширением класса sfc (simple feature geometry column). Теперь если просмотреть начало данных, то мы увидим, что это больше не фрейм данных, а аннотированный список: head(outlines) ## Geometry set for 6 features ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -73.41544 ymin: -55.25 xmax: 75.15803 ymax: 42.68825 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## First 5 geometries: ## MULTIPOLYGON (((61.21082 35.65007, 62.23065 35.... ## MULTIPOLYGON (((23.90415 -11.72228, 24.07991 -1... ## MULTIPOLYGON (((21.02004 40.84273, 20.99999 40.... ## MULTIPOLYGON (((51.57952 24.2455, 51.75744 24.2... ## MULTIPOLYGON (((-66.95992 -54.89681, -67.56244 ... Далее можно опуститься на базовый уровень геометрии, получив доступ к отдельному объекту. Поскольку объект класса sfc представляет собой список, любой элемент можно извлечь по его порядковому номеру. Класс полученного объекта будет: class(outlines[[8]]) ## [1] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; Исходя из полученной информации можно сделать вывод, что геометрия 8-го объекта таблицы countries имеет класс sfg, реализованный в виде мультиполигонов (MULTIPOLYGON) с плоскими координатами (XY) Наконец, чтобы добраться до координат в чистом виде, необходимо развернуть иерархию списков, из которых состоит объект sfg. Количество уровней вложенности всегда зависит от конкретного объекта, их может быть достаточно много, особенно если объекты представлены мультиполигонами (несколько компонент связности), каждый из которых такж состоит из полигонов с дырками. В нашем случае все достаточно просто, так как в слое countries дырок в полигонах нет, а 8-й по счету полигон состоит из одной-единственной геометрии, координаты которой в виде матрицы можно извлечь как: outlines[[8]][[1]] ## [[1]] ## [,1] [,2] ## [1,] 68.9350 -48.6250 ## [2,] 69.5800 -48.9400 ## [3,] 70.5250 -49.0650 ## [4,] 70.5600 -49.2550 ## [5,] 70.2800 -49.7100 ## [6,] 68.7450 -49.7750 ## [7,] 68.7200 -49.2425 ## [8,] 68.8675 -48.8300 ## [9,] 68.9350 -48.6250 9.3.4 Визуализация 9.3.4.1 Базовые возможности Если попытаться применить функцию plot() к геометрии объекта, она попытается нарисовать тематические карты по всем имеющимся атрибутам (но остановится, если их более 9): plot(countries) Если задача стоит нарисовать границы объектов, то нужно отображать объект sfc: plot(outlines, col = &#39;red&#39;) Для быстрого построения тематических карт по выбранному показателю необходимо при вызове функции plot() указать соответствующий атрибут фрейма данных: plot(countries[&#39;sovereignt&#39;], key.pos = NULL) # Здесь легенда не нужна Для отображения координатной сетки надо указать параметр graticule = TRUE, а подписей координат — axes = TRUE: plot(countries[&#39;gdp_md_est&#39;], graticule = TRUE, axes = TRUE) 9.3.4.2 Совмещение слоев Для совмещения нескольких слоев на одной карте необходимо при втором и последующих вызовах функции plot() указать параметр add = TRUE: oceans &lt;- st_read(&#39;ne/oceans.gpkg&#39;) ## Reading layer `ocean&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/ne/oceans.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 4 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -85.60904 xmax: 180 ymax: 90 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs rivers &lt;- st_read(&#39;ne/rivers.gpkg&#39;) ## Reading layer `rivers_lake_centerlines&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/ne/rivers.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 13 features and 8 fields ## geometry type: LINESTRING ## dimension: XY ## bbox: xmin: -135.3134 ymin: -33.99358 xmax: 129.956 ymax: 72.90651 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs lakes &lt;- st_read(&#39;ne/lakes.gpkg&#39;) ## Reading layer `lakes&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/ne/lakes.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 25 features and 8 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: -124.9536 ymin: -16.53641 xmax: 109.9298 ymax: 66.9693 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs plot(countries %&gt;% st_geometry, lwd = 0.5, border = &#39;gray&#39;) plot(oceans %&gt;% st_geometry, col = &#39;steelblue1&#39;, border = &#39;steelblue&#39;, add = TRUE) plot(lakes %&gt;% st_geometry, col = &#39;steelblue1&#39;, border = &#39;steelblue&#39;, add = TRUE) plot(rivers %&gt;% st_geometry, col = &#39;steelblue&#39;, add = TRUE) Внимание: чтобы слои совместились на карте, они должна иметь одинаковую систему координат. Ясно, что на полученных нами картах можно много что улучшить, однако это мы отложим до следующей главы, где подробно разбирается построение тематических карт в R. 9.3.5 Системы координат и проекции Работа с пространственной привязкой данных в R состоит в основном из четырех операций: чтение информации о системе координат создание информации о системе координат замена информации о системе координат изменение системы координат (проецирование) Первые три операции (чтение, создание, замена) осуществляются функцией st_crs(). Чтобы прочитать информацию о проекции, достаточно передать в качестве параметра объект типа sf: st_crs(countries) # Координатная система ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; Эта же функция позволяет создать новую координатную систему, путем передачи ей кода EPSG или строки PROJ.4: st_crs(3857) # Проекция Меркатора для карт мира ## Coordinate Reference System: ## EPSG: 3857 ## proj4string: &quot;+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs&quot; st_crs(54030) # Проекция Робинсона для карт мира ## Coordinate Reference System: ## EPSG: 54030 ## proj4string: &quot;+proj=robin +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs&quot; # Проекция UTM, зона 37. st_crs(&#39;+proj=utm +zone=37 +datum=WGS84 +units=m&#39;) ## Coordinate Reference System: ## EPSG: 32637 ## proj4string: &quot;+proj=utm +zone=37 +datum=WGS84 +units=m +no_defs&quot; Замена координатной системы требуется в тех случаях, когда слой не имеет пространственной привязки, или же она задана некореектно. В этом случае необходимо вызвать для слоя функцию st_crs() и перезаписать результат. st_crs(countries) &lt;- NA st_crs(countries) ## Coordinate Reference System: NA st_crs(countries) &lt;- st_crs(4326) st_crs(countries) ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; Внимание: замена координатной системы не осуществляет перепроецирования данных и не меняет координаты точек. Она лишь влияет на то, как эти координаты будут интерпретироваться. Если вместо проецирования выполнить замену информации о координатной системе, данные будут позиционироваться в неправильном месте. Для трансформирования данных в другую проекцию следует использовать функцию st_tranform(x, crs). Данная функция принимает в качестве параметров класс объектов sf и координатную систему, в которую необхоимо проецировать данные. # Проекция Меркатора countries.merc &lt;- st_transform(countries, 3857) plot(st_geometry(countries.merc), col = &#39;lightgray&#39;, lwd = 0.5, graticule = TRUE, axes = TRUE) # Проекция Робинсона (используем dplyr) countries.rob &lt;- countries %&gt;% st_transform(54030) plot(st_geometry(countries.rob), col = &#39;lightgray&#39;, lwd = 0.5, graticule = TRUE, axes = TRUE) # Зарубежная Европа в Конической равнопромежуточной проекции. # Задаем только необходимые параметры проекции europe.conic &lt;- countries %&gt;% dplyr::filter(continent == &#39;Europe&#39; &amp; sovereignt != &#39;Russia&#39;) %&gt;% st_transform(&#39;+proj=eqdc +lon_0=10 +lat_1=30 +lat_2=60 +datum=WGS84 +units=m&#39;) plot(st_geometry(europe.conic), col = &#39;lightgray&#39;, lwd = 0.5, graticule = TRUE, axes = TRUE) Внимание: чтобы слои данных можно было совместно анализировать и наносить на одну карту, они должны иметь одну и ту же координатную систему (проекцию). 9.3.6 Атрибутивные операции Поскольку пространственные объекты хранятся в фреймах данных, к ним можно применять стандартные операции выборки по атрибутам и преобразования таблиц. Например, можно выбрать Италию и отобразить ее на отдельной карте: library(dplyr) italy &lt;- countries %&gt;% filter(sovereignt == &#39;Italy&#39;) plot(st_geometry(italy)) Следующий пример иллюстрирует как выбрать страны с населением более 100 млн человек: largest &lt;- countries %&gt;% select(pop_est) %&gt;% filter(pop_est &gt; 100000000) plot(outlines, col = &#39;lightgrey&#39;) plot(largest, col = &#39;red&#39;, add = TRUE) Обратите внимание на то, что при вызове функции select() столец geometry не был указан в числе выбираемых переменных. Тем не менее, то, что мы смоги построить карту по результатам выборки, говорит о том, что данный столбец был сохранен. Функции dplyr определены для объектов sf таким образом, чтобы всегда сохранять геометрический столбец. Еще интереснее работает агрегирование объектов по атрибутам. В случае, когда агрегируются пространственные объекты, необходимо объединять и их геометрию. При этом если у агрегируемых объектов имеется общая граница, ее необходимо удалить, а если объекты разнесены в пространстве, из них нужно собрать новый мульти-объект. Например, мы можем агрегировать валовый региональный продукт по континентам: continents &lt;- countries %&gt;% group_by(continent) %&gt;% summarise(gdp = sum(gdp_md_est)) plot(continents[&#39;gdp&#39;]) Потрясающе просто, не правда ли? Вдобавок, мы еще и получили границы континентов (достаточно условные, конечно), которых у нас раньше не было. Данный пример также показывает, что атрибутивные операции над пространственными объектами всегда учитывают их геометрию. 9.3.7 Пространственные операции Поиск объектов по местоположению базируется на проверке топологических отношений между объектами. Топологические отношения описывают взаимное расположение объектов. Различные варианты топологических отношений для площадных объектов представлены на следующем рисунке, где серым цветом показаны пересечения внутренних областей объектов \\(A\\) и \\(B\\), синим цветом — пересечения границ объектов \\(A\\) и \\(B\\): Отношение Пересекает (intersects) будет истинно для любого случая когда две геометрии имеют хотя бы одну общую точку, то есть во всех случаях кроме Не пересекает (disjoint). Для проверки этих, а также некоторых других отношений, в пакете sf существуует ряд функций: Функция Топологическое отношение st_intersects(x, y) x имеет общие точки с y st_disjoint(x, y) x не имеет общих точек с y st_touches(x, y) x касается y (граница x имеет общие точки с границей y И внутренняя область x не имеет имеет общих точек с внутренней областью y) st_crosses(x, y) x пересекает y (граница x имеет общие точки с границей y, при этом размерность их пересечения меньше размерности хотя бы одного из исходных обхектов) st_within(x, y) x внутри y (все точки x содержатся в y И внутренняя область x имеет общие точки с внутренней областью y) st_contains(x, y) x содержит y (все точки y содержатся в x И внутренняя область y имеет общие точки с внутренней областью x) st_contains_properly(x, y) x содержит y полностью (все точки y содержатся в x И граница x не имеет общих точек с границей y) st_overlaps(x, y) x перекрывает y (внутренняя область x имеет как общие, так и не общие точки с внутренней областью y) st_equals(x, y) x совпадает y (множества точек x и y совпадают) st_covers(x, y) x покрывает y (все точки y содержатся в x) st_covered_by(x, y) x покрыт y (все точки x содержатся в y) st_equals_exact(x, y) x совпадает y точно (упорядоченные множества точек x и y совпадают) Между covered_by и within, а также covers и contains нет разницы в случае, когда оба объекта являются площадными. Эта разница будет сказываться если хотя бы один из объектов является линией либо точкой. В этом случае within, contains и contains_properly будут давать ложный результат (FALSE), поскольку ни у линий, ни у точек нет внутренней области. Проверка топологических отношений используется для выполнения выборки объектов по местоположению — пространственной выборки. Наиболее простой способ выбрать объекты по пространственному местоположению — это использовать один слой в качестве фильтра для другого слоя. В этом случае будет по умолчанию использовано отношение st_intersects() (пересекает). Никаких отличий от работы с обычными таблицами нет. Например, вот так можно выбрать точки, находящиеся внутри ранее отобранных стран с максимальным ВВП: cities &lt;- st_read(&#39;ne/cities.gpkg&#39;) ## Reading layer `populated_places&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/ne/cities.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 243 features and 103 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: -175.2206 ymin: -41.29999 xmax: 179.2166 ymax: 64.15002 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs city.pts &lt;- st_geometry(cities) # Наносим исходную конфигурацию plot(outlines, lwd = 0.5) plot(cities, col = &#39;black&#39;, pch = 20, cex = 0.5, add = TRUE) # Отбираем точки внутри стран с максимальным ВВП sel &lt;- cities[largest, ] ## although coordinates are longitude/latitude, st_intersects assumes that they are planar # Смотрим что получилось plot(outlines, lwd = 0.5) plot(largest, col = &#39;gray&#39;, add = TRUE) plot(sel, pch = 20, col = &#39;black&#39;, add = TRUE) Разумеется, при выполнении пространственных запросов могут возникать и другие пространственные отношения. Например, мы можем выбрать все страны, имеющие общую границу с Чехией. Для этого можно использовать топологическое отношение st_touches вместо st_intersects — это будет гарантировать, что сама Чехия в результате не выберется (касающиеся объекты не могут перекрываться). Тип отношения необходимо поставить в параметр op = при выполнении фильтрации фрейма данных: cz &lt;- countries %&gt;% filter(sovereignt == &#39;Czechia&#39;) neighbors &lt;- countries[cz, op = st_touches] ## although coordinates are longitude/latitude, st_touches assumes that they are planar plot(st_geometry(neighbors), col = &#39;lightgray&#39;, lwd = 0.5) plot(cz, col = &#39;darkgray&#39;, add = TRUE) 9.3.8 Создание пространственных объектов Пространственные объекты в R можно собирать “вручную”, если есть такая необходимость. Например, вам известны координаты границ участков полевого обследования, полученные посредством GPS, а вам необходимо превратить их в полигоны, чтобы выполнить анализ и картографирование. Придется из координат собрать полигоны программным путем. Процесс создания пространственных объектов осуществляется в последовательности их иерархического соподчинения: sfg &gt; sfc &gt; sf. 9.3.8.1 Геометрические объекты (sfg) Для создания геометрических объектов в пакете sf существует ряд функций с говорящими названиями: Функция Тип пространственного объекта st_point() POINT st_linestring() LINESTRING st_polygon() POLYGON st_multipoint() MULTIPOINT st_multilinestring() MULTILINESTRING st_multipolygon() MULTIPOLYGON st_geometrycollection() GEOMETRYCOLLECTION В зависимости от типа создаваемого объекта, данные функции принимают координаты, организованные в виде одной из трех структур данных: Вектор координат (POINT) Матрица координат (MULTIPOINT или LINESTRING), в которой строки соответствуют точкам, столбцы — координатам Список (для всех остальных типов) Проще всего создаются отдельные точки (POINT): st_point(c(0, 2)) # XY POINT ## POINT (0 2) st_point(c(0, 2, -1)) # XYZ POINT ## POINT Z (0 2 -1) st_point(c(0, 2, 5), dim = &#39;XYM&#39;) # XYM POINT ## POINT M (0 2 5) st_point(c(0, 2, -1, 5)) # XYZM POINT ## POINT ZM (0 2 -1 5) Дополнительный параметр dim= служит для уточнения типа геометрии точек и по сути нужен только тогда, когда необходимо создать редко используемые точки типа XYM. во всех остальных случаях (XY, XYZ, XYZM) размерность геометрии распознается по умолчанию. При создании мультиточек (MULTIPOINT) и линий (LINESTRING) необходимо подавать на вход функции уже матрицу координат: coords &lt;- matrix(c( 0, 2, 1, 3, 3, 1, 5, 0 ), ncol = 2, byrow = TRUE) mp &lt;- st_multipoint(coords) # XY MULTIPOINT print(mp) ## MULTIPOINT (0 2, 1 3, 3 1, 5 0) ls &lt;- st_linestring(coords) # XY LINESTRING print(ls) ## LINESTRING (0 2, 1 3, 3 1, 5 0) В первом случае геометрия состоит из отдельных точек. Во втором случае те же самые точки соединены линией: plot(ls) plot(mp, col = &#39;red&#39;, pch = 19, add = TRUE) Создание трех-(XYZ, XYM) и четрехмерных (ZYXM) мультиточек и линий выполняется аналогично, но матрица должна содержать не 2, а, соответственно 3 или 4 столбца, и при необходимости параметр dim = 'XYM'. Создание полигонов (POLYGON), мультиполигонов (MULTIPOLYGON) и мультилиний (MULTILINESTRING) требует уже создания списков из матриц. Почему нельзя представить обычный (не мульти) полигон просто матрицей координат? Потому что полигон может содержать дырки. Например, контур леса может содержать дырку в том месте, где находится озеро. Или озеро может содержать дырку в том месте, где находится остров. Природа предлагает нам бесконечное число таких примеров. В целях универсализации приходится закладываться на возможность наличия дырок в полигонах, поэтому даже полигоны без дырок представляются в виде списков. При этом действу.т следующее правила: Первая матрица координат в списке отвечает за контур полигона Все остальные матрицы координат отвечают за дыры в полигоне Координаты первой и последней точки в каждой матрице должны совпадать Если дыр в полигоне нет, его список будет содержать только одну матрицу. Рассмотрим оба примера построения полигонов: coords &lt;- matrix(c( # Координаты главного полигона 1, 0, 0, 2, 2, 3, 4, 2, 3, 0.5, 1, 0 ), ncol = 2, byrow = TRUE) pol &lt;- st_polygon(list(coords)) # Простой полигон print(pol) ## POLYGON ((1 0, 0 2, 2 3, 4 2, 3 0.5, 1 0)) plot(pol, col = &#39;lightblue&#39;) hole &lt;- matrix(c( # Координаты дыры 2, 1, 3, 1.5, 3, 2, 2, 2, 1.5, 1.5, 2, 1 ), ncol = 2, byrow = TRUE) pol2 &lt;- st_polygon(list(coords, hole)) # Полигон с дырой print(pol2) ## POLYGON ((1 0, 0 2, 2 3, 4 2, 3 0.5, 1 0), (2 1, 3 1.5, 3 2, 2 2, 1.5 1.5, 2 1)) plot(pol2, col = &#39;lightblue&#39;) Мультиполигоны (MULTIPOLYGON) и мультилинии (MULTILINESTRING) требуются тогда, когда один и тот же географический объект состоит из нескольких геометрических объектов. Простейший пример — островные государства. Чтобы представить страну, занимающую архипелаг (Багамские острова, Индонезия, Япония и т.д.) как один пространственный объект, необходимо создать мультиполигон. Все компоненты мультиполигона будут иметь общий набор атрибутов (непространственных характеристик). Мультилинии используются реже мультиполигонов и необходимы для представления линейных объектов, разорванных в пространстве. Примером такого объекта может быть любая река или канал, которые разорваны в тех местах, где они протекают через озеро или водохранилище, представленное полигональным объектом. В мультиполигонах добавляется еще один уровень списка, то есть искомые матрицы координат будут располагаться как минимум на втором уровне вложенности: coords1 &lt;- matrix(c( 0.5, 0, 0, 1, 1, 1.5, 2, 1, 1.5, 0.25, 0.5, 0 ), ncol = 2, byrow = TRUE) coords2 &lt;- matrix(c( 3, 1, 2.5, 2, 3.5, 2.5, 4, 2, 4, 1.25, 3, 1 ), ncol = 2, byrow = TRUE) mpol &lt;- st_multipolygon(list(list(coords1), list(coords2))) print(mpol) ## MULTIPOLYGON (((0.5 0, 0 1, 1 1.5, 2 1, 1.5 0.25, 0.5 0)), ((3 1, 2.5 2, 3.5 2.5, 4 2, 4 1.25, 3 1))) plot(pol, col = &#39;grey&#39;) # Обычный полигон (серый) plot(mpol, col = &#39;pink&#39;, add = TRUE) # Мультиполигон (розовый) Как насчет острова на озере? Если остров и суша, окружающая озеро, составляют единое целое (например, подлежат учету как единый массив леса), их можно собрать как мультиполигон. В этом случае первая компонента мультиполигона будет представлять собой полигон с дыркой, а вторая компонента — остров. Порядок компонент в данном случае роли не играет: coords4 &lt;- matrix(c( 2.2, 1.2, 2.8, 1.5, 2.8, 1.8, 2.2, 1.8, 2.0, 1.6, 2.2, 1.2 ), ncol = 2, byrow = TRUE) island &lt;- st_polygon(list(coords4)) mpol2 &lt;- st_multipolygon(list(pol2, island)) print(mpol2) ## MULTIPOLYGON (((1 0, 0 2, 2 3, 4 2, 3 0.5, 1 0), (2 1, 3 1.5, 3 2, 2 2, 1.5 1.5, 2 1)), ((2.2 1.2, 2.8 1.5, 2.8 1.8, 2.2 1.8, 2 1.6, 2.2 1.2))) plot(mpol2, col = &#39;darkolivegreen4&#39;) Из данного примера также видно, что при сборе мультиполигона на самом нижнем уровне вложености можно подавать не списки матриц координат, а готовые полигоны. Мультилиния, в отличие от мультиполигона, не требует дополнительного списка верхнего уровня, поскольку линии не могут содержать дыр. Например, можно собрать мультилинию из двух частей, соответствующих участкам реки до и после озера: coords1 &lt;- matrix(c( -3, 0, -1, 2, 0, 2 ), ncol = 2, byrow = TRUE) coords2 &lt;- matrix(c( 4, 2, 5, 3, 6, 5 ), ncol = 2, byrow = TRUE) mline &lt;- st_multilinestring(list(coords1, coords2)) print(mline) ## MULTILINESTRING ((-3 0, -1 2, 0 2), (4 2, 5 3, 6 5)) plot(mline, lwd = 3, col = &#39;blue&#39;) plot(pol2, col = &#39;lightblue&#39;, add = TRUE) Наконец, еще один вид геометрии — это геометрическая коллекция (GEOMETRYCOLLECTION), который позволяет хранить вместе любые виды геометрий. Эта возможность используется достаточно редко, тем не менее, рассмотреть ее нужно. Геометрическая коллекция собирается из списка объектов с простыми типами геометрии (мы создали их ранее): col &lt;- st_geometrycollection(list(ls, mp, mline, pol2)) print(col) ## GEOMETRYCOLLECTION (LINESTRING (0 2, 1 3, 3 1, 5 0), MULTIPOINT (0 2, 1 3, 3 1, 5 0), MULTILINESTRING ((-3 0, -1 2, 0 2), (4 2, 5 3, 6 5)), POLYGON ((1 0, 0 2, 2 3, 4 2, 3 0.5, 1 0), (2 1, 3 1.5, 3 2, 2 2, 1.5 1.5, 2 1))) plot(col) 9.3.8.2 Списки геометрических объектов (sfc) Списки геометрических объектов (класс sfc) используются в таблицах пространственных объектов в качестве столбца, который хранит геометрию объектов. Создание таких списков осуществляется функцией st_sfc(), которой достаточно передать в качестве перечня параметров объекты типа sfg. Расмотрим создание списка геометрий на примере точечных объектов (для остальных типов объектов порядок действий не меняется): moscow.sfg &lt;- st_point(c(37.615, 55.752)) irkutsk.sfg &lt;- st_point(c(104.296, 52.298)) petro.sfg &lt;- st_point(c(158.651, 53.044)) cities.sfc &lt;- st_sfc(moscow.sfg, irkutsk.sfg, petro.sfg) print(cities.sfc) ## Geometry set for 3 features ## geometry type: POINT ## dimension: XY ## bbox: xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752 ## epsg (SRID): NA ## proj4string: NA ## POINT (37.615 55.752) ## POINT (104.296 52.298) ## POINT (158.651 53.044) При создании списка геометрий для него может быть определена система координат (это можно сделать и позднее при создании таблицы пространственных объектов). Для этого используем уже знакомую нам функцию st_crs(): st_crs(cities.sfc) &lt;- st_crs(4326) # WGS84 print(cities.sfc) ## Geometry set for 3 features ## geometry type: POINT ## dimension: XY ## bbox: xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## POINT (37.615 55.752) ## POINT (104.296 52.298) ## POINT (158.651 53.044) Для списка геометрий может быть определена только одна система координат Можно посмотреть, куда легли наши точки: plot(cities.sfc, pch = 19) countries %&gt;% filter(sovereignt == &#39;Russia&#39;) %&gt;% st_geometry() %&gt;% plot(add = TRUE) 9.3.8.3 Пространственные объекты (sf) Пространственные объекты (класс sf) организуются в виде фрейма данных, один из столбцов которого имеет класс sfc. Для этого следует сначала создать обычный фрейм данных с атрибутами, а затем соединить его со списком геометрий посредством функции st_sf: city.attr &lt;- data.frame( name = c(&#39;Москва&#39;, &#39;Иркутск&#39;, &#39;Петропавловск-Камчатский&#39;), established = c(1147, 1661, 1740), population = c(12500, 620, 180) ) cites.sf &lt;- st_sf(city.attr, geometry = cities.sfc) print(cites.sf) ## Simple feature collection with 3 features and 3 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 37.615 ymin: 52.298 xmax: 158.651 ymax: 55.752 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## name established population geometry ## 1 Москва 1147 12500 POINT (37.615 55.752) ## 2 Иркутск 1661 620 POINT (104.296 52.298) ## 3 Петропавловск-Камчатский 1740 180 POINT (158.651 53.044) 9.3.8.4 Преобразование типов геометрии Для преобразования типов геометрии существует функция st_cast(). Функция принимает объекты классов sfg, sfc или sf, а также название типа геометрии, к которому необходимо привести входные объекты. Довольно часто возникает задача конвертации площадного объекта в линейный и обратно, а также задача получения координат вершин линейного или площадного объекта в виде точек. Примеры преобразований: italy.borders &lt;- st_cast(italy, &#39;MULTILINESTRING&#39;) class(st_geometry(italy.borders)) ## [1] &quot;sfc_MULTILINESTRING&quot; &quot;sfc&quot; italy.regions &lt;- st_cast(italy.borders, &#39;MULTIPOLYGON&#39;) class(st_geometry(italy.regions)) ## [1] &quot;sfc_MULTIPOLYGON&quot; &quot;sfc&quot; italy.points &lt;- st_cast(italy.borders, &#39;POINT&#39;) class(st_geometry(italy.points)) ## [1] &quot;sfc_POINT&quot; &quot;sfc&quot; plot(st_geometry(italy.regions), lwd = 0.5) plot(italy.points, pch = 20, add = TRUE) 9.3.8.5 Полигонизация и разбиение линий Полигонизация — это процесс преобразования линии или мультилинии в полигон(ы). Полигон может быть образован последовательностью из одной и более линий, для которых выполняются следующие условия: Каждая линия является простой (не имеет самопересечений) Линии касаются только своими начальными и конечными точками Линии образуют замкнутую последовательность (т.е. выйдя из любой конечной точки и двигаясь вдоль множества линий, можно вернуться в ту жже точку.) Полигонизация может применяться только к одному геометрическому объекту (simple feature geometry). Соответственно, это должна быть либо просто замкнутая линия, либо мультилиния, компоненты которой образуют замкнутую последовательность. Рассмотрим операции полигонизации и добавления узлов на простом примере трех пересекающихся отрезков: # Создадим три линии coords1 = rbind(c(0, 0), c(0, 6)) line1 &lt;- st_linestring(coords1) coords2 = rbind(c(-1,1), c(5,1)) line2 = st_linestring(coords2) coords3 = rbind(c(-1,5), c(4,0)) line3 = st_linestring(coords3) # Создадим мультилинию mls &lt;- st_multilinestring(list(line1, line2, line3)) plot(mls) # Посмотрим на ее точки points &lt;- st_cast(mls, &#39;MULTIPOINT&#39;) plot(points, pch = 20, add = TRUE) Из рисунка видно, что линии образуют треугольную замкнутую область. Также рисунок показывает, что у компонент мультилинии нет вершин в точках пересечения. Мы можем попытаться найти замкнутые области и превратить их в полигоны, используя st_polygonize(): st_polygonize(mls) ## GEOMETRYCOLLECTION EMPTY Операция завершилась возвратом пустой геометрической коллекции, то есть программа не смогла выделить замкнутые области. Это произошло по причине того, что линии не разбиты в точках пересечения. Разбить их на компоненты можно, используя функцию st_node(): mls2 &lt;- st_node(mls) poly2 &lt;- st_polygonize(mls2) points2 &lt;- st_cast(mls2, &#39;MULTIPOINT&#39;) plot(mls2) plot(poly2, col = &#39;grey&#39;, add = TRUE) plot(points2, pch = 20, add = TRUE) Таким образом, после разбиения линий на куски в точках пересечения стала возможной операция полигонизации. 9.3.9 Геометрические атрибуты К описательным характеристикам геометрии относятся ограничивающий прямоугольник, периметр (для линий и полигонов) и площадь (для полигонов), которые можно получить с помощью функций st_bbox(), st_area() и st_length() соответственно. Функции корректно работают для простых объектов, мультиобъектов, списков геометрий и пространственных объектов. Применительно к полигону Италии эти параметры будут учитывать части геометрии, занимаемые островами: st_bbox(italy) # Координаты органичивающего прямоугольника ## xmin ymin xmax ymax ## 6.749955 36.619987 18.480247 47.115393 st_area(italy) # Площадь ## 315104851198 m^2 st_length(italy) # Периметр ## 5323111 m Обратите внимание на то, что площадь и перметр выводятся с указанием единиц измерений! Это возможно благодаря тому, что объекты типа sf поддерживают единицы измерений на основе пакета units. Если данные находятся в плоской прямоугольной системе координат, то единицы измерения как правило указываются в параметрах проекции — следовательно, они могут быть использованы при вычислении геометрических параметров объектов. Если же данные хранятся в широтах и долготах, то вычисление геометрических параметров осуществляется пакетом sf по формулам сферической тригонометрии через пакет geosphere. Это позволяет выводить результат в плоских единицах измерения. Ограничивающий прямоугольник можно быстро преобразовать в полигон и нанести на карту, применив функцию st_as_sfc(): box &lt;- st_as_sfc(st_bbox(italy)) # Ограничивающий прямоугольник plot(italy %&gt;% st_geometry(), col = &#39;lightgrey&#39;) plot(box, border = &#39;red&#39;, add = TRUE) 9.3.10 Экспорт Для экспорта векторных пространственных данных можно воспользоваться функцией st_write(), которая определит формат выходного файла по указанному вами расширению: st_write(cites.sf, &#39;mycities.shp&#39;) # Шейп-файл 9.4 Растровые данные Работа с растровыми данными в целом гораздо проще, чем работа с векторными объектами. Это обусловлено в том числе жесткой сеточной структурой данных, которая предоставляет не так много свободы в различных сценариях обработки данных. В то же время, эта жесткая структура позволяет сделать растровые алгоритмы универсальными и робастными, многие задачи решаются в растровом виде быстрее и проще, чем в векторном. В настоящее время для работы с растровыми данными в R используется мощный и достаточно универсальный пакет raster6. 9.4.1 Чтение Для чтения одноканальных растров (например, цифровых моделей рельефа или полей распределения метеорологических величин) используется функция raster(), она создает растровый слой (Raster Layer). Многоканальные растры (например, космические снимки или файлы NetCDF) читаются с помощью функции stack(), она создает растровый стек (Raster Stack): library(raster) ## Загрузка требуемого пакета: sp ## ## Присоединяю пакет: &#39;raster&#39; ## Следующий объект скрыт от &#39;package:dplyr&#39;: ## ## select dem &lt;- raster(&#39;world/gebco.tif&#39;) # Цифровая модель рельефа class(dem) ## [1] &quot;RasterLayer&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; img &lt;- stack(&#39;world/BlueMarbleJuly.tif&#39;) # Цветной космический снимок (RGB) class(img) ## [1] &quot;RasterStack&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; class(img[[1]]) ## [1] &quot;RasterLayer&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; Вы также можете прочитать каналы многоканального растра по отдельности. Для этого необходимо использовать функцию raster(), указав ей в качестве второго параметра номер канала, который вы хотите прочитать. Если потом потребуется собрать поканальные растры в один стек, для этого можно снова использовать функцию stack(): ch1 &lt;- raster(&#39;world/BlueMarbleJuly.tif&#39;, 1) ch2 &lt;- raster(&#39;world/BlueMarbleJuly.tif&#39;, 2) ch3 &lt;- raster(&#39;world/BlueMarbleJuly.tif&#39;, 3) img &lt;- stack(ch1, ch2, ch3) 9.4.2 Визуализация 9.4.2.1 Одноканальные растры Для визуализации одноканальных растров используется функция plot(). В простейшем виде ей достаточно просто передать визуализруемый растр: par(mfrow = c(1,1)) plot(dem) Поскольку растры часто используют в классифицированном виде, вы можете сформировать вектор граничных значений классов, вектор цветов классов, и передать их в параметры breaks и col функции plot() соответственно. Если параметр breaks не определять, то весь диапазон значений растра будет разбит на равные интервалы соответственно количеству цветов. Если не определять параметр col, то будет применена стандартная палитра terrain.colors. Вы также можете использовать одну из готовых палитр цветов или создать ее вручную (см. посвященную графической подсистеме R): brks &lt;- c(-12000, 0, 200, 500, 1000, 2000, 4000, 8000) clrs &lt;- c( &quot;steelblue4&quot;, &quot;darkseagreen&quot;, &quot;lightgoldenrod1&quot;, &quot;darkgoldenrod1&quot;, &quot;darkorange&quot;, &quot;coral2&quot;, &quot;firebrick3&quot;) plot(dem, breaks = brks, col = clrs) plot(ch1, col = colorRampPalette(c(&quot;black&quot;, &quot;white&quot;))(255)) plot(ch1, col = rainbow(10)) 9.4.2.2 Многоканальные растры Для визуализации растрового стека (многоканального растра) следует использовать функцию plotRBG(): plotRGB(img) Поскольку при визуализации космических снимков часто используют различные варианты синтеза каналов (чтобы лучше дешифрировать те или иные категории объектов), функция plotRGB() предоставляет такую возможность. Достаточно перечислить последовательность каналов растрового стека (по умолчанию эти каналы будут подставлены в каналы R, G и B соответсвенно): par(mfrow = c(3,2)) plotRGB(img, 1, 2, 3) plotRGB(img, 1, 3, 2) plotRGB(img, 2, 1, 3) plotRGB(img, 2, 3, 1) plotRGB(img, 3, 1, 2) plotRGB(img, 3, 2, 1) par(mfrow = c(1,1)) 9.4.2.3 Совмещение слоев Вы можете совмещать на картах несколько растровых и векторных слоев точно так же как и при совмещении векторных данных (указав параметр add = TRUE при вызове функции plot()): plotRGB(img) plot(outlines, border = &quot;white&quot;, lwd = 0.5, add = TRUE) 9.4.3 Системы координат и проекции Как и в случае с векторными данными, работа с проекцией растровых данных предполагает четыре возомжных процедуры: чтение, создание, замена и проецирование. Для чтения и замены информации о системе координат растра используется функция crs(). Она возвращает и принимает строку в формате PROJ.4. Для создания информации о системе координат можно использовать уже знакомую нам функцию st_crs() из пакета sf. Данная функция возвращает список, вторая компонента которого и есть искомая строка: crs(dem) # читаем систему координат ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 crs(dem) &lt;- NA # очищаем систему координат crs(dem) ## CRS arguments: NA crs(dem) &lt;- st_crs(4326)[[2]] # создаем систему координат crs(dem) ## CRS arguments: ## +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 Для проецирования растра в новую систему координат необходимо использовать функцию projectRaster(). В эту функцию необходимо передать как минимум два параметра: from= отвечает за входной растр и crs= отвечает за выходную систему координат в формате PROJ.4. Дополнительно можно указать разрешение растра (res=), метод передискретизации (method=) и растр-шаблон (to= — можно создать растр в выходной системе координат заранее и как бы “перенести” значения пикселей входного растра на пиксели шаблона). Есть и другие пераметры, с которыми можно ознакомиться в справке функции projectRaster(). Приведем несколько примеров проецирования: # Проекция Меркатора: img.merc &lt;- projectRaster(img, crs = st_crs(3857)[[2]]) plotRGB(img.merc) plot(st_geometry(countries.merc), border = rgb(1,1,1,0.2), lwd = 0.5, add = TRUE) # Проекция Робинсона: img.merc &lt;- projectRaster(img, crs = st_crs(54030)[[2]]) plotRGB(img.merc) plot(st_geometry(countries.rob), border = rgb(1,1,1,0.2), lwd = 0.5, add = TRUE) 9.4.4 Операции со значениями Операции со значениями растров чрезвычайно разнообразны, поэтому подробно они разбираются в одной из последующих глав. Здесь же мы кратко познакомимся с локальными операциями над растром, такими как фильтрация и арифметические преобразования. В локальных операциях каждый пиксел растра анализируется отдельно, независимо от остальных пикселов. Поэтому локальные операции наиболее просты в применении. Но это не означает, что они менее важны, чем более сложные операции. Как раз наоборот: фильтрация и арифметика представялют собой важнейшие операции растровой алгебры. Особенность растровой алгебры заключается в том, что растры используются в выражениях как обычные переменные — это делает преобразования растров простыми и наглядными. Чтобы произвести фильрацию (выбор) ячеек по значениям, необходимо соорудить логическое выражение с участием растра. Все пикселы, удовлетворяющие критерию, получат в результирующем растре значение 1, а все остальные — 0. Несколько примеров: below.zero &lt;- dem &lt; 0 plot(below.zero) highlands &lt;- dem &gt; 100 &amp; dem &lt; 500 plot(highlands) mountains &lt;- dem &gt; 1000 plot(mountains) С помощью локальных операций растровой алгебры можно складывать, вычитать, перемножать и делить растры (а также брать из них квадратные корни, логарифмы, тригонометрические функции), точно так же как это происходит с обычными числами. Соответственно, бывают бинарные (два растра) и унарные (один растр) операции. Чтобы получать предсказуемые результаты бинарных операций растровой алгебры, необходимо, чтобы геометрия растров совпадала. Покажем возможности растровой алгебры на примере определения толщины покровного оледенения. Глобальная цифровая модель рельефа ETOPO1 поставляется в двух вариантах: Ice Surface (поверхность с учетом покровного оледенения) и Bedrock (подстилающая поверхность). Если вычесть из первой вторую, можно узнать толщину льда в Гренландии и на Антарктиде: bed &lt;- raster(&#39;world/etopo1_bed.tif&#39;) ice &lt;- raster(&#39;world/etopo1_ice.tif&#39;) ice.depth &lt;- ice - bed plot(ice.depth, col = cm.colors(255)) plot(outlines, border = &#39;black&#39;, lwd = 0.5, add = TRUE) Чтобы маскировать значения растра, необходимо воспользоваться функцией values(), которая обнажает список значений растра. Например, можно превратить в NA все пикселы, в которых толщина льда меньше или равна нулю: values(ice.depth)[values(ice.depth) &lt;= 0] &lt;- NA plot(ice.depth, col = cm.colors(255)) plot(outlines, border = &#39;black&#39;, lwd = 0.5, add = TRUE) 9.4.5 Экспорт Чтобы экспортировать (сохранить в файл) любой растр, можно воспользоваться функцией writeRaster(), указав имя выходного файла: writeRaster(ice.depth, &#39;world/ice_depth.tif&#39;) Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 ГОСТ Р 52438-2005 &lt;&gt;. В стандарте поясняется, что объектом может быть неподвижный или движущийся простой или сложный объект, явление, событие, процесс и ситуация. Моделируемый объект может относиться к территории, акватории, недрам и воздушному пространству Земли, околоземному космическому пространству, другим космическим телам и небесной сфере. В широком смысле под пространственным объектом в геоинформатике понимается как сам объект, так и адекватная ему цифровая модель↩ Названия перечисленных компонент геометрии растра укоренились благодаря распространенности стандарта Esri ASCII Grid↩ Например, в широко распространенном формате Esri Shapefile атрибутивная таблица хранится в файле *.dbf формата DBASE, геометрия хранится в отдельном файле *.shp, а связь между ними осуществляется через файл *.shx. Разбиение формата хранения на несколько файлов — это одна из уязвимостей шейп-файлов: при отсутствии хотя бы одного из этих файлов данные прочесть стандартными средствами (без дополнительного хакинга) будет нельзя.↩ В настоящий момент ведется разработка нового пакета stars, который рассматривается как замена пакету raster и будет поддерживать большие массивы многовременных растровых данных, однако пока что пакет не доступен для использования.↩ "],
["thematic-mapping.html", "Глава 10 Тематические карты в R 10.1 Соединение таблиц в R 10.2 Классификация данных 10.3 Серии карт lattice 10.4 Карты растров 10.5 Экспорт изображения в графический файл", " Глава 10 Тематические карты в R Программный код главы Необходимые пакеты: sf, sp, raster, dplyr, lattice, cartography В данном модуле мы продвинемся дальше в изучении принципов работы с пространственными данными в R. Рассматривается соединение табличных и пространственных данных на примере статистики по регионам России. Даются базовые представления о построении серий карт средствами пакета lattice. 10.1 Соединение таблиц в R Операция соединения — одна из наиболее часто используемых возможностей реляционной алгебры, которая лежит в основе теории реляционных баз данных. Реляционные БД используются повсеместно, и данные в них физически организованы в виде таблиц. Если говорить по сути, то соединение позволяет объединять данные об одних и тех же объектах, находящиеся в разных таблицах. Результатом соединения является новая таблица, полученная следующим образом: Заголовок таблицы содержит атрибуты обеих таблиц Строки таблицы получены путем “состыковки” строк исходных таблиц по совпадению значений ключевых полей, содержащихся в обеих таблицах. Таким образом, в каждой из исходных таблиц должен быть столбец, по которому можно сопоставить их строки. Он не обязательно должен называться одинаково. Предположим, в таблице \\(A\\) имеется набор данных о некоторых объектах. Каждая строка соответствует одному объекту, строки не дублируются. В столбце \\(ID\\) хранится идентификатор каждого объекта. Это может быть число, строка и так далее — главное чтобы эти идентификаторы были уникальны и не повторялись. Таблица \\(B\\) содержит информацию о некоторых объектах из \\(A\\) (и возможно некоторых других!), а идентификатор каждого объекта хранится в столбце \\(FID\\). В результате соединения \\(A\\) и \\(B\\) по ключевым полям \\(ID\\) и \\(FID\\) строки из \\(B\\) пристыкуются справа к строкам из \\(A\\) в тех случаях, когда \\(ID = FID\\). Рассмотрим, соединение таблиц на примере добавления статистических данных из внешней таблицы к пространственным данным о некоторых регионах России. Для этого сначала подключим используемые в настоящем модуле пакеты R и прочтем исходные данные: library(sf) ## Linking to GEOS 3.6.1, GDAL 2.1.3, proj.4 4.9.3 library(readxl) # Чтение файлов Excel library(lattice) # Пакет lattice используется для построения серий карт/графиков library(classInt) # Пакет classInt реализует методы классификации данных ## Загрузка требуемого пакета: spData ## To access larger datasets in this package, install the spDataLarge ## package with: `install.packages(&#39;spDataLarge&#39;, ## repos=&#39;https://nowosad.github.io/drat/&#39;, type=&#39;source&#39;))` library(RColorBrewer) # Цветовые шкалы library(sp) # Пакет sp нужен для поддержки классов Spatial, необходимых для создания карт средствами lattice # Читаем шейп-файл с границами регионов reg &lt;- read_sf(&quot;Regions.gpkg&quot;) View(reg) # читаем таблицу со статистикой tab &lt;- read_xlsx(&quot;Regions.xlsx&quot;) View(tab) # сразу разделим численность населения на миллион, # чтобы не иметь дело с большими числами: tab[3:11] &lt;- tab[3:11] / 1000000 head(tab) ## # A tibble: 6 x 11 ## FID Region `1959` `1970` `1979` `1989` `2002` `2010` `2013` `2014` ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 29 Астра… 0.702 0.867 0.916 0.998 1.01 1.01 1.01 1.02 ## 2 18 Белго… 1.23 1.26 1.30 1.38 1.51 1.53 1.54 1.54 ## 3 22 Брянс… 1.55 1.58 1.51 1.47 1.38 1.28 1.25 1.24 ## 4 9 Влади… 1.40 1.51 1.58 1.65 1.52 1.44 1.42 1.41 ## 5 27 Волго… 1.85 2.32 2.48 2.59 2.70 2.61 2.58 2.57 ## 6 10 Ворон… 2.37 2.53 2.48 2.47 2.38 2.34 2.33 2.33 ## # ... with 1 more variable: `2015` &lt;dbl&gt; Для корректного соединения таблиц необходимо знать, как правильно сопоставить строки в двух таблицах т.е. статистика по Чувашской республике должна присоединиться именно к Чувашской республике, а не к Москве. Сопоставлять названия регионов текстовым поиском средствами grep() — можно, но не надежно, поскольку наименования регионов могут отличаться и содержать ошибки. Наилучший способ сопоставления — по уникальным числовым идентификаторам регионов. Для этого следует использовать функцию merge(). К счастью, такие идентификаторы имеются в наших данных: столбец TARGET_FID в слое regions соответствует столбцу FID в таблице tab. Можете проверить это, вызвав функцию View() для обоих объектов. Названия столбцов следует указать в параметрах by.x и by.y функции merge(). reg &lt;- merge(reg, tab, by.x=&quot;TARGET_FID&quot;, by.y=&quot;FID&quot;) View(reg) 10.2 Классификация данных Классификация данных — важнейший этап картографирования, который во многом определяет, как данные будут представлены на карте и какие географические выводы читатель сделает на ее основе. Существует множество методов классификации числовых рядов. Классифицировать данные автоматически можно с помощью функции classIntervals() из пакета classInt. Наберите в консоли ?classInt чтобы прочитать справку о методах классификации. Посмотрим несколько методов классификации. Первый параметр функции classInt — это числовой ряд. Число классов следует передать в параметр n =, метод классификации указывается в параметре style =. Для начала попробуем метод равных интервалов, который просто делит размах вариации (диапазон от минимума до максимум) на \\(n\\) равных интервалов. Функция plot() применительно к созданной классификации рисует замечательный график, на котором показаны границы классов и эмпирическая функция распределения показателя. В параметр pal можно передать цветовую палитру: # Запишем число классов в переменную nclasses &lt;- 5 # Подготовим цветовую шкалу от бледно-розового к красному ramp &lt;- colorRampPalette(c(&quot;mistyrose&quot;, &quot;red&quot;)) intervals &lt;- classIntervals(reg$X2015, n = nclasses, style = &quot;equal&quot;) # извлечь полученные границы можно через $brks intervals$brks ## [1] 0.280564 2.663970 5.047377 7.430783 9.814190 12.197596 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Равные интервалы MIN/MAX&quot;) Cозданные интервалы хоть и равны, но не аккуратны. Зато метод классификации &quot;pretty&quot; создает также равные интервалы, но может слегка расширить диапазон или добавить 1 класс, чтобы получить границы интервалов, округленные до целых чисел: intervals &lt;- classIntervals(reg$X2015, n = nclasses, style = &quot;pretty&quot;) intervals$brks ## [1] 0 2 4 6 8 10 12 14 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Округленные равные интервалы&quot;) Квантили — равноколичественные интервалы. В каждом классе содержится одинаковое число объектов: intervals &lt;- classIntervals(reg$X2015, n = nclasses, style = &quot;quantile&quot;) intervals$brks ## [1] 0.280564 1.010486 1.157865 1.355618 2.557397 12.197596 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Квантили (равноколичественные)&quot;) Метод “естественных интервалов”, или метод Фишера-Дженкса позволяет найти классы, максимально однородные внутри и при этом максимально отличающиеся друг от друга. Иногда он неплохо угадывает переломы в шкале: intervals &lt;- classIntervals(reg$X2015, n = nclasses, style = &quot;jenks&quot;) intervals$brks ## [1] 0.280564 1.547936 2.557397 4.242080 7.231068 12.197596 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Естественные интервалы&quot;) Поскольку серия карт будет отображать динамику численности населения за разные годы, необходимо объединить все столбцы в один вектор, и найти классы на его основе, чтобы не упустить какие-то значения. Для этого нужно выбранные столбцы преобразовать сначала в матрицу, а потом в вектор: data &lt;- as.vector(as.matrix(tab[3:11])) # Воспользуемся еще раз методом естественных интервалов: intervals &lt;- classIntervals(data, n = nclasses, style = &quot;jenks&quot;) intervals$brks ## [1] 0.184857 1.717237 2.850417 5.085581 8.967232 12.197596 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Естественные интервалы&quot;) Теперь наша классификация учитывает полный набор исходных данных. 10.3 Серии карт lattice Lattice — графическая библиотека R, разработанная Дипайяном Саркаром для визуализации многомерных данных. Такие данные часто визуализируются в виде фасетных графиков (trellis graphs), упорядоченных в виде матрицы, где каждая ячейка (фасета) показывает поведение отдельной переменной или зависимость между \\(i\\)-й и \\(j\\)-й переменной. Фасетные графики весьма наглядны при выявлении закономерностей в набрах данных, содержащих множество переменных. Пакет lattice может использовать классы типа Spaital, доступные в историческом пакете sp для визуализации пространственных данных и тематического картографирования на их основе. В частности, lattice чрезвычайно удобна для построения серий карт способом картограмм. Однако мы помним, что старые классы пакета sp отличаются от классов sf, не являясь фреймами данных. Поэтому после подготовки информации необходимо привести данные от одного типа к другому. 10.3.1 Картограммы Для построения аналитических карт средствами lattice используется функция spplot() из пакета sp. В первый параметр функции передается пространственный слой с данными. Далее в параметр zcol = передаются имена столбцов, по которым мы хотим создавать карты, в параметр at= — границы классов, а цветовая палитра подставляется в параметр col.regions =: spreg &lt;- as(reg, &#39;Spatial&#39;) spplot(spreg, zcol = c(&quot;X1959&quot;, &quot;X1979&quot;, &quot;X2002&quot;, &quot;X2014&quot;), at = intervals$brks, col.regions = ramp(nclasses) ) Представьте, сколько времени вы бы потратили на оформление подобных карт в ГИС с аккуратной компоновкой? Необходимо привести в порядок легенду — чтобы подписи значений соответствовали границам классов. Для этого сформируем список names, содержащий параметры подписей: names &lt;- list(at = intervals$brks, labels = intervals$brks, cex = 1.0 ) # Теперь создадим параметры легенды в виде списка. Параметр labels отвечает за подписи, а width — за ширину legend &lt;- list(labels = names, width=3.0) # наконец, созданную легенду можно подставить в параметр colorkey= spplot(spreg, zcol = c(&quot;X1959&quot;, &quot;X1979&quot;, &quot;X2002&quot;, &quot;X2014&quot;), at = intervals$brks, col.regions = ramp(nclasses), colorkey = legend ) Вы можете создать классификацию и вручную. Для этого необходимо указать метод классификации &quot;fixed&quot;, а в параметр fixedBreaks передать заданные вами границы классификации. Иногда подобранные вручную классы позволяют выявить больше закономерностей в динамике значений: breaks &lt;-c(0,1,2.5,5,10,15) nclasses &lt;- length(breaks) - 1 intervals &lt;- classIntervals(data, nclasses, style = &quot;fixed&quot;, fixedBreaks=breaks) plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Пользовательские интервалы&quot;) names &lt;- list(at = intervals$brks, labels = intervals$brks, cex = 1.0 ) legend &lt;- list(labels = names, width=3.0) spplot(spreg, zcol = c(&quot;X1959&quot;, &quot;X1979&quot;, &quot;X2002&quot;, &quot;X2014&quot;), names.attr = c(&quot;1959&quot;, &quot;1979&quot;, &quot;2002&quot;, &quot;2014&quot;), at = intervals$brks, col.regions = ramp(nclasses), colorkey = legend ) 10.3.2 Картодиграммы Пакет lattice наиболее приспособлен к однослойному отображению информации, в котором основной графической переменной является цвет. Полигоны или точки на графике/карте раскрашиваются в разные цвета в зависимости от значения показателя. Несколько более сложен в реализации случай когда нужно варьировать размер символов в зависимости от показателя, а также совмещать на графике/карте несколько слоев. Однако удобство составления серии карт средствами lattice окупает усилия, затрачиваемые на проработку нюансов визуализации. В данном разделе мы посмотрим, как можно построить картодиаграммы средствами lattice, а также дополнить карту элементами общегеографической основы. Помимо этого вы узнаете, как можно ввести ступенчатую шкалу размеров символов и оформить для нее аккуратную легенду. Для решения поставленной задачи нам необходимо выполнить следующую последовательность действий: Получить точки для размещения картодиаграмм Создать шкалу размеров (диаметров) картодиаграмм в зависимости от класса Присвоить точкам классы и размеры в зависимости от численности населения Подготовить параметры легенды для картодиаграмм Подготовить список дополнительных слоев общегеографической основы Построить карту, используя преднастроенную легенду и дополнительные слои Прежде всего необходимо получить концептуальные точки для раземещения картодиаграмм. Вообще говоря, это задача не такая простая, как может показаться на первый взгляд, поскольку желательно обеспечить отсутствие взаимного перекрытия диаграмм и их размещение, максимально приближенное к визуальному центру территориальной единицы. Тем не менее, мы будем использовать простой подход, в котором точки для размещения картодиаграмм будут распределены в центрах соответствующих территориальных единиц: # Центроиды полигонов извлекаются так: centers &lt;- st_centroid(reg) head(centers) ## Simple feature collection with 6 features and 19 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 44.44885 ymin: 53.18403 xmax: 50.90853 ymax: 56.57916 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## TARGET_FID NAME_CNTR SUBJECT FED_OKRUG ## 1 0 Нижний Новгород Нижегородская обл. Приволжский ## 2 1 Пенза Пензенская обл. Приволжский ## 3 2 Йошкар-Ола Республика Марий Эл Приволжский ## 4 3 Саранск Республика Мордовия Приволжский ## 5 4 Казань Республика Татарстан (Татарстан) Приволжский ## 6 5 Самара Самарская обл. Приволжский ## ECON_RAY PopTotal PopUrban PopRural PopDelta Region ## 1 Волго-Вятский 3479.3 2725.9 753.4 1972.5 Нижегородская область ## 2 Поволжский 1436.0 938.1 497.9 440.2 Пензенская область ## 3 Волго-Вятский 721.9 457.1 264.8 192.3 Республика Марий Эл ## 4 Волго-Вятский 876.1 520.7 355.4 165.3 Республика Мордовия ## 5 Поволжский 3720.9 2741.7 979.2 1762.5 Республика Татарстан ## 6 Поволжский 3217.6 2594.3 623.3 1971.0 Самарская область ## X1959 X1970 X1979 X1989 X2002 X2010 X2013 X2014 ## 1 3.590274 3.682484 3.695523 3.714322 3.524028 3.310597 3.289841 3.281496 ## 2 1.507765 1.535970 1.503198 1.504309 1.452941 1.386186 1.368657 1.360587 ## 3 0.647680 0.684748 0.702744 0.749386 0.727979 0.696459 0.690349 0.688686 ## 4 1.001994 1.029562 0.990617 0.964132 0.888766 0.834755 0.818566 0.812156 ## 5 2.850417 3.131238 3.435644 3.637809 3.779265 3.786488 3.822038 3.838230 ## 6 2.258359 2.750926 3.092866 3.265586 3.239737 3.215532 3.213289 3.211187 ## X2015 geometry ## 1 3.270203 POINT (44.60672 56.31283) ## 2 1.355618 POINT (44.62895 53.18403) ## 3 0.687435 POINT (47.93081 56.57916) ## 4 0.808888 POINT (44.44885 54.36621) ## 5 3.855037 POINT (50.90853 55.35318) ## 6 3.212676 POINT (50.4624 53.28303) Можно проверить, что получилось, используя обычную функцию plot: plot(reg %&gt;% st_geometry()) plot(centers %&gt;% st_geometry(), pch = 20, add = TRUE) Ступенчатая шкала размеров картодиаграмм как правило строится с коэффициентом увеличения 1.2 – 1.4. То есть в каждом последующем классе диаметр кружка в 1.2 – 1.4 раза больше, чем в предыдущем: # Шкалу классификации картодиаграмм определим вручную fixed.breaks &lt;- c(0, 500, 1000, 2000, 5000, 10000, 15000) # подсчитаем количество граничных значений nbreaks &lt;- length(fixed.breaks) # подсчитаем количество классов nclasses &lt;- nbreaks-1 # подготовим вектор для размеров диаграмм size.classes &lt;- vector(mode = &#39;numeric&#39;, length = nclasses) # Зададим диаметр первого класса size.classes[1] &lt;- 2 # Построим остальные размеры по принципу увеличения в 1.3 раза for(i in 2:nclasses){ size.classes[i] &lt;- 1.3 * size.classes[i-1] } # Посмотрим, что получилось: plot(1:nclasses, rep(0, nclasses), pch = 20, cex = size.classes) Теперь разделим точки на классы для картодиаграммы. Для этого используем функцию cut(). Она позволяет разделить переданный вектор на интервалы и кодировать входящие в его состав элементы соответствующими номерами. Крайний левый интервал получает номер 1, следующий 2, и так далее. Это простая и одновременно мощная функция часто используется при обработке данных. Чтобы полученные интервалы кодировались не номерами, а сразу размерами, можно передать их в параметр labels. # Классифицируем каждый показатель: size1 &lt;- cut(centers$PopUrban, breaks = fixed.breaks, labels = size.classes, include.lowest = TRUE) size2 &lt;- cut(centers$PopRural, breaks = fixed.breaks, labels = size.classes, include.lowest = TRUE) А теперь — внимание! — чтобы lattice использовала указанные размеры для построения серии карт, их нужно объединить в один массив. При этом порядок объединения должен совпадать с порядком карт в параметре zcol = size &lt;- as.numeric(c(as.character(size1), as.character(size2))) columns &lt;- c(&quot;PopUrban&quot;, &quot;PopRural&quot;) # диаграммы будут зеленого полупрозрачного цвета diag.color &lt;- adjustcolor(&quot;green4&quot;, alpha.f = 0.5) # Пробуем строить карту spcenters &lt;- centers %&gt;% as(&#39;Spatial&#39;) spplot(spcenters, zcol = columns, cuts = fixed.breaks, # для точечного символа границы классов указываются в параметре cuts cex = size, # каждая диаграмма будет иметь свой размер pch = 20, # наличие pch означает, что визуализация будет производиться с помощью точечных символов col.regions = diag.color, # устанавливаем красный полупрозрачный цвет names.attr = c(&quot;Городское&quot;, &quot;Сельское&quot;), main = list(&quot;Население&quot;, cex = 2.0, just=&quot;centre&quot;), as.table = TRUE # осуществлять прорисовку карт сверху вниз, слева направо ) 10.3.3 Легенда и компоновка В данном разделе мы посмотрим, как можно привести легенду и компоновку карты в аккуратный вид. Перед нами стоят следующие задачи: Перенсти легенду вправо от карты, поскольку она имеет вертикальную ориентировку и ее расположение снизу графически неуместно. Сформировать аккуратные подписи классов численности населения в формате “от - до” Заменить бледно-оранжевый цвет заголовков фасет на более нейтральный серый, который лучше сочетается с зеленым цветом диаграмм. Уменьшить шрифт заголовков фасет. Тонкая настройка легенды предполагает ее полностью ручное формирование. С этого и следует начать: # Сформируем список параметров значков, включая тип символа, цвет и размеры: legend.points &lt;- list(pch = 20, col = diag.color, cex = size.classes) Для создания подписей классов в легенде в формате “от - до” можно сначала сформировать вектора верхних (high) и нижних (low) границ классов, а далее вставить их друг в друга, дополнив разделителем &quot; — “. На выходе получим вектор той же длины, что и исходные. При этом каждый \\(i\\)-й его элемент будет результатом конкатенации \\(i\\)-го элемента из вектора low, разделителя и \\(i\\)-го элемента из массива high. Элегантно и просто! # сделаем отдельные вектора для левых и правых границ интервалов: low &lt;- fixed.breaks[1:nbreaks-1] high &lt;- fixed.breaks[2:nbreaks] # вставим вектора друг а друга. Метки должны быть оформлены как список, # поэтому дополнительно оборачиваем результат вставки в list(): labels = list(paste(low, &quot; — &quot;, high)) # Наконец, сформируем параметры легенды: legend &lt;- list(points = legend.points, # символы text = labels, # подписи columns = 1, # количество столбцов between = 0, # расстояние между строками reverse.rows = TRUE, # сортировка элементов padding.text = 10.0, # отступ подписи от символа title = &quot;Тыс.чел&quot;, # заголовок cex.title = 1.3 # масштаб шрифта заголовка ) Наконец, графические параметры lattice, отвечающие за цвет, масштаб и прочие параметры отображения элементов графиков, настраиваются с помощью параметров семейства par. В частности: par.settings — общие графические параметры lattice par.strip.text — параметры текста в заголовках фасет Используем эти параметры при итоговом выводе карт для настройки отображения заголовков фасет: # Построим карту spplot(spcenters, zcol = columns, cuts = fixed.breaks, cex = size, pch = 20, col.regions = diag.color, key.space=&quot;right&quot;, # местоположение легенды key = legend, # легенда names.attr = c(&quot;Городское&quot;, &quot;Сельское&quot;), main = list(&quot;Население&quot;, cex = 2.0, just=&quot;centre&quot;), par.settings = list(strip.background = list(col = &quot;lightgrey&quot;)), # меняем цвет шапки каждой фасеты на серый par.strip.text = list(cex = 0.9), # уменьшаем размер шрифта в каждой фасете as.table = TRUE # осуществлять прорисовку карт сверху вниз, слева направо ) С дополнительными параметрами легенды и принципами ее построения вы можете ознакомиться в справке к функции spplot(). Далее рассмотрим, как можно на карты, создаваемые средствами lattice, добавлять точки, линии и полигоны для визуализации элементов географической основы. 10.3.4 Элементы картографической основы Функция spplot() имеет параметр sp.layout, в который можно передать список дополнительных слоев, которые необходимо нанести на карту. Каждый слой, в свою очередь, тоже следует оформить как список. Первым параметром списка должен быть тип слоя, которы может принимать одно из значений sp.polygons, sp.lines, sp.points, sp.text. Остальные параметры указываются так же как и в функции plot(), с которой мы познакомились ранее: # Читаем исходные данные splakes &lt;- st_read(&quot;Lakes.gpkg&quot;) %&gt;% as(&#39;Spatial&#39;) ## Reading layer `Lakes&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Lakes.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2 features and 6 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 37.15078 ymin: 53.26958 xmax: 51.93652 ymax: 59.20977 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs sprivers &lt;- st_read(&quot;Rivers.gpkg&quot;) %&gt;% as(&#39;Spatial&#39;) ## Reading layer `Rivers&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Rivers.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 4 features and 3 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 32.59825 ymin: 45.65675 xmax: 50.14849 ymax: 58.28755 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs spcities &lt;- st_read(&quot;Cities.gpkg&quot;) %&gt;% as(&#39;Spatial&#39;) ## Reading layer `Cities&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Cities.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 10 features and 12 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 37.55257 ymin: 46.37541 xmax: 50.2463 ymax: 57.65914 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs # Настройки отображения городов layout.cities &lt;- list(&quot;sp.points&quot;, spcities, pch = 19, cex = 0.75, col = &quot;black&quot;) # Настройки отображения рек layout.rivers &lt;- list(&quot;sp.lines&quot;, sprivers, col = &quot;steelblue3&quot;, lwd = 1, first = TRUE) # Собираем в один список для передачи в spplot() layout &lt;- list(layout.rivers, layout.cities) Слои будут нарисованы именно в том порядке, в котором они объединены в списке, то есть в данном случае сначала реки, затем города (поверх рек). Это правило по умолчанию не распространяется на полигональные слои. Стандартное поведение spplot() устроено таким образом, что сначала будут нарисованы полигональные слои из sp.layout, затем основное содержание карты (obj + zcol), а затем линейные, точечные и текстовые слои из sp.layout. Чтобы рисовать полигональные вместе с остальными элементами sp.layout, необходимо дополнительно задать им параметр first = FALSE. В этом случае все слои sp.layout будут нарисованы поверх тематического содержания в том порядке, в котором они перечислены в списке. Это, однако, может быть нежелательным поведением в случае картодиаграмм, поскольку полигональные объекты могут перекрыть кружки. В таком случае следует задать всем элементам sp.layout, которые должны быть нарисованы под тематическим содержанием, параметр first = TRUE. # Границы регионов layout.reg &lt;- list(&quot;sp.polygons&quot;, spreg, lwd = 0.5, col = &quot;slategrey&quot;, first = TRUE) # Озера layout.lakes &lt;- list(&quot;sp.polygons&quot;, splakes, col = &quot;steelblue3&quot;, fill = &quot;lightblue1&quot;, lwd = 0.5, first = TRUE) # Подписи городов layout.text &lt;- list(&quot;sp.text&quot;, coordinates(spcities), spcities$name_2, cex = 0.75, pos = 2) layout &lt;- list(layout.reg, layout.rivers, layout.lakes, layout.cities, layout.text) Наконец, после многочисленных приготовлений мы имеем возможность насладиться результатами наших усилий. Есть, однако еще один финальный штрих, который призван обеспечить правильный экстент (охват) карты. По умолчанию spplot() ограничивает область построения карты экстентом слоя, который передается в параметр obj. В нашем случае это будут точки, которые размещены в географических центрах регионов. Однако мы хотим, чтобы каждая карта вмещала в себя все регионы и не была обрезана по местоположениям центроидов. Чтобы это обеспечить, необходимо указать дополнительные параметры xlim и ylim, которые работают аналогично функции plot(). Еще одним отличие от способа картограмм заключается в том, что необходимо вместо параметра at, который позволяет менять только цвет, использовать параметр cuts, применимый к точечным слоям. # Вычислим экстент регионов extent &lt;- st_bbox(reg) # Построим карту spplot(spcenters, zcol = columns, cuts = fixed.breaks, cex = size, pch = 20, col.regions = diag.color, xlim = c(extent[1], extent[3]), ylim = c(extent[2], extent[4]), key.space=&quot;right&quot;, # местоположение легенды sp.layout = layout, # дополнительные слои key = legend, # легенда names.attr = c(&quot;Городское&quot;, &quot;Сельское&quot;), main = list(&quot;Население&quot;, cex = 2.0, just=&quot;centre&quot;), par.settings = list(strip.background = list(col = &quot;lightgrey&quot;)), par.strip.text = list(cex = 0.9), as.table = TRUE # осуществлять прорисовку карт сверху вниз, слева направо ) Как видно, создание картодиаграмм в lattice — задача, требующая тщательной настройки параметров spplot. С другой стороны, единожды написав подобный код, вы далее можете его использовать при построении карт на основе других данных, меняя лишь содержимое входных параметров. В этом и заключается одно из преимуществ программной визуализации данных. 10.4 Карты растров 10.4.1 Одиночный растр Рассмотрим задачу тематического картографирования по растровым данным на примере информации о среднеклиматических температурах по разным месяцам, полученной с портала worldclim.org. Для работы с растровыми данными воспользуемся уже знакомым пакетом raster. library(raster) # Прочитаем растровый файл temp &lt;- raster(&quot;tmean_1.tif&quot;) # Проверим, какой он имеет класс: class(temp) ## [1] &quot;RasterLayer&quot; ## attr(,&quot;package&quot;) ## [1] &quot;raster&quot; # попробуем вывести растр на экран: plot(temp) Видно, что растр хранит температуры, умноженные на 10 (это позволяет делать его целочисленным), нужно привести их к истинным значениям: temp &lt;- temp/10 plot(temp) Чтобы изображение стало больше похоже на карту температур, необходимо задать цветовую шкалу, соответствующую отображаемому диапазону температур, а также классифицировать растр, то есть разбить его на равные интервалы температур и отобразить каждый интервал своим цветом, выбранным из палитры. Чтобы классифицировать растр методом равных интервалов с заданным шагом, нужно для начала определить минимальную и максимальную температуры. Для этого можно воспользоваться функцией cellStats() из пакета raster. # создадим цветовую палитру в синих тонах pal &lt;- colorRampPalette(c(&quot;dodgerblue4&quot;,&quot;dodgerblue1&quot;)) # вычислим минимум и маскимум температуры min &lt;- cellStats(temp, &quot;min&quot;) max &lt;- cellStats(temp, &quot;max&quot;) # определим ширину интервала температур равной 2.5 градусам step &lt;- 2.5 # вычислим границы равных интервалов, используя функцию fullseq() из пакета scales library(scales) levels &lt;- fullseq(c(min, max), step) # определим количество полученных интервалов nclasses &lt;- length(levels)-1 # визуализируем данные plot(temp, breaks = levels, # в breaks подставляем границы интервалов col = pal(nclasses)) Можно совмещать растровые и векторные данные, наносить подписи и сетку координат. Для добавления новых слоев следует вызывать функцию plot() с параметром add = TRUE. Подписи объектов наносятся по координатам с помощью функции text(): # визуализируем данные plot(temp, breaks = levels, # в breaks подставляем границы интервалов col = pal(nclasses)) plot(spreg, border = &quot;black&quot;, add = TRUE, lwd = 0.3) plot(sprivers, col = &quot;midnightblue&quot;, add = TRUE, lwd = 1) plot(splakes, col = &quot;steelblue1&quot;, add = TRUE, lwd = 0.5) plot(spcities, add = TRUE, pch = 20) pts &lt;- coordinates(spcities) text(pts[,1], pts[,2], labels = spcities$name_2, cex = 0.8, pos = 3) grid(col=&quot;grey20&quot;) 10.4.2 Серия растров Теперь посмотрим на задачу визуализации в более широком ракурсе. В нашем распоряжении имеется 12 месяцев, и мы хотим построить серию карт среднемесячных температур в единой шкале, чтобы карты можно было сравнивать друг с другом. Для этого нам необходимо: Предложить цветовую палитру, которая покрывает теплые и холодные месяцы года. Вычислить интервалы, покрывающие полный размах температур — от самой холодной до самой теплой точки года. Шкалу выберем стандартную от синего к белому в области отрицательных температур и от белого к оранжевому в области положительных температур. colors &lt;- c(&quot;dodgerblue4&quot;,&quot;white&quot;,&quot;orange&quot;,&quot;firebrick&quot;) pal &lt;- colorRampPalette(colors) # Можно, кстати, визуализировать полученные цвета как пиксельное изображение: ncolors &lt;- length(colors) image(x = 1:ncolors, y = 1, z = as.matrix(1:ncolors), col = colors) Чтобы интервалы охватывали все месяцы года, необходимо просмотреть все 12 файлов и найти минимум и максимум температуры. Вообще, задачу поиска минимума или максимума в неупорядоченном множестве из N элементов можно решить следующим образом: Принимается, что минимум (максимум) равен первому элементу Организуется цикл от 2-го до N-ного элемента. На каждой итерации цикла выполняется проверка: если текущий элемент меньше (больше), чем минимум (максимум), то приравнять минимум (максимум) текущему элементу. По завершению выполнения цикла будет найден минимальный (максимальный) элемент множества. В нашем случае элементами являются файлы температур по месяцам, текущее значение будет вычисляться как минимум или максимум во всем пикселам текущего растра. # Примем условно, что минимум и максимум содержатся в первом файле min &lt;- cellStats(temp, &quot;min&quot;) max &lt;- cellStats(temp, &quot;max&quot;) # Создадим список для растров, чтобы прочитать их единожды и далее использовать во всех циклах rasters &lt;- vector(mode = &quot;list&quot;, length = 12) # Запишем первый растр в список rasters[[1]] = temp # Пройдемся по остальным файлам и сравним их минимумы и максимумы с текущим for (i in 2:12){ # сформируем имя файла file &lt;- paste(&quot;tmean_&quot;, i, &quot;.tif&quot;, sep=&quot;&quot;) # прочитаем файл temp &lt;- raster(file)/10 # Запишем текущий растр в список rasters[[i]] &lt;- temp # вычислим текущий минимум и максимум vmin &lt;- cellStats(temp, &quot;min&quot;) vmax &lt;- cellStats(temp, &quot;max&quot;) # выясним, не меньше ли текущее значение, чем тот минимум, что мы храним if(vmin &lt; min){ min &lt;- vmin # если да, то заменим минимум на текущее значение } # аналогично для максимума if(vmax &gt; max){ max &lt;- vmax } } cat(&quot;Минимальная температура - &quot;, min) ## Минимальная температура - -14.8 cat(&quot;Максимальная температура - &quot;, max) ## Максимальная температура - 25.6 # Если предположить, что температуры будут визуализироваться # с шагом 2.5 градуса, то шкалу сечения можно посчитать автоматически # Рассчитаем границы классов, покрывающие диапазон данных, # используя удобную функцию fullseq() из пакета scales levels &lt;- fullseq(c(min, max), step) # Количество интервалов в шкале равно количеству граничных значений -1 nclasses &lt;- length(levels)-1 # Выведем теперь данные на экран plot(temp, breaks = levels, col = pal(nclasses)) # легенду можно сделать и покрасивее. За ширину шкалы отвечает параметр # legend.width, а за ее растяжение по высоте — legend.shrink. # Если legend.shrink = 1, то легенда будет по высоте такой же как и карта: plot(temp, breaks = levels, col = pal(nclasses), legend.shrink = 1, legend.width = 1.5) # вы также можете более тонко настроить параметры легенды растрового слоя, используя # аргументы legend.args и axis.args. Оба параметра являются списками # legend.args отвечает за заголовок легенды, # axis.args отвечает за шкалу подписей. legendargs &lt;- list(text=&#39;°С&#39;, side=3, font=2, line=0.3, cex=0.8) axisargs &lt;- list(cex.axis=0.7) # сделаем поля поуже: par(mar=c(6,3,5,1)+0.1) # и по 2 графика на строку par(mfrow = c(1,2)) months&lt;-c(&quot;Январь&quot;,&quot;Февраль&quot;, &quot;Март&quot;, &quot;Апрель&quot;, &quot;Май&quot;, &quot;Июнь&quot;, &quot;Июль&quot;, &quot;Август&quot;, &quot;Сентябрь&quot;, &quot;Октябрь&quot;, &quot;Ноябрь&quot;, &quot;Декабрь&quot;) for (i in 1:12){ plot(rasters[[i]], breaks = levels, col = pal(nclasses), legend.mar = 4.5, legend.shrink = 1, legend.width = 1.5, legend.args = legendargs, axis.args = axisargs, main = months[i] ) plot(spreg, border = &quot;black&quot;, add = TRUE, lwd = 0.3) plot(sprivers, col = &quot;midnightblue&quot;, add = TRUE, lwd = 1) plot(splakes, col = &quot;steelblue1&quot;, add = TRUE, lwd = 0.5) plot(spcities, add = TRUE, pch = 20) pts &lt;- coordinates(spcities) text(pts[,1], pts[,2], labels = spcities$name_2, cex = 0.8, pos = 3) grid(col=&quot;grey20&quot;) } Еще проще можно сделать карту с серией растров, используя функцию spplot, которая доступна в пакетах sp и raster при наличии установленного пакета lattice. Здесь для построения серии карт необходимо из множества растров сделать растровый стек (см. раздел по многоканальным растрам в предыдущей лекции): library(lattice) raster.stack &lt;- stack(rasters) names &lt;- list(at = levels, labels = levels) legend &lt;- list(labels = names) spplot(raster.stack, at = levels, col.regions = pal(nclasses), names.attr = months, colorkey = legend, main = &quot;Среднемноголетняя температура&quot;, sub = &quot;Карта составлена по данным WorldClim.org&quot;) 10.5 Экспорт изображения в графический файл Для экспорта изображения в графический файл существует ряд функций типа &lt;format&gt;(filename, width, height,...), где вместо &lt;format&gt; может быть один из форматов pdf, png, jpg, tiff, bmp. Растровые графические форматы png, jpg, tiff, bmp удобны для экспорта единичных изображений. Если же необходимо эксопртировать серию изображений, то лучше остановить свой выбор на файлах формата PDF. Помимо этого, формат PDF необходим, если необходимо сохранить векторное представление соответствующих слоев данных. Каждый раз, когда вы вызываете одну из вышеперечисленных функций, графическая подсистема R открывает новое “устройство” вывода, каким и является указанный в параметрах графический файл. После этого вы можете вызывать инструкции построения графиков и карт. Чтобы завершить рисование в файл, необходимо вызвать функцию dev.off(), которая закрывает нестандартное устройство. Важно: при выводе в файл функцию par(), устанавливающую графические параметры, необходимо вызывать после открытия устройства вывода. В противном случае параметры окажут свое влияние на стандартное устройство вывода 10.5.1 Одностраничные файлы PNG Например, чтобы экспортировать изображение размером \\(500 \\times 500\\) за март в файл PNG, можно написать следующий код: png(&quot;October.png&quot;, width = 500, height = 500) plot(rasters[[10]], breaks = levels, col = pal(nclasses), legend.mar = 4.5, legend.shrink = 1, legend.width = 1.5, legend.args = legendargs, axis.args = axisargs, main = months[10] ) dev.off() # Важно: завершаем рисование в файл Или, например, экспортировать все изображения в один большой постер размером 30 на 40 сантиметров с разрешением 300 точек на дюйм: png(&quot;Allmonths.png&quot;, width = 40, height = 30, units = &quot;cm&quot;, res = 300) par(mar=c(5,4,5,6)) par(mfrow = c(3,4)) for (i in 1:12){ plot(rasters[[i]], breaks = levels, col = pal(nclasses), legend.mar = 4.5, legend.shrink = 1, legend.width = 1.5, legend.args = legendargs, axis.args = axisargs, main = months[i] ) } dev.off() # Важно: завершаем рисование в файл 10.5.2 Многостраничные файлы PDF С файлами PDF имеются некоторые нюансы, cвязанные с тем, что стандартное устройство pdf() может испытывать сложности с трансляцией кириллического текста. Зато таких сложностей не испытывает пакет Cairo, которым мы и воспользуемся. Работает Cairo точно так же, как и другие функции экспорта: # по умолчанию ширина и высота задаются в дюймах CairoPDF(&quot;Results.pdf&quot;, width = 10, height = 10) par(mfrow=c(2,2)) par(mar=c(5,4,5,6)) for(i in 1:12){ plot(rasters[[i]], breaks = levels, col=pal(nclasses), legend.mar=4.5, legend.shrink = 1, legend.width = 1.5, legend.args = legendargs, axis.args = axisargs, axes = FALSE ) # Далее повторим инструкции по выводу остальных слоев и подписей: plot(spreg, border=&quot;black&quot;, add=TRUE, lwd=0.3) plot(sprivers, col=&quot;midnightblue&quot;, add=TRUE, lwd=1) plot(splakes, col=&quot;steelblue1&quot;, add=TRUE, lwd=0.5) plot(spcities, add=TRUE, pch=20) text(pts[,1], pts[,2], labels = cities$name_2, cex = 0.8, pos = 3) # Сделаем шаг по оси X равным 5 градусов, а по Y — 4 градуса xseq = seq(30,55,by=5) yseq = seq(46,60,by=4) # Сформируем подписи координат, включающие значок градуса: xlabels &lt;- paste(xseq, &quot;°&quot;, sep=&quot;&quot;) ylabels &lt;- paste(yseq, &quot;°&quot;, sep=&quot;&quot;) # Выведем на экран ось X и Y axis(1, at = xseq, labels = xlabels) axis(2, at = yseq, labels = ylabels) # Нанесем сетку вручную, используя функцию abline(): abline(h=yseq, lty=3, col=&quot;grey20&quot;) abline(v=xseq, lty=3, col=&quot;grey20&quot;) # Нанесем заголовок карты title(main=months[i], sub=&quot;Среднемесячная температура&quot;) # Нанесем box(&quot;plot&quot;, lwd=2) } dev.off() # Важно: завершаем рисование в файл Если вам необходимо построить географическую сетку непрямоугольного вида (для карт мира или континентов), то можно воспользоваться функцией gridlines(). Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "],
["vector-analysis.html", "Глава 11 Пространственный анализ 1. Векторные методы 11.1 Пространственные запросы 11.2 Постановка задач и изучение данных 11.3 Анализ расстояний 11.4 Анализ взаимного положения (топологический) 11.5 Анализ абсолютных зон окружения 11.6 Анализ конкурентных зон окружения 11.7 Анализ зон транспортной доступности 11.8 Построение маршрутов и матриц времени движения", " Глава 11 Пространственный анализ 1. Векторные методы Программный код главы Данный модуль посвящен пространственному анализу в R. Несмотря на то, что пространственный анализ — чрезвычайно широкая и многогранная область геоинформатики, все методы, которые объединяются под этим заголовком, базируются на ограниченном числе базовых операций, таких как вычисление расстояний, оценка плотности распределения, построение буферных зон и выполнение пространственных запросов. В настоящем модуле мы рассмотрим, как одно и то же множество пространственных объектов можно анализировать в различных контекстах, используя базовые методы пространственного анализа Пространственный анализ связан с оценкой размещения объектов и распределения величин в географическом пространстве. В геоинформатике для этих целей используется два подхода: геометрический и статистический. Эти подходы образуют две ступени пространственного анализа: как правило, данные геометрического анализа представляют собой входную информацию для анализа статистического. Геометрический подход связан с вычислением расстояний между географическими локациями, а также агрегированием объектов/интегрированием показателей в пределах заданных областей, вдоль линий или в окрестности точек. Поиск входной информации для агрегирования решается путем выполнения пространственных запросов. 11.1 Пространственные запросы Пространственные запросы связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве пространственных отношений. В свою очередь, пространственные отношения бывают трех типов: дирекционные (направления), метрические (расстояния) и топологические (взаимное размещение). Примеры пространственных запросов знакомы любому географу: Найти все объекты внутри административного района (топологические отношения) Найти все объекты не далее 100 метров от дороги (метрические отношения) Найти все объекты, расположенные к северу от точки (дирекционные отношения) Пространственные запросы могут объединять несколько условий. Можно найти объекты, удовлетворящие одновременно всем (логическое И) вышеперечисленным условиям: внутри района, не далее 100 м от дороги и к северу от выбранной точки; или хотя бы одному (логическое ИЛИ) из вышеперечисленных условий. Результат выполнения такого комплексного запроса будет являться, соотвественно, пересечением множеств объектов, полученных каждым из запросов, или их объединением. Наконец, пространственные запросы можно объединять с атрибутивными и временными. Атрибутивные запросы связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве характеристик объектов. Временные запросы определены на множестве шкалы времени. Например, можно найти все населенные пункты населением свыше 10 000 человек (атрибутивный запрос), находящиеся в пределах выбранного административного района (пространственный запрос, основанный на топологических отношениях), время движения от которых до районного центра не превышает 90 минут (временной запрос). 11.1.1 Контекстные и целевые объекты При выполнении пространственного анализа, в общем случае, имееются множества объектов двух типов: контекстные — объекты, относительно которых будет оцениваться размещение других объектов, то есть, определяющие контекст анализа целевые — объекты, размещение которых анализируется по отношению к контекстным объектам, что является целью анализа Эти множества, разумеется, могут совпадать. Скажем, мы можем проанализировать размещение магазинов относительно других магазинов. 11.1.2 Зоны окружения объектов Весьма часто в качестве контекстного множества используются не реальные пространственные объекты, а набор абстрактных геометрических объектов, каждый из которых является производным от оригинального пространственного объекта. Как правило, такие геометрии представляют из себя зоны окружения объектов, построенные по некоторому формальному признаку. Методы построения зон окружения можно разделить по двум критериям: учету взаимного размещения объектов (абсолютные и конкурентные зоны) и пространству признаков, в котором эти зоны строятся. Если зоны окружения строятся без учета взаимного размещения объектов, то есть, независимо для каждого объекта, то мы будем называть их абсолютными. Абсолютные зоны окружения строятся путем фиксации порогового расстояния либо времени движения относительно исходного объекта. Такие зоны носят название буферных зон (по расстоянию) или зон доступности (по времени). Границей абсолютной зоны окружения является изолиния, построенная по соответствующему показателю. В случае времени это будет изохрона. Примеры абсолютных зон окружения: Водоохранная зона реки 200 метров (буферная зона) Площадь городской территории, в любую точку которой вы можете доехать из дома на машине в течение 30 минут (зона доступности) Если же при построении зон окружения учитывается взаимное размещение объектов, то в данном случае зоны доступности строятся не исходя из порогового значения показателя (хотя оно может использоваться дополнительно), а исходя из того, какой объект является ближайшим. Конкурентные зоны окружения представляют собой разбиение пространства на неперекрывающиеся участки без дыр, каждый из которых является зоной окружения соответствующего пространственного объекта. При этом любая точка внутри зоны окружения объекта ближе к этому объекту по выбранному признаку (времени или расстоянию), нежели к любому другому объекту. Конкурентные зоны окружения, построенные по расстоянию, можно реализовать средствами диаграммы Вороного. 11.2 Постановка задач и изучение данных В настоящем моделе мы рассмотрим вышеперечисленные методы на примере анализа размещения пунктов общественного питания — кафе, ресторанов и т.д. Используя методы пространственного анализа в среде R, мы ответим на следующие вопросы: Какие улицы являются местами наибольшей концентрации заведений общественного питания? Как распределены заведения общественного питания по районам центра Москвы? Какие заведения общественного питания находятся вблизи метро и на берегу реки? В какие заведения общественного питания можно доехать от выбранной точки в течение 5 минут? Каков оптимальный маршрут между вашим местоположением и заведением, в котором вы хотите пообедать? В качестве источника данных используем OpenStreetMap — краудсорсинговый интернет-проект по созданию бесплатных и открытых пространственных данных глобального охвата. Данные OpenStreetMap в удобном для использования в ГИС виде доступны на портале GIS-Lab. Для решения задач настоящего модуля нам понадобятся следующие дополнительные пакеты, которые мы не использовали ранее: osrm — построение зон доступности, маршрутов и матриц корреспонденции онлайн на основе данных OpenStreetMap и OSRM API. cartography — пакет, облегчающий построение тематических карт и легенд средствами стандартной функции plot(). Начнем наше исследование с визуального анализа исходных данных library(sf) library(dplyr) library(classInt) library(osrm) # Использование онлайн-сервиса маршрутизации OSRM library(cartography) # Удобное построение тематических карт средствами plot() # Чтение данных roads &lt;- st_read(&quot;roads.gpkg&quot;) # Дороги poi &lt;- st_read(&quot;poi_point.gpkg&quot;) # Точки интереса rayons &lt;- st_read(&quot;boundary_polygon.gpkg&quot;) # Границы районов stations &lt;- st_read(&quot;metro_stations.gpkg&quot;) # Станции метро water &lt;- st_read(&quot;water_polygon.gpkg&quot;) # Водные объекты # Прочитаем текущие параметры компоновки def &lt;- par(no.readonly = TRUE) # Уберем поля, чтобы карта занимала весь экран par(mar = c(0,0,0,0)) # Получим ограничивающий прямоугольник слоя дорог в качестве общего охвата карты frame &lt;- roads %&gt;% st_bbox() %&gt;% st_as_sfc() %&gt;% st_geometry() ## ОБЗОР ИСХОДНЫХ ДАННЫХ ------------------------------------- # Визуализируем входные данные plot(frame) plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray70&quot;, add = TRUE) plot(poi %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.2, add = TRUE) Теперь приступим к изучению данных, хранящихся в слое poi (от англ. POI — Point Of Interest). Данный слой содержит все точечные маркеры OSM, которыми были отмечены на карте объекты, представляющие (по мнению создателей данных) интерес для пользователей. В POI включаются самые разнообразные объекты, такие как: объекты сферы услуг (amenity), места для отдыха (leisure), офисные здания (office), магазины и торговые центры (shop), туристические достопримечательности (tourism), спортивные объекты (sport), примечательные инженерные сооружения (man_made). В наших данных информация разнесена по соответствующим полям, каждый объект снабжен уникальным идентификатором: View(poi) Заведения общественного питания по классификатору OSM относятся к классу amenity. Поскольку данный классификатор представляет собой множество номинальных (категориальных) данных, можно начать изучение состава данных с помощью таблицы частот, которая строится средствами функции table(): stats &lt;- data.frame(table(poi$AMENITY)) View(stats) Для дальнейшего анализа отберем из всего множества объектов сферы услуг заведения, где можно поесть: рестораны, кафе, бары, пабы и заведения быстрого питания (фастфуд). В классификаторе OSM эти заведения имеют тип restaurant, bar, cafe, pub и fast_food. Для отбора нужных строк и столбцов используем dplyr: poi.food &lt;- poi %&gt;% select(NAME, AMENITY) %&gt;% filter(AMENITY %in% c(&quot;restaurant&quot;, &quot;bar&quot;, &quot;cafe&quot;, &quot;pub&quot;, &quot;fast_food&quot;)) head(poi.food) ## Simple feature collection with 6 features and 2 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 410954.9 ymin: 6178842 xmax: 411023.8 ymax: 6181896 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs ## NAME AMENITY geometry ## 1 Аршин restaurant POINT (410975.2 6181661) ## 2 Андерсон restaurant POINT (410954.9 6180118) ## 3 Holynoot fast_food POINT (410958.8 6179938) ## 4 Gayane&#39;s restaurant POINT (410958.4 6178842) ## 5 Molon Lave restaurant POINT (411013.7 6181448) ## 6 Шоколадница cafe POINT (411023.8 6181896) 11.3 Анализ расстояний Метрические отношения связывают объекты в терминах расстояний между ними. Предположим, что мы хотим определить улицы, являющиеся сосредоточением заведений питания. Один из вариантов решения состоит в том, чтобы для каждого пункта обслуживания определить ближайшую к нему улицу и далее для каждой улицы просуммировать количество раз, которое улиц оказалось ближайшей. Подробнее алгоритм решения выглядит следующим образом: Вычислить матрицу расстояний между пунктами обслуживания и улицами. Размер матрицы \\(M \\times N\\), где \\(M\\) — количество улиц (строк), \\(N\\) — количество пунктов (столбцов) Найти в каждом столбце минимальное расстояние. Получить идентификатор улицы (номер строки), соответствующий данному расстоянию. Записать идентификатор в выходной вектор. Таким образом, мы получим вектор из идентификаторов улиц, при этом каждый идентификатор будет встречаться в этом векторе столько раз, сколько раз данная улица оказалась ближайшей к какому-то объекту. Вычислим матрицу расстояний с помощью функции st_distance() из пакета sf: ## АНАЛИЗ РАССТОЯНИЙ ------------------------------------- dist.matrix &lt;- st_distance(roads, poi.food) # посмотрим, как выглядит результат на примере первых пяти объектов print(dist.matrix[1:5,1:5]) ## Units: m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 4962.292 3420.6849 3240.2066 2145.2044 4748.686 ## [2,] 2247.737 705.2923 524.9411 570.3986 2035.341 ## [3,] 2213.236 670.7904 490.4167 605.1606 2000.759 ## [4,] 2197.874 655.4285 475.0629 620.4411 1985.242 ## [5,] 3910.957 2368.5560 2188.1348 1092.5472 3698.246 Далее необходимо в каждом столбце матрицы найти номер строки с минимальным расстоянием. Для этого необходимо получить порядок сортировки элементов по возрастанию значений данного столбца и взять номер первого элемента. Операцию можно применить с помощью apply ко всем столбцам: ids &lt;- apply(dist.matrix, 2, function(X) order(X)[1]) Теперь применим уже знакомую нам функцию table(), чтобы подсчитать, сколько раз каждая улица оказалась наиболее близкой. Далее присоединим статистику к исходным улицам, однако для этого нам потребуется вынести названия строк (номеров) улиц в отдельный столбец. count.stats &lt;- as.data.frame(table(ids)) roads &lt;- roads %&gt;% mutate(id = row.names(.)) roads.poi &lt;- merge(roads, count.stats, by.x = &#39;id&#39;, by.y = &#39;ids&#39;, all.x = T) Посмотрим первые 10 улиц по количеству общепита: # Статистика по улицам в табличном представлении (первые 10) roads.poi %&gt;% select(NAME, Freq) %&gt;% arrange(desc(Freq)) %&gt;% head(10) ## Simple feature collection with 10 features and 2 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 411105.1 ymin: 6178083 xmax: 414504.1 ymax: 6181734 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs ## NAME Freq geometry ## 1 улица Арбат 43 MULTILINESTRING ((412157.9 ... ## 2 улица Новый Арбат 24 MULTILINESTRING ((411105.1 ... ## 3 Цветной бульвар 22 MULTILINESTRING ((413491.7 ... ## 4 Мясницкая улица 20 MULTILINESTRING ((414504.1 ... ## 5 Никольская улица 17 MULTILINESTRING ((413704.5 ... ## 6 Пятницкая улица 17 MULTILINESTRING ((413895.8 ... ## 7 Неглинная улица 14 MULTILINESTRING ((413498.2 ... ## 8 улица Рождественка 14 MULTILINESTRING ((413628.1 ... ## 9 Козицкий переулок 14 MULTILINESTRING ((412831.7 ... ## 10 улица Большая Дмитровка 14 MULTILINESTRING ((413262.7 ... Для завершения анализа осталось визуализировать результаты. Чтобы усилить наглядность визуализации, мы не будем каждую улицу утолщать пропорционально количеству привязанных объектов, а разделим это количество на 4 класса. Каждый класс покажем линией соответствующей толщины и интенсивности цвета (чем больше объектов привязано к улице, тем толще линия, темнее и насыщеннее ее цвет). Для классификации используем функцию cut(), позволяющую перекодировать интервальные данные в номинальные, то есть сопоставить каждому элементу вектора некий класс, которому он принадлежит. На выходе будем иметь вектор, который состоит из такого же количества элементов, что и исходный, но вместо исходных значений будут стоять названия классов. # Получим границы классов nclasses &lt;- 4 class.breaks &lt;- classIntervals(roads.poi$Freq, n = nclasses, style = &quot;jenks&quot;) # Извлечем граничные интервалы borders &lt;- class.breaks$brks # Названия классов — они же толщины линия от 1 до 4 line.widths &lt;- 1:nclasses # Перекодируем столбец количества присоединенных пунктов в классы sizes &lt;- cut(roads.poi$Freq, breaks = borders, labels = line.widths) Теперь присвоим каждому объекту свой цвет в соответствии с классом, который ему присвоен. Удобная функция findColours() позволяет найти цвет для каждого объекта в соответствии с полученной классификацией: base.colors &lt;- c(&quot;mistyrose&quot;, &quot;red&quot;) ramp &lt;- colorRampPalette(base.colors) colors &lt;- findColours(class.breaks, base.colors) plot(frame) plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray70&quot;, add = TRUE) plot(roads.poi %&gt;% st_geometry(), lwd = sizes, col = colors, add = TRUE) plot(poi.food %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.2, add = TRUE) # Функция legendGradLines из пакета cartography позволяет строить # легенду для карт линий градуированных размеров: legendGradLines(title.txt = &quot;Пункты питания&quot;, pos = &quot;left&quot;, title.cex = 0.8, values.cex = 0.6, breaks = borders, lwd = line.widths, col = &quot;red&quot;) 11.4 Анализ взаимного положения (топологический) Пространственные запросы, основанные на топологических отношениях, позволяют находить объекты, находящиеся внутри других объектов, соприкасающиеся с другими объектами, пересекающиеся с ними и так далее. Топологические отношения сохраняются при взаимно-однозначных и непрерывных преобразованиях плоскости. Отличия от метрических отношений легко пояснить на примере преобразования проекции. Представьте, что карту России в конической проекции с концентрическими параллелями (известную по учебникам и атласам) вы трансформировали в карту России в проекции Меркатора (такую же как на Google Maps). Изогнутые параллели превратились в прямые линии; форма регионов, площади и расстояния между населенными пунктами значительно изменились. Однако Красноярск по-прежнему находится в Красноярском крае, Ярославль — на реке Волге, Нижний Новгород — на правом берегу Волги, озеро Белое — внутри Вологодской области, а Московская область как не граничила с Тамбовской, так и не граничит после трансформации проекции. Это и есть топологические отношения. Формально топологические отношения в ГИС описываются с помощью модели девяти пересечений DE-9IM, которая была рассмотрена в предыдущей лекции. ## АНАЛИЗ ВЗАИМНОГО ПОЛОЖЕНИЯ ------------------------------------- poi.food &lt;- poi.food %&gt;% mutate(count = 1) rayons.poi &lt;- aggregate(poi.food[&#39;count&#39;], rayons, sum) # Преобразуем результат в относительный показатель # (единиц на кв.км. площади) и запишем в таблицу районов: rayons.poi$density &lt;- 1000000 * rayons.poi$count / st_area(rayons.poi) Масштабный множитель 1000000 в коде понадобился чтобы перевести площадь, храняющуюся в поле Shape_Area из квадратных метров в квадратные километры. Обратите внимание на то, что в данном случае мы не стали ограничивать фигурными скобками тело анонимной функции (table(X)[2]) внутри apply(), поскольку выполняемая операция достаточно компактна. Подготовим параметры отображения: # Настроим параметры отображения choro.pal &lt;- colorRampPalette(c(&quot;lightgoldenrodyellow&quot;, &quot;orangered&quot;)) intervals &lt;- classIntervals(rayons.poi$density, n = 5, style = &quot;quantile&quot;) Далее используем функции choroLayer() и legendChoro() из пакета cartography для построения картограмм плотности пунктов питания и соответствующей им легенды средствами обычной функции plot(): choroLayer(rayons.poi, # Исходный слой типа SpatialPolygonsDataFrame var = &quot;density&quot;, # Картографируемая переменная (столбец) breaks = intervals$brks, # Границы интервалов col = choro.pal(5), # Цвета для соответствующих интервалов legend.pos = &quot;n&quot;) # Легенду мы нарисуем позднее, поверх всех слоев plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray50&quot;, add = TRUE) plot(poi.food %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.5, add = TRUE) plot(rayons %&gt;% st_geometry(), border = &quot;black&quot;, lwd = 3, add = TRUE) text(rayons %&gt;% st_centroid() %&gt;% st_coordinates(), labels = gsub(&#39; &#39;, &#39;\\n&#39;, rayons$NAME), font = 2, cex = 0.6) # Рисуем легенду legendChoro(breaks = intervals$brks, col = choro.pal(5), pos = &quot;topleft&quot;, frame = FALSE, title.txt = &quot;Заведений на 1 кв.км&quot;) Итак, используя топологический пространственный запрос “Содержит”, мы смогли агрегировать точечные объекты внутри площадных и построить картограммы плотности распределения пунктов питания по районам центра Москвы. 11.5 Анализ абсолютных зон окружения Задача данного раздела модуля звучит следующим образом: определить, какие пункты питания находятся в радиусе 300 метров от метро “Кропоткинская”. Контекстом анализа в данном случае служит 300-метровая зона окружения станции метро. Поставленную задачу можно решить двумя способами: Рассчитать расстояния от каждого пункта питания до станции метро “Кропоткинская” и выбрать точки, для которых это расстояние меньше или равно 300 метрам. Построить буферную зону радиусом 300 метров и выбрать ею точки, используя топологическое отношение пересечения Мы будем использовать второй вариант решения. Алгоритм выглядит следующим образом: Построить буферную зону, используя функцию st_buffer() из пакета sf. Выбрать полученной зоной точки пунктов питания, используя стандартный оператор []. Визуализировать на карте полученные точки и буферную зону. Определим функцию plotBasemap(), которая будет рисовать объекты картографической основы, ее мы будем использовать далее неоднократно. ## АНАЛИЗ АБСОЛЮТНЫХ ЗОН ОКРУЖЕНИЯ ------------------------------------- # Функция отвечает за рисование базовой карты plotBasemap &lt;- function(){ plot(frame) plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray70&quot;, add = TRUE) plot(poi.food %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.3, add = TRUE) plot(stations %&gt;% st_geometry(), col = &quot;slategray4&quot;, pch = 20, cex = 2, add = TRUE) text(stations %&gt;% st_centroid() %&gt;% st_coordinates(), labels = &quot;M&quot;, col = &quot;white&quot;, cex = 0.4) } Определив вспомогательные функции, можем приступать к выполнению анализа: # Выберем станцию метро и построим буферную зону krop &lt;- stations %&gt;% filter(NAME == &quot;Кропоткинская&quot;) zone &lt;- st_buffer(krop, dist = 300) # Применим разработанную функцию для отбора точек selected.poi &lt;- poi.food[zone, ] # Применим разработанную функцию для рисования картографической основы plotBasemap() # Визуализируем результаты анализа plot(krop %&gt;% st_geometry(), col = &quot;red&quot;, pch = 20, cex = 4, add = TRUE) text(krop %&gt;% st_coordinates(), labels = &quot;M&quot;, col = &quot;white&quot;, cex = 0.7, add = TRUE) plot(zone %&gt;% st_geometry(), col = adjustcolor(&quot;sienna3&quot;, alpha.f = 0.5), border = &quot;sienna3&quot;, add = TRUE) plot(selected.poi %&gt;% st_geometry(), col = &quot;sienna4&quot;, pch = 20, cex = 0.5, add = TRUE) # Найденные объекты в табличном представлении: View(selected.poi) В качестве примера аналогичного анализа отберем все пункты питания, находящиеся в пределах 100 метров от реки Москвы: river &lt;- water %&gt;% filter(NAME == &quot;Москва&quot;) zone &lt;- st_buffer(river, dist = 100) selected.poi &lt;- poi.food[zone, ] plotBasemap() plot(zone %&gt;% st_geometry(), col = adjustcolor(&quot;orange&quot;, alpha.f = 0.5), border = &quot;orange&quot;, add = TRUE) plot(river %&gt;% st_geometry(), col = adjustcolor(&quot;deepskyblue&quot;, alpha.f = 0.5), border = F, add = TRUE) plot(selected.poi %&gt;% st_geometry(), col = &quot;firebrick1&quot;, pch = 20, cex = 0.5, add = TRUE) # Найденные объекты в табличном представлении: View(selected.poi) 11.6 Анализ конкурентных зон окружения В данном разделе мы решим следующую задачу: разбить всю изучаемую территорию на зоны окружения станций метро и подсчитать количество пунктов питания, попадающих в каждую зону. Полученные зоны должны быть конкурентными: любая точка, находящаяся в зоне окружения конкретной станции метро, должна быть ближе к этой станции, чем к любой другой станции. Ранее мы говорили о том, что конкурентные зоны окружения по расстоянию можно реализовать с помощью диаграммы Вороного. Применим функцию st_voronoi() из из одноименного пакета, чтобы посмотреть, как выглядит диаграмма Вороного для точек станций метро: ## АНАЛИЗ КОНКУРЕНТНЫХ ЗОН ОКРУЖЕНИЯ ------------------------------------- zones &lt;- st_voronoi(stations) plot(zones) Для визуализации результатов мы будем использовать метод картодиаграмм (пропорциональных символов), реализованный в функции propSymbolsLayer() пакета cartography. Размером кружка покажем количество пунктов питания, оказавшихся в каждой зоне окружения: # Агрегруем данные по каждой зоне zones.poi &lt;- aggregate(poi.food[&#39;count&#39;], zones, sum) # Визуализируем результат plotBasemap() plot(zones %&gt;% st_geometry(), col = adjustcolor(&quot;white&quot;, alpha.f = 0.5), add = TRUE) propSymbolsLayer(zones.poi, var = &quot;count&quot;, symbols = &quot;circle&quot;, col = adjustcolor(&quot;turquoise3&quot;, alpha.f = 0.5), border = F, legend.title.txt = &quot;Заведений питания&quot;) text(zones %&gt;% st_coordinates(), labels = zones$count, col = &quot;turquoise4&quot;, cex = log(zones$counts)/4) 11.7 Анализ зон транспортной доступности Зоны транспортной доступности представляют из себя зоны окружения объектов, построенные не по евклидову расстоянию, а по расстоянию или времени движения по дорожной сети. В задачах логистики и геомаркетинга зоны транспортной доступности часто называют зонами обслуживания (service area), поскольку используются для определения территории, которую может покрыть объект, предоставляющий некоторые услуги. Например, для пожарного депо зона 10-минутной доступности показывает территорию города, в любую точку которой пожарная машина может доехать из данного депо в течение 10 минут. И наоборот, для торгового центра зона 10-минутной доступности показывает территорию города, из любой точки которой можно добраться до ТЦ в течение 10 минут. Очевидно, что продолжительность прямого и обратного маршрута неодинакова, на нее может оказывать влияние схема движения, приоритет дорог и так далее. Задача, которую мы решим в данном разделе, звучит так: определить все заведения питания, находящиеся в 3 минутах езды от Центрального детского магазина. Для построения зоны доступности мы будем использовать пакет osrm, предоставляющий интерфейс R к онлайн-библиотеке маршрутизации OSRM, работающей на основе данных OSM. Для построения зоны доступности (изохроны) нам понадобится функция osrmIsochrone() из данного пакета. Внимание: для выполнения этого раздела модуля необходимо подключение к Интернету Поскольку данные, используемые в настоящем модуле, предварительно были конвертированы в проекцию UTM и хранятся в метрах, а OSRM решает все задачи в географических координатах (широте и долготе относительно эллипсоида WGS84), нам необходимо научиться работать с проекциями данных и преобразовывать системы координат между собой. ## АНАЛИЗ ЗОН ТРАНСПОРТНОЙ ДОСТУПНОСТИ ------------------------------------- # Инициализируем систему координат WGS84, используемую в OSRM WGS84 &lt;- st_crs(4326) # Извлечем информацию о системе координат исходных точек UTM &lt;- st_crs(poi) # Выберем целевой объект psel &lt;- poi %&gt;% filter(NAME == &quot;Центральный детский магазин&quot; &amp; SHOP == &quot;toys&quot;) # Преобразуем координаты точки в WGS84 psel.wgs &lt;- st_transform(psel, WGS84) # Получаем 5-минутную зону транспортной доступности # с помощью пакета osrm service_area &lt;- osrmIsochrone(loc = psel.wgs %&gt;% st_coordinates() %&gt;% as.vector(), breaks = 5) # Преобразуем зону обратно в UTM для дальнейших операций service_area_utm &lt;- st_transform(st_as_sf(service_area), UTM) # Отбираем точки selected_poi &lt;- poi.food[service_area_utm, ] # Визуализируем результат plotBasemap() plot(service_area_utm %&gt;% st_geometry(), col = adjustcolor(&quot;violetred3&quot;, alpha.f = 0.2), border = &quot;violetred3&quot;, add = TRUE) plot(selected_poi %&gt;% st_geometry(), col = &quot;violetred3&quot;, pch = 20, cex = 0.5, add = TRUE) plot(psel %&gt;% st_geometry(), col = &quot;violetred4&quot;, pch = 20, cex = 4, add = TRUE) Итак, в данном разделе мы научились строить зоны транспортной доступности в виде полигонов, ограниченных изохроной времени движения. 11.8 Построение маршрутов и матриц времени движения В этом разделе модуля пространственного анализа мы посмотрим, каким образом можно построить оптимальный маршрут между двумя точками, а также получить матрицу времени движения между точками (на примере станций метро). Для решения этих задач используем следующие функции пакета osrm: osrmRoute(src, dest) — строит оптимальный маршрут между точками src и dest osrmTable(loc) — строит матрицу времени движения между всеми парами точек в loc Так же, как и в предвдущем разделе, нам понадобятся преобразования координат. Построим оптимальный маршрут между книжным магазином “Молодая Гвардия” на Полянке и чебуречной “Дружба” на метро Сухаревская: ## ПОСТРОЕНИЕ МАРШРУТОВ ------------------------------------- # Выбираем и проецируем начальную точку origin &lt;- poi %&gt;% filter(NAME == &#39;Молодая Гвардия&#39;) origin_wgs &lt;- st_transform(origin, WGS84) # Выбираем и проецируем конечную точку destination &lt;- poi %&gt;% filter(NAME == &#39;Чебуречная &quot;Дружба&quot;&#39;) destination_wgs &lt;- st_transform(destination, WGS84) # Строим маршрут route &lt;- osrmRoute(origin_wgs %&gt;% as(&#39;Spatial&#39;), destination_wgs %&gt;% as(&#39;Spatial&#39;), overview = &quot;full&quot;, # запретить генерализацию линий sp = TRUE) # вернуть результат в виде объекта класса Spatial # Преобразуем результат обратно в UTM route.utm &lt;- st_transform(route %&gt;% st_as_sf(), UTM) # Визуализируем результат: plotBasemap() plot(route.utm %&gt;% st_geometry(), lwd = 3, col = &quot;orange&quot;, add = TRUE) plot(origin %&gt;% st_geometry(), col = &quot;tomato3&quot;, pch = 20, cex = 3, add = TRUE) text(origin %&gt;% st_coordinates(), labels = &quot;O&quot;, col = &quot;tomato4&quot;, cex = 0.5) plot(destination %&gt;% st_geometry(), col = &quot;tomato&quot;, pch = 20, cex = 4, add = TRUE) text(destination %&gt;% st_coordinates(), labels = &quot;D&quot;, col = &quot;tomato4&quot;, cex = 0.7) Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "],
["raster-analysis.html", "Глава 12 Пространственный анализ 2. Растровые методы 12.1 Введение 12.2 Локальные операции 12.3 Фокальные операции 12.4 Зональные операции 12.5 Глобальные операции", " Глава 12 Пространственный анализ 2. Растровые методы Программный код главы 12.1 Введение Растровая модель данных представляет собой мощный инструмент абстракции пространственных распределений и выполнения пространственного анализа. На первый взгляд, растр обладает целым рядом ограничений по сравнению с векторной моделью: не позволяет оперировать отдельными объектами, их границами и так далее. Растровые карты и снимки мы часто оцифровываем, выделяя объекты, чтобы на основе них можно было что-то посчитать. Самые первые ГИС были исключительно растровыми, что сейчас воспринимается как архаизм. Однако за ширмой ограниченности растровой модели кроются огромные аналитические возможности. Растровая модель обладает внутренней топологией: ее ячейки соприкасаются друг с другом, что позволяет моделировать непрерывные в пространстве и динамические явления (при которых происходит перемещение вещества, энергии или информации в пространстве). Поскольку ячейки растра имеют одинаковый размер, к ним можно применять однотипные операции, которые будут давать предсказуемый результат вне зависимости от конкретной локации в пределах растра. Это также позволяет сделать обработку растра очень быстро. Существует классификация операций растрового анализа, введенная американским профессором Даной Томлином, которая объединяет их под общим названием “алгебра карт” или “растровая алгебра”7. Предполагая, что обработке подвергается каждая ячейка растра, данная классификация разделяет все операции по охвату относительно текущей ячейки Локальные — анализируется одна ячейка растра или совпадающие в пространстве ячейки нескольких растров Фокальные — анализируются все ячейки в окрестности. Окрестность может быть как фиксированной, так и расширенной (expanded), когда ее размер управляется внешними факторами, например множеством объектов, до которых требуется вычислить расстояние. Информация по соседним ячейкам может быть как из исходного растра, так и из внешнего. Фокальные методы алгебры карт также называются методами анализа соседства. Зональные — анализируются все ячейки в пределах зон, определяемых извне (например, вторым растровым слоем). Глобальные — анализируются все ячейки растра. 12.2 Локальные операции Локальные операции связаны с алгебраическими преобразованиями значений в ячейках. Например, цифровую модель высот в футах можно перевести в цифровую модель высот в метрах. Для этого нужно значение в каждой ячейке умножить на \\(0.3048\\). В локальных операциях могут участвовать несколько растров. Например, если у нас есть растровые поверхности плотности населения за разные года, мы можем вычесть одну поверхность из другой, чтобы получить поверхность изменений плотности, выяснить где она увеличилась, уменьшилась или осталось прежней. К локальным операциям относится также оверлей растров, при котором получается взвешенная сумма значений по нескольким растрам. И в том и в другом случае анализируются ячейки с нескольких растров, которые совпадают в пространстве. В качестве примера определим мощность покровного оледенения в Антарктике и Гренландии, путем вычитание двух моделей ETOPO1, одна из которых показывает рельеф коренных пород (bedrock), а вторая — видимый рельеф поверхности (ice surface): library(sp) library(sf) ## Linking to GEOS 3.6.1, GDAL 2.1.3, proj.4 4.9.3 library(raster) library(classInt) ## Загрузка требуемого пакета: spData ## To access larger datasets in this package, install the spDataLarge ## package with: `install.packages(&#39;spDataLarge&#39;, ## repos=&#39;https://nowosad.github.io/drat/&#39;, type=&#39;source&#39;))` # ЛОКАЛЬНЫЕ ОПЕРАЦИИ # Вычисление толщины покровного оледенения # Чтение данных bed &lt;- raster(&#39;etopo1_bed.tif&#39;) ice &lt;- raster(&#39;etopo1_ice.tif&#39;) countries &lt;- st_read(&#39;countries.gpkg&#39;) ## Reading layer `admin_0_map_units&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/countries.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 183 features and 72 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs borders &lt;- countries %&gt;% st_geometry() # отображение данных classes &lt;- classIntervals(values(bed), 20) brks &lt;- classes$brks nclass &lt;- length(brks) - 1 plot(bed, breaks = brks, col = gray.colors(nclass), main = &#39;ETOPO Bedrock&#39;, legend = F) plot(ice, breaks = brks, col = gray.colors(nclass), main = &#39;ETOPO Ice surface&#39;, legend = F) # вычисление разности ice.depth &lt;- ice - bed plot(ice.depth, col = cm.colors(255), main = &#39;Мощность покровного оледенения&#39;) plot(borders, border = &#39;black&#39;, lwd = 0.5, add = TRUE) # сделаем пустыми все ячейки, в которых толщина льда равна нулю ice.depth[ice.depth == 0] &lt;- NA plot(ice.depth, col = cm.colors(255), main = &#39;Мощность покровного оледенения&#39;) plot(borders, border = &#39;black&#39;, lwd = 0.5, add = TRUE) 12.3 Фокальные операции В фокальных операциях участвует не только сама ячейка или совпадающие с ней ячейки других растров, но также ячейки, находящиеся в некоторой окрестности (опять же, в одном или нескольких растрах одновременно). Данный вид анализа подразделяется на две категории: фокальный анализ с фиксированной окрестностью и с раширенной окрестностью. 12.3.1 Фиксированная окрестность В общем случае фиксированна окрестность может иметь различную форму, однако наиболее часто используется квадратная окрестность размером \\(3\\times3\\): Виды растровых окрестностей. Темной точкой выделена анализируемая ячейка Фокальные операции с фиксированной окрестностью — привычное дело в обработке изображений. Они работают по принципу “плавающего окна”. Выбранная окрестность (квадратная, круглая и т.д.) представляется в виде матрицы коэффициентов — так называемого ядра свёртки (convolution kernel). Далее эта матрица перемещается, позиционируясь последовательно над каждой ячейкой растра, и значение в этой ячейке заменяется на взвешенную сумму значений ячеек в окрестности, умноженных на соответствующие коэффициенты ядра свертки. Например, если ядро состоит из единиц, то будет посчитана обычная сумма. С помощью фокального анализа можно выполнить сглаживание изображения, которое убирает из него мелкие детали (высокочастотные составляющие яркостного сигнала). В качестве такого изображения может быть цифровая модель рельефа или космический снимок. Чтобы выполнить сглаживание, коэффициенты должны быть такими, чтобы получаемая взвешенная сумма осредняла значения в соседних ячейках. Самый простой вариант — это рассчитать среднее арифметическое. В этом случае коэффиценты ядра свертки будут равны \\(1/k\\), где \\(k\\) — количество ячеек в окрестности. Для матрицы \\(3\\times3\\) они будут равны, соответственно \\(1/9\\): # ФОКАЛЬНЫЕ ОПЕРАЦИИ # Вырежем кусок из ЦМР dem &lt;- crop(ice, extent(-120, -75, 10, 40)) spplot(dem) # Среднее wgt &lt;- matrix(c(1, 1, 1, 1, 1, 1, 1, 1, 1) / 9, nrow = 3) # на самом деле проще написать так: # wgt &lt;- matrix(1/9, 3, 3), но полная форма записана для наглядности # выполним обработку ЦМР с помощью фокального фильтра filtered &lt;- focal(dem, w = wgt) spplot(stack(dem, filtered), names.attr=c(&#39;Исходный рельеф&#39;, &#39;Сглаживание средним&#39;)) Более мягким эффектом сглаживания, который к тому же не нарушает дифференцируемость поверхности, является гауссово сглаживание. Коэффициенты в матрице Гаусса убывают от центральной ячейки к краям матрицы по закону Гаусса-Лапласа, что позволяет придать центральной ячейке более высокий вес по сравнению с ячейками, располагающимися на краю анализируемой окрестности: # Гауссово (параметр 0.5 - это стандартное отклонение в единицах измерения растра) wgt &lt;- focalWeight(dem, 0.5, &quot;Gauss&quot;) filtered &lt;- focal(dem, wgt) spplot(stack(dem, filtered), names.attr=c(&#39;Исходный рельеф&#39;, &#39;Гауссово сглаживание&#39;)) Еще одна интересная область применения фильтрации — это обнаружение границ (change detection). Границы на изображении возникают в тех местах, где его яркость резко меняет свое значение (в одном или нескольких каналах). Например, на фотографии контур лица может быть распознан по перепаду яркости между его изображением и фоном (если он имеет существенно отличный цвет). Поскольку перепад яркости соответствует экстремальным значениям производной поверхности (отрицательным или положительным), его также можно определить путем фокального анализа, а затем отсечь ячейки растра, в которых значение этой производной по модулю превышает заданный порог (то есть, имеет необходимый контраст). Рассмотрим, как можно выделить уступы континентального склона океана путем применения фильтра Собеля для выделения границ: # Матрица Собеля: wgt &lt;- matrix(c(1, 2, 1, 0, 0, 0, -1,-2,-1) / 4, nrow=3) filtered &lt;- focal(dem, wgt) # Это поверхность производных: plot(filtered, col = gray.colors(128), main = &#39;Производная поверхности&#39;) # Отберем все ячейки, обладающие высокими значениями производных faults &lt;- (filtered &lt; -1500) | (filtered &gt; 1500) faults[faults == 0] &lt;- NA # Визуализируем результат plot(dem, col = rev(rainbow(20)), main = &#39;Уступы континентального склона&#39;, legend = FALSE) plot(faults, col = &#39;black&#39;, legend = FALSE, add = TRUE) Еще один распространненый случай использования фокальных операций — это морфометрический анализ поверхностей. Квадратная окрестность \\(3\\times3\\) вокруг каждой ячейки формирует локальную поверхность, производные которой дают представление об уклоне, экспозиции и прочих морфометрических параметрах. Их можно вычислить с помощью функции terrain() из пакета raster: # Морфометрия рельефа — фиксированное соседство dem &lt;- raster(&#39;dem_fergana.tif&#39;) spplot(dem) # углы наклона slope &lt;- terrain(dem, opt = &#39;slope&#39;, unit = &#39;degrees&#39;) spplot(slope, col.regions = heat.colors(20), names.attr=c(&#39;Углы наклона&#39;)) # экспозиция aspect &lt;- terrain(dem, opt = &#39;aspect&#39;, unit = &#39;degrees&#39;) spplot(aspect, col.regions = rainbow(20), names.attr=c(&#39;Экспозиции склона&#39;)) Вычисление производных поверхности позволяет не только исследовать рельеф, но также строить его изображения. Например, хорошо знакомую всем по картам аналитическую отмыку рельефа (hillshade). Яркость поверхности в этом способе изображения зависит от угла между направлением на источник освещения (откуда светит Солнце) и нормалью к поверхности. Нормаль можно вычислить как напрямую через производные поверхности, так и восстановить на основе значений угла наклона и экспозиции в точке, что и используется в пакете raster. Обратите внимание на то, что для того чтобы повысить наглядность (контрастность) изображения, мы умножаем высоты рельефа на 20. Это стандартная практика для мелкомасштабных карт: # отмывка slope2 &lt;- terrain(dem * 20, opt = &#39;slope&#39;) aspect2 &lt;- terrain(dem * 20, opt = &#39;aspect&#39;) # параметры angle и direction функции hillShade определяют азимут и высоту источника освещения: hill &lt;- hillShade(slope2, aspect2, angle = 45, direction = 315) plot(hill, col = gray.colors(128), main = &#39;Отмывка рельефа&#39;) 12.3.2 Расширенная окрестность Расширенность окрестности означает, что она определяется не фиксированным шаблоном, а условием, которое должно выполниться для того, чтобы анализ в ячейке считался выполненным. Типичный пример анализа на основе расширенной окрестности — это операции, основанные на вычислении расстояний на растровой матрице, такие как аллокация, опреление кратчайшего пути на поверхности сопростивления, и собственно, само вычисление расстояние. В мелкомасштабных тематических атласах часто можно встретить карты доступности той или иной географической локации, которые в форме изолиний показывают время движения до ближайшего населенного пункта. Эти изолинии можно построить по растровой поверхности, в каждой ячейке которой зафиксировано расстояние до ближайшего населенного пункта. Рассмотрим построение аналогичной поверхности на примере доступности станций метро (по расстоянию). Для этого нам понадобится представить растр в виде матрицы точек, рассчитать для этих точек расстояния до ближайших станций метро и присвоить эти значения выходному растру: # Определение Евклидовых расстояний — расширенное соседство # Чтение данных roads &lt;- st_read(&quot;roads.gpkg&quot;) # Дороги ## Reading layer `roads&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/roads.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 2213 features and 12 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 410946.9 ymin: 6176676 xmax: 415890.8 ymax: 6181910 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs poi &lt;- st_read(&quot;poi_point.gpkg&quot;) # Точки интереса ## Reading layer `poi_point&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/poi_point.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 6623 features and 9 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 410947.3 ymin: 6176678 xmax: 415889.9 ymax: 6181909 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs rayons &lt;- st_read(&quot;boundary_polygon.gpkg&quot;) # Границы районов ## Reading layer `boundary_polygon&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/boundary_polygon.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 11 features and 5 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 410946.9 ymin: 6176676 xmax: 415890.8 ymax: 6181910 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs stations &lt;- st_read(&quot;metro_stations.gpkg&quot;) # Станции метро ## Reading layer `metro_stations&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/metro_stations.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 45 features and 3 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 411007.5 ymin: 6176747 xmax: 415852.2 ymax: 6181892 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs water &lt;- st_read(&quot;water_polygon.gpkg&quot;) # Водные объекты ## Reading layer `water_polygon&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/water_polygon.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 8 features and 7 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 411595.6 ymin: 6176676 xmax: 415890.8 ymax: 6180765 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs # Создаем пустой растр с охватом, равным охвату станции r &lt;- raster(extent(stations), nrows = 200, ncols = 200) # Конвертируем ячейки в точки cells &lt;- r %&gt;% as(&quot;SpatialPoints&quot;) %&gt;% st_as_sf() %&gt;% st_set_crs(st_crs(stations)) # Вычисляем расстояния d &lt;- st_distance(stations, cells) # Находим минимальное расстояние для каждой точки и заполняем # полученными значениями текущее содержимое растра r[] = apply(d, 2, min) # Визуализируем результат plot(r, col = rev(heat.colors(100)), main = &#39;Расстояние до ближайшей станции метро&#39;) contour(r, lwd = 0.5, add= TRUE) plot(water, col = &#39;blue&#39;, border = &#39;darkblue&#39;, add = TRUE) plot(roads, lwd = 0.2, col = &#39;black&#39;, add = TRUE) plot(stations, pch = 20, col = &#39;black&#39;, add = TRUE) 12.4 Зональные операции 12.5 Глобальные операции Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 Tomlin, C Dana. 2012. GIS and Cartographic Modeling. Second edition. Redlands, California: ESRI Press↩ "],
["interpolation-deterministic.html", "Глава 13 Детерминистическая интерполяция 13.1 Введение 13.2 Построение сетки 13.3 Интерполяционные методы 13.4 Аппроксимационные методы", " Глава 13 Детерминистическая интерполяция Программный код главы В лекции рассмотрены детерминистические методы восстановления непрерывных поверхностей по данным в точках. Детерминистичекие методы интерполяции производят интерполяцию значений на основе заданной аналитической зависимости между значением в точке и значениями в пунктах с исходными данными. Это отличает их от методов геостатистических, где эта зависимость находится статистическим путем. Геостатистические методы будут рассмотрены далее. 13.1 Введение Интерполяция в общем случае — это способ нахождения промежуточных значений величины по имеющемуся дискретному набору известных значений. В географии обычно имеют дело с двумерным случаем интерполяции — когда измерения проведены в некоторых географических локациях, и по ним нужно восстановить непрерывную картину поля распределения величины. В общем случае неизвестно, как ведет себя исследуемое явление между точками, поэтому существует бесчисленное множество вариантов интерполяции. Методы которые производят интерполяцию на основе заданной аналитической зависимости, называют детерминистическими. Параметры этой зависимости могут быть как априори заданы пользователем, так и определяться автоматически одним из методов оптимизации — в частности, по методу наименьших квадратов. Например, мы можем сказать, что между соседними точками показатель меняется линейным образом (здесь нужно еще указать, что мы понимаем под соседством). Такие методы достаточно просты в использовании и интерпретации. В то же время, они не учитывают статистических особенностей поведения величины между точками, которое определяется ее автокорреляционными свойствами. Методы интерполяции, которые учитывают простраственную автокорреляцию, называют геостатистическими. Они более сложны в использовании, но потенцально могут дать более достоверные результаты. В этом модуле мы познакомимся со следующими детерминистическими методами интерполяции. Метод ближайшего соседа (nearest neighbor) Метод интерполяции на основе триангуляции Метод обратно взвешенных расстояний (ОВР) Метод радиальных базисных функций (РБФ) Метод иерархических базисных сплайнов (ИБС) Интерполяцию будем рассматривать на примере данных по количеству осадков на метеостанциях в северной Италии (долина реки По и окружающие горы). Станции распределены в пространстве нерегулярно, что позволит визуально оценить чувстительность методов к этому фактору. Прежде чем исследовать распределение показателя, необходимо проанализировать географический контекст. В этой части модуля мы воспользуемся уже известными функциями чтобы создать карту с общегеографической основой и нанести на нее пункты метеонаблюдений. library(sf) library(sp) library(dismo) library(akima) # библиотека для интерполяции на основе триангуляции library(rgdal) library(gstat) # библиотека для геостатистической интерполяции, построения трендов и IDW library(raster) library(plotly) library(maptools) library(lattice) library(deldir) # библиотека для построения триангуляции Делоне и диаграммы Вороного library(fields) # радиальные базисные функции (сплайны минимальной кривизны) library(MBA) # иерархические базисные сплайны # Убираем экспоненциальное представление больших чисел options(scipen=999) # Читаем слои картографической основы cities &lt;- st_read(&quot;Italy_Cities.gpkg&quot;) # Города ## Reading layer `Italy_Cities&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Italy_Cities.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 8 features and 37 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 368910.4 ymin: 4930119 xmax: 686026 ymax: 5115936 ## epsg (SRID): 32632 ## proj4string: +proj=utm +zone=32 +datum=WGS84 +units=m +no_defs rivers &lt;- st_read(&quot;Italy_Rivers.gpkg&quot;) # Реки ## Reading layer `Italy_Rivers&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Italy_Rivers.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 23 features and 10 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 332178.5 ymin: 4922880 xmax: 758033.3 ymax: 5121416 ## epsg (SRID): 32632 ## proj4string: +proj=utm +zone=32 +datum=WGS84 +units=m +no_defs lakes &lt;- st_read(&quot;Italy_Lakes.gpkg&quot;) # Озера ## Reading layer `Italy_Lakes&#39; from data source `/Users/tsamsonov/GitHub/r-geo-course/data/Italy_Lakes.gpkg&#39; using driver `GPKG&#39; ## Simple feature collection with 6 features and 13 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 460686.2 ymin: 4938750 xmax: 757443.7 ymax: 5113557 ## epsg (SRID): 32632 ## proj4string: +proj=utm +zone=32 +datum=WGS84 +units=m +no_defs # Читаем ЦМР — цифровую модель рельефа на регулярной сетке dem &lt;- raster(&quot;gtopo.tif&quot;) # Читаем данные об осадках rainfall&lt;-read.table(&quot;Rainfall.dat&quot;, header = TRUE) # Создаем точечные объекты по координатам на основе таблицы coords &lt;- cbind(rainfall$x, rainfall$y) pts &lt;- SpatialPointsDataFrame(coords, rainfall) # Цветовая шкала для осадков rain.colors &lt;- colorRampPalette(c(&quot;white&quot;, &quot;dodgerblue&quot;, &quot;dodgerblue4&quot;)) # Шкала количества осадков и соответствющее число цветов rain.levels &lt;- seq(0,80,by=10) rain.ncolors &lt;- length(rain.levels)-1 # Цветовая шкала для рельефа dem.colors&lt;-colorRampPalette(c(&quot;darkolivegreen4&quot;,&quot;lightyellow&quot;,&quot;orange&quot;, &quot;firebrick&quot;)) # Шкала высот для рельефа dem.levels &lt;- c(0,50,100,200,500,1000,1500,2000,2500,3000,3500,4000,5000) dem.ncolors &lt;- length(dem.levels) - 1 # Шкала подписей высот для легенды рельефа dem.labels &lt;- c(0,200,500,1000,1500,2000,2500,3000,3500,4000,5000) par(mfrow = c(1,1)) # Настраиваем параметры легенды args &lt;- list(at = dem.labels, cex.axis = 0.7) # Рисуем рельеф гипсометрическим способом plot(dem, breaks = dem.levels, col = dem.colors(dem.ncolors), legend.width = 1.5, legend.shrink = 1.0, axis.args = args) # Наносим горизонтали contour(dem, levels = dem.levels, add = TRUE, col = rgb(0, 0, 0, 0.5)) # Наносим элементы картографической основы plot(rivers, col = &quot;midnightblue&quot;, add = TRUE) plot(lakes, border = &quot;midnightblue&quot;, col = &quot;lightblue&quot;, add = TRUE) # Наносим точки с данными plot(pts, pch = 20, cex = 0.75, add = TRUE) # Наносим города поверх точек, чтобы они не потерялись plot(cities %&gt;% st_geometry(), pch = 21, bg = rgb(1, 1, 1, 0.7), cex = 0.8, add = TRUE) # Наносим подписи городов text(st_coordinates(cities)[,1], st_coordinates(cities)[,2], cities$name, pos = 4, col = &quot;black&quot;) 13.2 Построение сетки Любопытным свойством пакетов R, отвечающих за интерполяцию данных, является их индифферентность относительно того, в каких точках эта интерполяция будет производиться. Это может быть как регулярная растровая сетка, так и множество точек в совершенно произвольных конфигурациях. Подобная гибкость делает процесс интерполяции данных чуть более сложным, чем в ГИС-пакетах, однако способствует полному и глубокому пониманию происходящего. Вы своими руками задаете пункты, в которых следует интерполировать значения. Мы воспользуемся замечательной функцией spsample() из пакета sp, чтобы создать регулярную сетку для интерполяции данных. В целях наглядности для начала сделаем сетку с шагом \\(10\\) км. Первый аргумент spsample() задает географический охват (экстент), в пределах которого необходимо произвести размещение точек, параметр type = отвечает за тип семплирования (spatial sampling): # ПОСТРОЕНИЕ СЕТКИ ДЛЯ ИНТЕРПОЛЯЦИИ pts.grid &lt;- spsample(pts, type = &#39;regular&#39;, cellsize = 10000) plot(pts, pch = 20, cex = 0.75) plot(pts.grid, pch = &#39;+&#39;, cex = 0.75, add = TRUE) Получившееся представление можно уже назвать сеточной моделью. Каждая точка является узлом сетки, и в ней можно произвести интерполяцию показателя. Если мы хотим использовать результат как поверхность, необходимо сеточную модель превратить в растровую (пиксельную). Тогда каждый узел сетки станет центром соответствующей ячейки растра (пиксела), и вся интерполируемая площадь будет покрыта пикселами без пустых мест. В пределах каждого пиксела величина будет считаться постоянной. Ее значение будет интерполировано в центре пиксела. Создадим и визуализируем сетку пикселов: pixels.grid &lt;- SpatialPixels(pts.grid) plot(pts, pch = 20, cex = 0.75) plot(pixels.grid, add = TRUE, col = &quot;black&quot;) Можно видеть, что и сетка узлов, и сетка пикселов не выровнены идеально относительно охвата исходных данных. Часть точек не попадает в пределы построенной сетки. Это связано с тем, что размеры прямоугольника, ограничивающего множество точек, не кратны выбранному разрешению растра (\\(10 000\\) м). При этом размещать точки “с запасом”, т.е. за пределами ограничивающего прямоугольника, смысла нет, так как далеко не все методы интерполяции позволяют восстанавливать данные за пределами области данных. Проблема, однако, не столько критична, если вы выбираете достаточно подробное (малое) разрешение растра, что мы и сделаем. Зададим его равным \\(1 000\\) м. pts.grid &lt;- spsample(pts, type = &#39;regular&#39;, cellsize = 1000) pixels.grid &lt;- SpatialPixels(pts.grid) # извлечем координаты точек в соответствующие столбцы, они нам пригодятся: coords.grid &lt;- data.frame(coordinates(pts.grid)) names(coords.grid) &lt;- c(&quot;x&quot;, &quot;y&quot;) # получим также ограничивающий прямоугольник вокруг точек: box &lt;- bbox(pts) envelope &lt;- extent(pts) %&gt;% as.vector() 13.3 Интерполяционные методы 13.3.1 Метод ближайшего соседа (nearest neighbour) Данный метод является простейшим по сути подходом к интерполяции. В его основе лежит построение диаграммы Вороного исходного множества точек. Считается, что в пределах каждой ячейки диаграммы значение показателя постоянно и равно значению в центре ячейки. Далее поверх диаграммы накладывается сетка интерполируемых точек и снимаются соответствующие значения: # МЕТОД БЛИЖАЙШЕГО СОСЕДА (NEAREST NEIGHBOR) voronoi.sp &lt;- voronoi(pts, ext = envelope) plot(voronoi.sp) plot(pts, pch = 19, cex = 0.5, add = TRUE) # Диаграмма Вороного является дополнением триангуляции Делоне: edges &lt;- deldir(pts$x, pts$y, rw = envelope) %&gt;% triang.list() plot(edges, border = &#39;blue&#39;, lwd = 0.5, add = TRUE) Как видите, нам пришлось несколько потрудиться чтобы соорудить пространственный слой вручную. Давайте посмотрим, как выглядит результат, с помощью lattice: # Список с дополнительным элементом графика — точками layout &lt;- list(&quot;sp.points&quot;, pts, pch = 20, col = &quot;black&quot;) spplot(voronoi.sp, zcol = &quot;rain_24&quot;, at = rain.levels, col.regions = rain.colors(rain.ncolors), sp.layout = layout) Если есть задача конвертировать это в растр, то надо сформировать новый растр и “перенести” на него информацию с полигонов: # Создаем растр raster.out &lt;- raster(pixels.grid) # Снимаем в него значения полигонов rnn &lt;- rasterize(voronoi.sp, raster.out, field = &quot;rain_24&quot;) # Визуализируем: plot(rnn, breaks = rain.levels, col=rain.colors(rain.ncolors)) plot(pts, pch=16, cex=0.5, col = &quot;black&quot;, add = TRUE) Видно, что полученная поверхность уже пиксельная. Для наглядности визуализирем ее в трехмерном виде. Для этого используем замечательный пакет plotly, предоставляющий интерфейс к одноименной библиотеке. Функция plot_ly(), отвечающая за построение графиков в этом пакете, требует для визуализации поверхности предоставить три компоненты: x - вектор координат ячеек по оси \\(Х\\) y - вектор координат ячеек по оси \\(Y\\) z - матрицу значений, имеющую размеры \\(length(x) \\times length(y)\\) Поверхность будет раскрашиваться в различные цвета в зависимости от значений z, для управления цветами можно определить параметр colors, который должен иметь тип colorRamp: rain.colors3d &lt;- colorRamp(c(&quot;white&quot;, &quot;dodgerblue&quot;, &quot;dodgerblue4&quot;)) x &lt;- unique(pts.grid@coords[,1]) # Получим координаты столбцов y &lt;- unique(pts.grid@coords[,2]) # Получим координаты строк z &lt;- as.matrix(rnn) # Получим высоты в виде матрицы p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Понятное дело, что такая ступенчатая форма поверхности вряд ли соответствует реальному распределению показателя, который меняется в пространстве неперывным образом. Можно сказать, что это первое приближение пространственного распределения. 13.3.2 Интерполяция на основе триангуляции Интерполяция на основе триангуляции — метод интерполяции, результатом которого вляется уже не ступенчатая поверхность, а аппроксимированная треугольными гранями — наподобие того как объекты представлены в системах трехмерного моделирования и компьютерных играх. Каждый треугольник определяет наклонный участок поверхности между тремя соседними точками. С построенных треугольников уже далее снимаются значения в заданных точках. Для этого обычно используется линейная интерполяции, результатом которой является угловатая “граненая” поверхность. Также возможно применение бикубической интерполяции, или метода Акимы, который позволяет сгладить поверхность за счет применения полиномов 5-й степени. # ИНТЕРПОЛЯЦИЯ НА ОСНОВЕ ТРИАНГУЛЯЦИИ (TRIANGULATION) # Интерполятор на основе триангуляции требует, чтобы результирующие точки имели тип SpatialPointsDataFrame: pts.grid.df &lt;- SpatialPointsDataFrame(pts.grid, data = coords.grid) # Интерполируем. Параметр linear говорит о том, что показатель будет меняться вдоль ребер триангуляции линейно: z.linear &lt;- interpp(x = pts, z = &quot;rain_24&quot;, xo = pts.grid.df, linear = TRUE) # Переносим результат на сетку пикселей: px.linear &lt;- SpatialPixelsDataFrame(pts.grid.df, data = as.data.frame(z.linear$z)) # Создаем объект типа raster, который можно визуализировать в привычном виде: r.linear &lt;- raster(px.linear) # Смотрим как выглядит результат plot(r.linear, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.linear, levels = rain.levels, add = TRUE) plot(edges, pch = 19, lwd = 0.5, lty = 3, cex = 0.5, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Обратите внимание, что все изломы (повороты) изолиний происходят на ребрах триангуляции, а внутри треугольников изолинии проходят параллельно друг другу. Каждый треугольник представляет собой фрагмент наклонной плоскости. Такой метод интерполяции, по сути, является самым простым и “честным” подходом, который близок к тому как горизонтали интерполируются вручную. Рассмотрим поверхность в 3D: z &lt;- as.matrix(r.linear) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Линейная интерполяция на треугольниках, как можно видеть, выглядит достаточно угловато, хотя и существенно более правдоподобна, нежели ступенчатая поверхность, полученная методом ближайшего соседа. Более гладкий результат можно получить, используя не линейный, а бикубический метод интерполяции на треугольниках. Для этого следует указать параметр linear = FALSE. Помимо этого, параметр extrap = TRUE говорит о том, что можно производить экстраполяцию за пределами выпуклой оболочки точек (такая возможность недоступна в линейном случае) # Интерполируем z.spline &lt;- interpp(x = pts, z = &quot;rain_24&quot;, xo = pts.grid.df, linear = FALSE, extrap = TRUE) # Переносим результат на сетку пикселей: px.spline &lt;- SpatialPixelsDataFrame(pts.grid.df, data = as.data.frame(z.spline$rain_24)) # Создаем объект типа raster: r.spline &lt;- raster(px.spline) # Визуализируем результат: plot(r.spline, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.spline, levels = rain.levels, add = TRUE) plot(edges, pch = 19, lwd = 0.5, lty = 3, cex = 0.5, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Полученные изолинии отличаются более плавным и естественным рисунком. Тем не менее, использование триангуляции все еще заметно по фестончатым изгибам изолиний на ребрах. Смотрим наглядное представление поверхности в 3D: z &lt;- as.matrix(r.spline) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Можно видеть, что в данном случае получена уже гладкая поверхность, плотно натянутая на ребра триангуляции. 13.3.3 Метод обратно взвешенных расстояний (IDW) В данном методе значение показателя в произвольной точке получается как средневзвешенная сумма значений в исходных точках. Веса определяются обратно пропорционально расстоянию: чем дальше исходная точка удалена, тем меньший вес она будет иметь в оценке. Метод реализуется в R с помощью функции idw() из пакета gstat. Основным параметром метода является степень idp =, которая указывает, насколько быстро в зависимости от расстояния будет убывать вес исходной точки. По умолчанию idp = 2. При больших значениях степени (3, 4, 5, …) поверхность становится более платообразной, при меньших — островершинной. Функция idw() принимает 4 параметра: Формула, указывающая название зависимой переменной и независимых переменных Исходные точки Результирующие точки Степень весовой функции idp Формулы полезны в тех случаях, когда известно (или делается предположение), что исследуемый показатель функционально связан с другой величиной. В этом случае запись Z ~ x означает, что сначала будет построена линейная регрессия \\(Z(x)\\) и на основе нее получена грубая оценка показателя в каждой результирующей точке. Интерполяции же будут подвергаться случайные остатки между исходными величинами в точках и теми, что получены по регрессии. Эти остатки добавляются в результирующих точках к оценке, полученной по регрессии. С этой техникой мы познакомимся подробнее в следующем модуле при рассмотрении универсального кригинга. А пока что мы воспользуемся стандартной записью вида Z ~ 1, которая означает, что интерполироваться будет непосредственно исходная величина. В качестве Z надо указать название столбца, содержащего значения показателя. Этот столбец должен находиться в слое с исходными точками, который передается в параметр locations =. Сетка новых точек передается в параметр newdata. Рассмотрим, как меняется вид поверхности при разных значениях idp. Оператор ‘@’ позволяет извлекать слоты из классов S4. К таким классам относятся объекты типа Spatial*, которые мы активно используем в настоящей лекции. Атрибуты в таких объектах хранятся в слоте @data, а координаты — в слоте @coords # МЕТОД ОБРАТНО ВЗЕШЕННЫХ РАССТОЯНИЙ (IDW --- INVERSE DISTANCE WEIGHTED) # Интерполируем количество осадков: z1 &lt;- idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 2.0) z2 &lt;- idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 3.0) z3 &lt;- idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 4.0) z4 &lt;- idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 5.0) # Переносим результат на сетку пикселей. px1 &lt;- SpatialPixelsDataFrame(z1, data = z1@data) px2 &lt;- SpatialPixelsDataFrame(z2, data = z2@data) px3 &lt;- SpatialPixelsDataFrame(z3, data = z3@data) px4 &lt;- SpatialPixelsDataFrame(z4, data = z4@data) # Создаем объект типа raster для визуализации r1 &lt;- raster(px1, values = px1$var1.pred) r2 &lt;- raster(px2, values = px2$var1.pred) r3 &lt;- raster(px3, values = px3$var1.pred) r4 &lt;- raster(px4, values = px4$var1.pred) # Смотрим как выглядит результат plot(r1, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r1, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) plot(r2, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r2, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) plot(r3, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r3, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) plot(r4, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r4, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Удобно также набор растровых данных визуализировать средствами lattice, превратив их в растровый стек: r &lt;- stack(r1, r2, r3, r4) spplot(r, at = rain.levels, col.regions = rain.colors(rain.ncolors), sp.layout = list(&quot;sp.points&quot;, pts, pch=20, cex=0.5, col=&#39;black&#39;) ) Видно, что метод ОВР формирует вокруг каждой исходной точки замкнутые изолинии, оконтуривающие вершины и впадины на поверхности. Этот эффект является основным недостатком метода и носит название эффекта “бычьих глаз”. Он вызван тем, что производная функции ОВР в каждой точке равняется нулю. При увеличении степени весовой функции происходит расширение зоны влияния каждой точки, поверхности вершин и впадин приобретают платообразный характер. Наглядное представление о характере поверхности, получаемой методом ОВР, дает трехмерная визуализация: z &lt;- as.matrix(r3) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Любопытным фактом является то, что при стремлении параметра idp к плюс-бесконечности получаемая поверхность становится все более похожей не результат интерполяции методом ближайшего соседа. А именно этот метод, как мы помним, дает ступенчатую платообразную поверхность. Это легко проверить на практике, задав достаточно большой параметр idp, например \\(30\\): z30 &lt;- idw(rain_24 ~ 1, locations = pts, newdata = pts.grid, idp = 30.0) ## [inverse distance weighted interpolation] px30 &lt;- SpatialPixelsDataFrame(z30, data = z30@data) r30 &lt;- raster(px30, values = px30$var1.pred) plot(r30, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r30, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Добавим границы ячеек диаграммы Вороного: plot(voronoi.sp, border = &quot;red&quot;, add = TRUE) # Рассмотрим поверхность в 3D: z &lt;- as.matrix(r30) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) 13.3.4 Метод радиальных базисных функций (РБФ) В методе РБФ задается радиальная функция — некоторая монотонно возрастающая функция, в качестве аргумента которой выступает расстояние между точками. Для интерполируемой точки вычисляются расстояния от нее до каждой из исходных точек. На основе этих расстояний получают значения радиальной функции. Результат интерполяции получается как сумма значений радиальной функции с коэффициентами. Коэффициенты определяются исходя из условия прохождения поверхности через исходные точки путем решения системы линейных уравнений. Метод РБФ является одним из самых мощных и гибких широким возможностям выбора радиальной функции. Недостатком же его является то, что поверхность может выходить за пределы исходного диапазона значений. Существуют радиальные функции, обладающие особыми свойствами. В частности, в качестве радиальной функции можно использовать сплайны - функции, выполняющие некоторое дополнительное условие (условия) при одновременном выполнении условий интерполяции (прохождение через исходные точки). Одним из наиболее популярных сплайнов является сплайн минимальной кривизны (thin plate spline — TPS), который дает поверхность, обладающую максимально низкой кривизной между исходными точками. Это, кстати, не означает что поверхность плотно натянута на исходные точки (как в триангуляции). Скорее, в ней будут отсутствовать резкие скачки и понижения, что мы видели на поверхности, построенной методом ОВР. Задается такой сплайн с помощью радиальной функции \\(R(d) = d^2 * log(d^2)\\) На языке R сплайны минимальной кривизны реализованы в пакете fields. Сначала необходимо инициализировать процесс интерполяции с помощью функции Tps(), передав ей координаты исходных точек и значения показателя в них. Дополнительно при необходимости указывается параметр scale.type = 'unscaled', который означает, что не следует масштабировать координаты исходных точек так чтобы область определения стала квадратной: # РАДИАЛЬНЫЕ БАЗИСНЫЕ ФУНКЦИИ (RADIAL BASIS FUNCTIONS) pred &lt;- Tps(coords, pts$rain_24, scale.type = &#39;unscaled&#39;) # После этого можно интерполировать значения с помощью функции predict(): z.tps &lt;- predict(pred, coords.grid) # Результирующий объект является вектором, поэтому его нужно привести к типу data.frame перед перенесением на сетку пикселей: px.tps &lt;- SpatialPixelsDataFrame(pts.grid, data = data.frame(z.tps)) # Также добавим название показателя names(px.tps) &lt;- c(&quot;rain_24&quot;) # Преобразуем в растр r.tps &lt;- raster(px.tps, values = px.tps$rain_24) # Придется расширить шкалу, так как сплайновая поверхность выходит за пределы исходных значений: tps.breaks = seq(-10,90,by=10) tps.ncolors = length(tps.breaks) - 1 # Виузализируем результат: plot(r.tps, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.tps, levels = seq(-10,90,by=10), add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Можно видеть, что по плавному характеру изолиний и отсутствию артефактов в виде “бычьих глаз” интерполяция методом РБФ существенно ближе к ожидаемому распределению показателя, а также удачно сглаживает неравномерность распределения исходных данных. Смотрим, как выглядит поверхность в 3D: z &lt;- as.matrix(r.spline) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) 13.3.5 Метод иерархических базисных сплайнов (B-сплайнов) Если говорить просто — в методе иерархических базисных сплайнов (ИБС) поверхность формируется как совокупность профилей по осям \\(X\\) и \\(Y\\). Участок профиля, соединяющий 4 последовательных узла, представляет из себя кубический полином — базисный сплайн. Сплайны стыкуются гладко, то есть в любом узле поверхности существуют и первая и вторая производная. Каждый участок поверхности размером \\(4 \\times 4\\) ячейки представляет собой уже бикубическую поверхность. Высоты в ячейках получаются исходя из условия прохождения поверхности через исходные точки, а также минимизации суммы квадратов высот (поскольку существует бесконечное число различных поверхностей на сетке \\(4 \\times 4\\), которые проходят через заданную точку). Если хотя бы в один участок \\(4 \\times 4\\) попадает более одной точки, поверхность будет аппроксимирующей, так как каждая точка дает свой оптимум, минимизирующий сумму квадратов значений в узлах. При иерархическом подходе поверхность строится в несколько итераций с последовательным переходом на более детальное разрешение сетки. При этом на каждой последующей итерации аппроксимации подвергаются остатки между исходными значениями в точках и теми, которые получаются по бикубической поверхности. Если результирующее разрешение таково, что в окрестности \\(4 \\times 4\\) исходной точки нет других исходных точек, метод будет интерполирующим. Достоинством метода иерархических базисных сплайнов является то, что поверхность получается сразу для всех узлов, нет необходимости решать систему линейных уравнений для каждого узла сетки. Метод явяется локальным: исходные точки, удаленные от текущего узла ЦМР далее чем на 2 узла, не оказывают на нее влияние. В результате этого метод ИБС получается чрезвычайно быстрым и эффективным в вычислительном плане. Помимо этого, мультимасштабность метода позволяет эффективно использовать его при интерполяции данных, распределенных кластерным образом — например, данных профилирования. Метод иерархических базисных сплайнов доступен в пакете MBA. Чтобы использовать его, сначала необходимо подготовить исходные данные. Они должны представлять из себя матрицу из трех столбцов: X, Y, Показатель: # ИЕРАРХИЧЕСКИЕ БАЗИСНЫЕ СПЛАЙНЫ (HIERARCHICAL BASIS SPLINES) mba.data &lt;- cbind(pts$x, pts$y, pts$rain_24) Метод ИБС, так же как и РБФ, предполагает по умолчанию, что область определения должна быть квадратной. Если разброс координат по осям X и Y не одинаков, поверхность будет искусственно растянута или сжата. Чтобы этого не произошло, необходимо сначала рассчитать пропорции ЦМР. Ранее мы уже создали объект envelope, который хранит крайние координаты по X и Y: ratio &lt;- (envelope[2] - envelope[1])/(envelope[4] - envelope[3]) # После этих приготовлений можно осуществить интерполяцию pred &lt;- mba.points(mba.data, coords.grid, n = 1, m = ratio) # Далее извлечем полученные значения pred.z = data.frame(pred$xyz.est[,&quot;z&quot;]) # Перенесем результат на сетку пикселей: px.bspline &lt;- SpatialPixelsDataFrame(pts.grid, data = pred.z) # Вернем исходное название показателю: names(px.bspline) &lt;- c(&quot;rain_24&quot;) # Построим растр для визуализации результатов r.bspline &lt;- raster(px.bspline, values = px.bspline$rain_24) # Смотрим, что получилось: plot(r.bspline, breaks = seq(-10,90,by=10), col=rain.colors(10)) contour(r.bspline, levels = seq(-10,90,by=10), add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Можно видеть, что метод иерерхических базисных сплайнов обеспечивает некий оптимум представления поверхности. С одной стороны, он, как и метод РБФ, дает гладкую и достаточно генерализованную поверхность. С другой стороны, на участках с плотным размещением исходных данных метод ИБС раскрывает локальные нюансы поверхности, чего лишен метод РБФ, и что более типично для метода ОВР. Наконец, рассмотрим результат в трехмерном виде: z &lt;- as.matrix(r.bspline) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Итак, в настоящем модуле мы рассмотрели несколько распространенных методов детерминистической интерполяции поверхностей по данным в нерегулярно расположенных точках. В следующем модуле мы рассмотрим методы аппроксимации, которые могут быть полезны для работы с данными, обладающими высоким уровнем шума, а также для оценки пространственных трендов изменения показателя. 13.4 Аппроксимационные методы Аппроксимационные методы используются для выявления пространственных трендов - глобальных или локальных. В зависимости от этого они и классифицируются. Полученная поверхность в каждом узле показывает средневзвешенное (типичное) значение в заданной окрестности. Таким образом, задача аппроксимации — убрать детали и выявить основные закономерности протранственного распределения. При проведении аппроксимации условие прохождения поверхности через исходные точки не применяется. В случае глобального тренда окрестность аппроксимации включает весь набор исходных точек. Локальные аппроксимации учитывают только ближайшие точки, причем общепринятым является подход, в котором окрестность определяется не расстоянием, а заданным количеством ближайших точек (или их долей от общего числа). В этом случае в области сгущения исходных данных локальная аппроксимация будет строиться по меньшей окрестности, что позволит отразить нюансы изменения показателя. И в локальных и в глобальных аппроксимациях используются обычно полиномиальные поверхности степени от \\(0\\) до \\(3\\). Коэффициенты полиномов подбираются методом наименьших квадратов для минимизации отклонения поверхности от исходных точек в заданной окрестности. В случае если степень равна \\(0\\), поверхность представляет из себя константу, или горизонтальную плоскость. Для степени \\(1\\) возможно построение наклонной плоскости. Степени \\(2\\) и \\(3\\) соответствуют квадратичным и кубическим поверхностям. Степени большего порядка для построения трендов, как правило, не используются. 13.4.1 Глобальный тренд Построение поверхности глобального тренда можно осуществить с помощью геостатистического пакета gstat, с которым мы познакомимся в следующем модуле. Для этого необходимо сначала создать объект gstat, используя формулу (см. метод ОВР), исходные точки и степень аппроксимации. После этого аппроксимация осуществляется с попощью функции predict(). Дальнейшие действия совпадают со стандартным алгоритмом, который мы использовали ранее. # ГЛОБАЛЬНАЯ АППРОКСИМАЦИЯ (GLOBAL APPROXIMATION) # 1-я степень ------------------------------------------------------------- # Создаем объект gstat. Столбец, указываемый в параметре formula, должен содержаться # в наборе данных, который передается в параметр data: trend &lt;- gstat(formula = rain_24 ~ 1, data = pts, degree = 1) # Осуществляем аппроксимацию на заданную сетку точек: z &lt;- predict(trend, newdata = pts.grid) # Переносим результат на сетку пикселей: px &lt;- SpatialPixelsDataFrame(z, data = z@data) # Преобразуем в растр: r.trend1 &lt;- raster(px, values = px$var1.pred) # Визуализируем результат: plot(r.trend1, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.trend1, levels = tps.breaks, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Теперь повторим все то же самое для степеней 2 и 3: # 2-я степень ------------------------------------------------------------- trend &lt;- gstat(formula = rain_24 ~ 1, data = pts, degree = 2) z &lt;- predict(trend, newdata = pts.grid) px &lt;- SpatialPixelsDataFrame(z, data = z@data) r.trend2 &lt;- raster(px, values = px$var1.pred) # Визуализируем: plot(r.trend2, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.trend2, levels = tps.breaks, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # 3-я степень ------------------------------------------------------------- trend &lt;- gstat(formula = rain_24 ~ 1, data = pts, degree = 3) z &lt;- predict(trend, newdata = pts.grid) px &lt;- SpatialPixelsDataFrame(z, data = z@data) r.trend3 &lt;- raster(px, values = px$var1.pred) # Визуализируем: plot(r.trend3, breaks = tps.breaks, col=rain.colors(tps.ncolors)) contour(r.trend3, levels = tps.breaks, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Наконец, рассмотрим полученные поверхности в трехмерном виде: z &lt;- as.matrix(r.trend1) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z &lt;- as.matrix(r.trend2) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z &lt;- as.matrix(r.trend3) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) 13.4.2 Локальный тренд Метод построения локальной регрессии изначально был разработан для построения кривых регрессии в случае когда зависимость между переменными ведет себя сложным образом и не может быть описана в терминах традиционной линейной и нелинейной регрессии — глобальных методов. В этом случае область значений независимой переменной \\(X\\) можно покрыть конечным числом отрезков, для каждого из которых далее находят регрессию традиционным методом — как правило, линейную или квадратичную. В классической постановке метод реализуется следующим образом. Пусть дано \\(N\\) точек с координатами \\(X\\) (независимая переменная) и \\(Y\\) (зависимая). Задается число \\(\\alpha\\), которое обозначет долю от общего количества точек, которую необходимо выбрать в окрестности каждой из N точек для построения регрессии. То есть для каждой точки \\(p(x)\\) из исходных данных выбираются \\(\\alpha N\\) ближайших к ней. Близость опеределяется как разность координат \\(X\\). Выбранные точки определяют окрестность \\(p(x)\\), в которой будет строиться локальная регрессия. Далее происходит определение параметров линейной или квадратической регрессии взвешенным методом наименьших квадратов. При использовании этого метода более близкие к \\(p(x)\\) точки оказывают большее влияние на коэффициенты регрессии. Построенная регрессия дает в точке \\(x\\) сглаженную оценку \\(p&#39;(x)\\) вместо исходной \\(p(x)\\). Процедура повторяется для каждой из \\(N\\) точек. Результирующая кривая соединяет точки \\(p&#39;(x)\\). При этом чем больше значение \\(\\alpha\\), тем более сглаженный вид будет иметь кривая регрессии. Метод получил название LOWESS (Locally weighted scatterplot smoothing). В дальнейшем эта аббревиатура была редуцирована до LOESS. В методе LOESS используются степени регрессии 0, 1, 2. Кубические и более высокие степени полиномов не применяются. При степени равной 0 метод носит название сглаживающего среднего. Вместо координат исходных точек для построения регрессии можно использовать и произвольные координаты \\(X\\). В этом случае кривая будет соединять точки, полученные локальной регрессионной оценкой в заданных координатах \\(X\\). Именно этот принцип используется в двумерном (и многомерном) случае. Пусть даны измерения показателя в \\(N\\) исходных точках и задано число \\(\\alpha\\) — сглаживающий параметр. Тогда аппроксимация показателя в каждом узле интерполяции получается путем построения поверхности тренда (см. выше) по \\(\\alpha N\\) ближайшим исходным точкам. Как и в одномерном случае, близкие точки будут оказывать более сильное влияние на коэффициенты регрессии, чем удаленные. Метод LOESS предоставляет широкие возможности настройки благодаря вариативности параметра сглаживания и степени регрессионного полинома. Рассмотрим применение метода LOESS на примере данных по осадкам. Поскольку это один из базовых методов регрессионного анализа, он входит в состав базового пакета stats. Для его использования нужно вначале инициализировать параметры локальной регрессии с помощью функции loess(). Параметры задаются в следующей форме: Формула, содержащая названия зависимой и независимых (координаты) переменной Набор данных, в котором содержатся значения переменных Степень полиннома (degree) Сглаживающий параметр (span) Необходимость нормализации координат (приведения к квадратной области определения) # ЛОКАЛЬНАЯ АППРОКСИМАЦИЯ (LOWESS) # 0-я степень ------------------------------------------------------------- local.trend &lt;- loess(rain_24 ~ x + y, pts, degree = 0, span = 0.07, normalize = FALSE) # Производим оценку в заданных точках z.local.trend &lt;- predict(local.trend, coords.grid) # Переводим результат на сетку пикселей px.local.trend &lt;- SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) # Задаем название показателя names(px.spline) &lt;- c(&quot;rain_24&quot;) # Преобразуем в растр для визуализации r.local.trend0 &lt;- raster(px.local.trend, values = px.spline$rain_24) # Визуализируем plot(r.local.trend0, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend0, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # Повторим аналогичные действия для степеней 1 и 2 # 1-я степень ------------------------------------------------------------- local.trend &lt;- loess(rain_24 ~ x + y, pts, degree = 1, span = 0.07, normalize = FALSE) z.local.trend &lt;- predict(local.trend, coords.grid) px.local.trend &lt;- SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) &lt;- c(&quot;rain_24&quot;) r.local.trend1 &lt;- raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend1, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend1, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # 2-я степень ------------------------------------------------------------- local.trend &lt;- loess(rain_24 ~ x + y, pts, degree = 2, span = 0.07, normalize = FALSE) z.local.trend &lt;- predict(local.trend, coords.grid) px.local.trend &lt;- SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) &lt;- c(&quot;rain_24&quot;) r.local.trend2 &lt;- raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend2, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend2, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Рассмотрим результаты в 3D: z &lt;- as.matrix(r.local.trend0) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z &lt;- as.matrix(r.local.trend1) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z &lt;- as.matrix(r.local.trend2) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Можно заметить, что с увеличением степени полинома поверхность все более точно аппроксимирует исходные данные — там, где достаточно большое количество исходных точек. В то же время, появляются нежелательные экстраполяции в приграничных областях, слабо обеспеченных измерениями, что можно наблюдать на последнем рисунке (степень = 2) в северо-западной части. Поэтому нельзя однозначно сказать, что более высокая степень обеспечивает лучшие результаты аппроксимации. Точность аппроксимации правильно регулировать не степенью полинома, а увеличением и уменьшением сглаживающего параметра альфа. Рассмотрим это на примере линейной аппроксимации при \\(\\alpha = 0.05, 0.1, 0.2\\): # degree = 1, span = 0.05 ------------------------------------------------- local.trend &lt;- loess(rain_24 ~ x + y, pts, degree = 1, span = 0.05, normalize = FALSE) z.local.trend &lt;- predict(local.trend, coords.grid) px.local.trend &lt;- SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) &lt;- c(&quot;rain_24&quot;) r.local.trend.a05 &lt;- raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend.a05, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend.a05, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # degree = 1, span = 0.1 ------------------------------------------------- local.trend &lt;- loess(rain_24 ~ x + y, pts, degree = 1, span = 0.1, normalize = FALSE) z.local.trend &lt;- predict(local.trend, coords.grid) px.local.trend &lt;- SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) &lt;- c(&quot;rain_24&quot;) r.local.trend.a10 &lt;- raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend.a10, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend.a10, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) # degree = 1, span = 0.2 ------------------------------------------------- local.trend &lt;- loess(rain_24 ~ x + y, pts, degree = 1, span = 0.2, normalize = FALSE) z.local.trend &lt;- predict(local.trend, coords.grid) px.local.trend &lt;- SpatialPixelsDataFrame(pts.grid, data = data.frame(z.local.trend)) names(px.spline) &lt;- c(&quot;rain_24&quot;) r.local.trend.a20 &lt;- raster(px.local.trend, values = px.spline$rain_24) plot(r.local.trend.a20, breaks = rain.levels, col=rain.colors(rain.ncolors)) contour(r.local.trend.a20, levels = rain.levels, add = TRUE) plot(pts, pch = 20, cex = 0.5, add = TRUE) Сравниваем результаты в трехмерном виде: z &lt;- as.matrix(r.local.trend.a05) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z &lt;- as.matrix(r.local.trend.a10) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) z &lt;- as.matrix(r.local.trend.a20) p &lt;- plot_ly(x = x, y = y, z = z, type = &quot;surface&quot;, colors = rain.colors3d) layout(p, scene = list(aspectratio = list(x = 1, y = 1, z = 0.3) )) Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "],
["kriging.html", "Глава 14 Геостатистическая интерполяция", " Глава 14 Геостатистическая интерполяция Программный код главы Раздел посвящен геостатистической интерполяции в R. [To be written…] "],
["autocorrelation.html", "Глава 15 Пространственная автокорреляция 15.1 Введение 15.2 Пространственное соседство 15.3 Пространственные веса 15.4 Пространственная автокорреляция 15.5 Пространственная авторегрессия 15.6 Локальные показатели пространственной ассоциации (LISA) 15.7 Географически взвешенная реграссия (GWR)", " Глава 15 Пространственная автокорреляция Программный код главы В данном модуле мы приступим к исследованию связей в географическом пространстве. Понятие пространственной автокорреляции является математическим отражением первого закона географии: все связано со всем, но близкорасположенные объекты связаны сильнее. Различные коэффициенты пространственной автокорреляции, такие как индекс Морана (Moran’s I) позволяют охарактеризовать силу этой связи с точки зрения математической статистики. Однако для их вычисления необходимо формализовать понятия географической близости, или географического соседства. В настоящем модуле рассматриваются различные подходы к решению данной проблемы. 15.1 Введение Анализ географического соседства — первый этап исследования пространственной автокорреляции (ПА). Общепринятого определения ПА не существует. Одно из наиболее удачных определений гласит следующее: Для множества \\(S\\), состоящего из \\(n\\) географических единиц, пространственная автокорреляция есть соотношение между переменной, наблюдаемой в каждой из \\(n\\) единиц и мерой географической близости, определенной для всех \\(n(n − 1)\\) пар единиц из \\(S\\) (Hubert et al., 1981)8 Анализ ПА, как правило, осуществляется по жестко зафиксированной сетке (lattice) учетных единиц, в качестве которых могут выступать как площади, так и точки. Но, строго говоря, пространственная статистика в конечном счете любую единицу будет интерпретировать как точку. Конечной целью исследований ПА является построение статистической модели зависимости значения показателя в каждой единице от значений в соседних единицах и (опционально) неких факторов. Наличие статистически значимой ПА говорит о влиянии процессов, обуславливающих кластеризацию значений в соседних территориальных единицах. И пока эти механизмы не установлены, модель ПА дает инструмент их статистического моделирования. Добавление известных факторов в модель может улучшить точность моделирования. Как мы уже сказали, исследование ПА начинается с анализа географического соседства. То есть, для каждой анализируемой единицы мы должны определить соседние по отношению к ней единицы. Это не так-то просто,поскольку существует множество способов определить соседство. Перед выполнением анализа подключим необходимые библиотеки и визуализируем исходные данные: library(sf) library(sp) library(rgdal) library(spdep) # пакет spdep содержит инструменты анализа ПА library(lattice) library(RANN) library(RColorBrewer) library(readxl) reg.sf &lt;- st_read(&#39;Regions.gpkg&#39;) reg &lt;- as(reg.sf, &#39;Spatial&#39;) # пакет spdep пока что требует объекты класса sp par(mar = c(1,1,1,1)) plot(reg, border = &quot;gray50&quot;) 15.2 Пространственное соседство В целом, можно выделить три большие группы методов: Соседи по смежности Соседи по графу Соседи по метрике Соседство по смежности основано на топологических отношениях между объектами и применяется при анализе данных, приуроченных к площадным единицам — например, сетке административно-территориального деления. Смежными считаются объекты, границы которых имеют общие точки. При этом возможно два варианта соседства: по правилу ферзя (QUEEN) и правилу ладьи (ROOK). В первом случае соседними будут считаться все пары территориальных единиц, имеющие хотя бы одну общую точку на границе, т.е. соприкасющиеся сторонами и/или углами. Соседство по правилу ладьи является более строгим, так как разрешает только наличие общих сторон вдоль границ, а точечные касания в расчет не берутся. Отличия правил иллюстрирует рисунок ниже. Поиск географических соседей по правилу ферзя и правилу ладьи Соседство по графу основано на отношениях объектов в триангуляции Делоне. В эту же категорию попадают всевозможные фильтрации триангуляции Делоне, которые удаляют из нее ребра, не удовлетворяющие заданным критериям. Более подбробно о них будет сказано ниже. Соседство по метрике основано на вычислении расстояний между объектаи. Соседними по отношению к каждому объекту будут считаться либо \\(K\\) ближайших к нему объектов (соседи по количеству), либо все объекты, удаленные на растояние не далее \\(D_{max}\\) (соседи по расстоянию). Результатом анализа соседства является граф соседства(neighborhood graph), в котором сами объекты являются вершинами, а связи между ними — ребрами. Анализ географического соседства на языке R можно провести с помощью пакета spdep. Рассмотрим суть и принципы построения графов соседства на основе различных принципов. 15.2.1 Соседи по смежности Список соседей по смежности можно получить с помощью функции poly2nb(). Возвращаемый объект является классом типа nb. Для каждой единицы в нем содержится список номеров соседних по отношению к нему единиц. По умолчанию функция находит соседей по правилу ферзя: polynei &lt;- poly2nb(reg) # Соседство по правилу ферзя polynei # посмотрим сводную информацию class(polynei) # проверим тип объекта Для объектов типа nb в пакете spdep определена своя функция plot(), которая позволяет визуализировать граф соседства. Функция требует на вход координаты точек, в случае площадных единиц для этого используют центроиды площадей, которые можно получить функцией coordinates(): coords &lt;- coordinates(reg) # Теперь рисуем граф: plot(reg, border = &quot;gray50&quot;) plot(polynei, coords, pch = 19, cex = 0.5, add = TRUE) title(main=&quot;Соседи по смежности (правило ферзя)&quot;) Для определения соседей по правилу ладьи необходимо вызвать функцию poly2nb() с аргументом queen=FALSE. В нашем случае, правда, это даст тот же результат, поскольку в данных отсутствуют единицы, соприкасающиеся в одной лишь точке: polynei&lt;-poly2nb(reg, queen=FALSE) # Соседство по правилу ладьи plot(reg, border=&quot;grey70&quot;) plot(polynei, coords, pch = 19, cex = 0.5, add = TRUE) title(main=&quot;Соседи по смежности (правило ладьи)&quot;) Обратим внимание на то, что функция poly2nb() принимает на вход площадные объекты. Все помледующие методы определения соседства (по графу и по метрике) работают с точечными данными. 15.2.2 Соседи по графу Данная группа методов определения соседства основана на построении триангуляции Делоне для точек исходных данных. Далее эта триангуляция может быть оставлена в неизменном виде, или быть подвержена процедуре фильтрации, которая удалит из нее ребра, не удовлетворяющие заданному критерию. Соседи по триангуляции Делоне без фильтрации могут быть получены с помощью функции tri2nb(): plot(reg, border=&quot;grey70&quot;) trinei = tri2nb(coords) plot(trinei, coords, pch = 19, cex = 0.5, add = TRUE) title(main=&quot;Соседи по триангуляции Делоне&quot;) Соседи по сфере влияния получаются путем фильтрации триангуляции Делоне. Для каждой вершины находится расстояние до ближайшего соседа \\(D_{min}\\) — это расстояние называется радиусом сферы влияния вершины. Остальные ребра триангуляции, инцидентные (примыкающие к) данной вершине, сохраняются только если их длина \\(D\\) превышает радиус ее сферы влияния не более чем вдвое: \\(D \\leq 2D_{min}\\). Рассуждая геометрически, можно сказать, что сферы радиусом \\(D_{min}\\), построенные в точке и ее соседях по триангуляции, должны пересекаться. Процесс фильтрации по сфере влияния иллюстрирует рисунок ниже. Поиск географических соседей по правилу сферы влияния Поиск соседей по сфере влияния построен по аналогии с принципом сферы действия тяготения из небесной механики. Построение соседей по правилу сферы влияния осуществляется в 3 шага: определение соседей по триангуляции (функция tri2nb()) фильтрация триангуляции по правилу сферы влияния (функция soi.graph()) преобразование полученного объекта в класс nb(функция graph2nb()) plot(reg, border=&quot;grey70&quot;) soinei = graph2nb(soi.graph(tri2nb(coords), coords)) plot(soinei, coords, pch = 19, cex = 0.5, add = TRUE) title(main=&quot;Соседи по сфере влияния&quot;) Соседи по графу Гэбриела получаются также путем фильтрации триангуляции Делоне. В каждом треугольнике ребро сохранятся только тогда, когда построенная на нем окружность не включает третью точку треугольника (Gabriel, Sokal, 1969)9. Данный метод проиллюстрирован рисунком ниже. Поиск географических соседей по графу Гэбриела Поиск соседей по графу Гэбриела осуществляется в 2 шага: построение графа Гэбриела (функция gabrielneigh()) преобразование полученного объекта в класс nb(функция graph2nb()) plot(reg, border=&quot;grey70&quot;) gabnei&lt;-graph2nb(gabrielneigh(coords)) plot(gabnei, coords, pch = 19, cex = 0.5, add = TRUE) title(main=&quot;Соседи по графу Гэбриела&quot;) Относительные соседи по графу получаются путем фильтрации триангуляции Делоне по следующему правилу: ребро \\(A\\), соединяющее две вершины \\(p\\) и \\(q\\), будет удалено, если найдется третья вершина \\(r\\), такая что расстояния от нее до \\(p\\) и \\(q\\) (\\(B\\) и \\(C\\) соответственно) окажутся короче, чем \\(A\\), то есть: \\(A &gt; B\\) and \\(A &gt; C\\). Полученный граф носит название графа относительных соседей (relative neighborhood graph). Данный метод был предложен французским информатиком Готфридом Туассеном для выявления структуры множества точек, которая бы максимально соответствовала восприятию человеком формы этого множества (Toussaint, 1980)10. Поиск соседей по графу относительных соседей осуществляется в 2 шага: построение графа относительных соседей (функция relativeneigh()) преобразование полученного объекта в класс nb(функция graph2nb()) plot(reg, border=&quot;grey70&quot;) relnei&lt;-graph2nb(relativeneigh(coords)) plot(relnei, coords, pch = 19, cex = 0.5, add = TRUE) title(main=&quot;Относительные соседи по графу&quot;) 15.2.3 Соседи по метрике Поиск соседей по метрике — наиболее простой способ определения соседства. Для его использования необходимо задать метрику (как правило, расстояние между точками), а также критерий фильтрации связей: по количеству (\\(k\\) ближайших) или по расстоянию (не ближе чем \\(d_1\\), но и не далее чем \\(d_2\\)). Поиск соседей по количеству осуществляется в 2 шага: построение списка соседей (функция knearneigh()) преобразование полученного объекта в класс nb(функция knn2nb()) Рассмотрим поиск по количеству на примере нескольких пороговых значений: par(mfrow = c(2,2)) for (i in 1:4){ knearnei&lt;-knn2nb(knearneigh(coords, k = i)) plot(reg, border=&quot;grey70&quot;) plot(knearnei, coords, pch = 19, cex = 0.5, add = TRUE) title(main = paste(&quot;Ближайшие соседи (k =&quot;, i, &quot;)&quot;, sep = &#39;&#39;)) } Поиск соседей по расстоянию осуществляется средствами функции dnearneigh(), которая принимает 3 аргумента: координаты точек, минимальное \\(d_1\\) и максимальное \\(d_2\\) расстояние. Минимальное расстояние имеет смысл использовать чтобы избежать анализа совпадающих по положению объектов, или когда известен пространственный период явления, превышающий \\(d_1\\): par(mfrow = c(2,2)) for (d in 3:6){ dnearnei &lt;- dnearneigh(coords, d1 = 0, d2 = d) plot(reg, border=&quot;grey70&quot;) plot(dnearnei, coords, pch = 19, cex = 0.5, add = TRUE) title(main = paste(&quot;Ближайшие соседи (d &lt;=&quot;, d, &quot;)&quot;, sep = &#39;&#39;)) } Итак, мы рассмотрели различные принципы выявления географического соседства. После того, как определен сам факт соседства, необходимо оценить силу пространственной связи между всеми парами соседних единиц. Эта оценка производится путем построения матрицы пространственных весов(spatial weights matrix). 15.3 Пространственные веса Пространственные веса характеризуют силу связи между единицами. Если единицы не являются соседними (по выбранному правилу), то пространственный вес их связи будет равен нулю. Во всех остальных случаях веса будут ненулевыми. Поскольку теоретически каждая единица может быть связана с любой другой единицей, распространена форма представления весов в виде матрицы \\(W\\) размером \\(N \\times N\\), где \\(N\\) – число единиц. На пересечении \\(i\\)-й строки и \\(j\\)-го столбца матрицы располагается вес связи между \\(i\\)-й и \\(j\\)-й единицей. Простейший вид матрицы \\(W\\) — бинарная. Если связь есть, то ее вес равен единице (1), если нет — нулю (0). Для построения бинарной матрицы нужно использовать функцию nb2listw() c параметром style=&quot;B&quot;: polynei&lt;-poly2nb(reg) Wbin&lt;-nb2listw(polynei,style=&quot;B&quot;) Wbin # посмотрим, что за объект получается на выходе (listw) Оказывается, что это на самом деле не матрица. Это объект с двумя слотами. В слоте weights содержатся веса, а в слоте neighbours — идентификаторы соседей: Wbin$neighbours Wbin$weights Дело в том, что матрица весов всегда получается разреженной. То есть, в основном она содержит нули. Это логично, поскольку у каждой точки как правило есть лишь ограниченное число соседей. При этом общее количество точек может быть достаточно большим: чем больше точек мы анализируем, тем больше будет нулей в матрице. Получается, что хранить матрицу как матрицу неэкономично. Более рационально для каждого объекта возвращать список весов, которые соответствуют его соседям. Что и делает функция nb2listw(). Матрицу весов как правило визуализируют, поскольку она может содержать в себе довольно интересные паттерны. Для этого полученный список весов нужно превратить в матрицу с помощью функции listw2mat(). Далее использовать функцию levelplot из пакета lattice, которая раскрашивает ячейки матрицы или растрового набора данных: M&lt;-listw2mat(Wbin) levelplot(M, main=&quot;Матрица весов (бинарная)&quot;) Более интересный результат дает нормированная матрица. В ней веса всех соседей нормируются на количество соседей. То есть, если у текущей точки 2 соседа, их веса будут равны 0.5. Если 3 соседа то 0.33, 4 — 0.25 и так далее. Взвешенная матрица позволяет отразить тот факт, что одна и та же территориальная единица может оказывать неодинаковое влияние на соседние единицы: Wstand&lt;-nb2listw(polynei, style = &quot;W&quot;) M&lt;-listw2mat(Wstand) ramp &lt;- colorRampPalette(c(&quot;white&quot;,&quot;red&quot;)) levels &lt;- 1/1:10 # шкала 1, 0.5, 0.33, 0.25 ... 0.1 levelplot(M, main=&quot;Матрица весов (нормированная)&quot;, at = levels, col.regions=ramp(10)) Обратите внимание, что на этот раз цвета в матрице распределены асимметрично. Однако есть методы определения соседства, которые приведут также и к асимметричному виду самой матрицы, а не только значений. Например, при поиске соседей по количеству соседство A и B вовсе не означает соседство B и A. Проверим это на опыте: # Ближайшие соседи (k = 1) knearnei&lt;-knn2nb(knearneigh(coords,k=1)) Wstand&lt;-nb2listw(knearnei, style = &quot;B&quot;) M&lt;-listw2mat(Wstand) levelplot(M, main=&quot;Матрица весов (нормированная)&quot;, at = levels, col.regions=ramp(10)) Полученная матрица весов дает искомую меру потенциальной пространственной связи (близости) между всеми парами территориальных единиц. Сопоставив эту меру со значениями показателя, зафиксированными в тех же единицах, можно получить статистическую оценку пространственной автокорреляции изучаемой величины. 15.4 Пространственная автокорреляция Далее мы рассмотрим вычисление меры пространственной автокорреляции — индекса Морана, который дает оценку статистической зависимости между значением показателя в каждой локации (территориальной единице) и значениями в соседних локациях. Имея предположение о наличии пространственной автокорреляции, можно построить модель пространственной авторегрессии, которая дает фоновое распределение показателя по территориальным единицам, а также случайные остатки. На этом занятии мы кратко познакомимся со статистической оценкой пространственной автокорреляции, а также построением простейших авторегрессионных моделей. Мы будем использовать месячную статистику по случаям заболеваний верхних дыхательных путей в Кировской области за 2015 год (данные Росстата по районам, модифицированы автором для большей наглядности анализа). Вам предстоит выполнить следующую последовательность действий: Загрузить исходные данные (границы районов и таблицу со статистикой) Присоединить таблицу к пространственным данным Построить серию карт по месяцам для визуального анализа данных Вычислить матрицу пространственных весов \\(W\\) Вычислить I-индекс Морана для численной оценки пространственной автокорреляции Построить диаграмму рассеяния Морана для визуальной оценки пространственной автокорреляции Подобрать параметры модели пространственной авторегрессии Построить карты реальных, модельных (fitted) значений и остатков (lag) Для начала построим серию карт чтобы оценить по ним наличие или отсутствие пространственной автокорреляции по месяцам: # Чтение базовых пространственных данных mun.sf &lt;- st_read(&quot;Kirov.gpkg&quot;) mun &lt;- as(mun.sf, &#39;Spatial&#39;) # Чтение таблицы со статистикой # classes &lt;- c(&quot;integer&quot;, &quot;character&quot;, rep(&quot;numeric&quot;, 10)) tab &lt;- read_xlsx(&quot;Kirov.xlsx&quot;, 1) # Соединение таблиц mun@data &lt;- merge(mun@data, tab, by.x=&quot;OBJECTID&quot;, by.y=&quot;N&quot;) # Построение серии карт months &lt;- names(mun)[22:31] # выбираем названия столбцов с месяцами ramp &lt;- colorRampPalette(c(&quot;white&quot;, &quot;orange&quot;, &quot;red&quot;)) levels &lt;- seq(0,10000,1000) nclasses &lt;- length(levels)-1 spplot(mun, months, at = levels, col.regions = ramp(nclasses)) Данная серия карт показывает, что наиболее интересный для анализа месяц — февраль, в котором наблюдается рост заболеваемости, а также очевидно наличие пространственной автокорреляции с двумя очагами в центральных и северо-зпапдных районах области. Вычислим матрицу пространственных весов: # Определение соседства (правило ферзя) nei&lt;-poly2nb(mun) # Визиуализация графа соседства coords &lt;- coordinates(mun) plot(mun, border=&quot;darkgray&quot;) plot(nei, coords, pch = 19, cex = 0.5, add = TRUE) title(main=&quot;Соседи по смежности (правило ферзя)&quot;) # Вычисление весов (нормированная матрица) W &lt;- nb2listw(nei) # Визуализация матрицы весов M&lt;-listw2mat(W) ramp2 &lt;- colorRampPalette(c(&quot;white&quot;,&quot;red&quot;)) levels2 &lt;- 1/1:10 # шкала 1, 0.5, 0.33, 0.25 ... 0.1 levelplot(M, main=&quot;Матрица весов (нормированная)&quot;, at = levels2, col.regions=ramp2(10)) 15.4.1 Индекс Морана (Moran’s I) Анализ пространственной автокорреляции осуществляется, как правило, путем вычисления индекса Морана (Moran’s I), : \\[ I = \\frac{n \\sum^n_{i=1} \\sum^n_{j=i} w_{ij} (y_i - \\bar y)(y_j - \\bar y)}{ \\Big[\\sum^n_{i=1} \\sum^n_{j=i} w_{ij}\\Big] \\Big[\\sum^n_{i=1} (y_i - \\bar y)^2\\Big]} \\] где \\(n\\) — количество единиц, \\(w_{ij}\\) — вес пространственной связи между \\(i\\)-й и \\(j\\)-й единицей, \\(y_i\\) — значение в \\(i\\)-й единице, \\(\\bar y\\) — выборочное среднее по всем единицам Обратим внимание на то, что индекс Морана по сути и форме записи похож на линейный коэффициент корреляции Пирсона, в котором перебираются все пары соответствующих друг другу значений из рядов \\(X = \\{x_i\\}\\) и \\(Y = \\{y_i\\}\\): \\[ r_{xy} = \\frac{\\sum_{i=1}^{n}(x_i - \\bar x)(y_i - \\bar y)}{\\sqrt{\\sum_{i=1}^{n}(x_i - \\bar x)^2} \\sqrt{\\sum_{i=1}^{n}(y_i - \\bar y)^2}} \\] При вычислении индекса Морана происходит нечто подобное, но под соответствием понимается наличие соседства между \\(i\\)-й и \\(j\\)-й территориальной единицей. Степень выраженности соседства задается весом \\(W_{ij}\\), который можно наблюдать в числителе формулы индекса Морана. Таким образом, пары территориальных единиц, для которых \\(w_{ij} = 0\\), не участвуют в вычислении индекса Морана. Индекс Морана для нормально распределенных данных лежит в диапазоне от -1 до 1: +1 означает детерминированную прямую зависимость — группировку схожих (низких или высоких) значений. 0 означает абсолютно случайное распределение (CSR — complete spatial randomness) -1 означает детерминированную обратную зависимость — идеальное перемешивание низких и высоких значений, напоминающее шахматную доску Для вычисления индекса Морана следует использовать функцию moran.test(), которая дополнительно оценивает статистическую значимость полученного значения: # Вычисление индекса (тест) Морана moran.test(mun$Февраль, W) ## ## Moran I test under randomisation ## ## data: mun$Февраль ## weights: W ## ## Moran I statistic standard deviate = 5.0335, p-value = 2.408e-07 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.52118132 -0.02564103 0.01180194 Результаты теста включают в себя следующие значения: Moran I statistic — полученный индекс Морана Expectation — математическое ожидание индекса при нулевой гипотезе \\(E[I]\\) Variance — дисперсия ожидаемого значения при нулевой гипотезе \\(D[I]\\) Moran I statistic standard deviate — \\(Z\\)-оценка вычисленного индекса Морана p-value — \\(p\\)-значение вычисленного индекса Морана Здесь мы видим, что значение индекса Морана равно ~\\(0.52\\) (Moran I statistic), то есть присутствует положительная пространственная автокорреляция. При этом вероятность того, что мы ошибаемся в наших выводах, и распределение на самом деле случайно - крайне мала и равна \\(2.408 \\times 10^{-7})\\) (p-value), то есть менее \\(0.0001\\%\\). Можно принимать гипотезу о наличии пространственной автокорреляции. Рассмотрим чуть подробнее, откуда берутся эти и остальные значения результатов теста, и как их правильно интерпретировать. Обычно для сравнения принимают предположение о том, что исследуемая величина распределена случайно. Это так называемая “нулевая” гипотеза. После того как мы вычислили индекс Морана по фактическим данным, можно вычислить его аналитически, приняв нулевую гипотезу. В этом случае математическое ожидание индекса \\(E[I] = -1/(n-1)\\), где \\(n\\) - количество территориальных единиц. Также может быть вычислена и дисперсия индекса Морана \\(D[I]\\) (в англоязычной литературе дисперсия обозначается \\(V[I]\\)). Эти два параметра определяют функцию распределения индекса Морана при всевозможных случайных расстановках исследуемой величины по территориальным единицам. Грубо говоря, такое распределение получится, если мы извлечем все фактические данные, будем их случайным образом перемешивать между территориями и каждый раз вычислять индекс Морана, повторяя процедуру бесконечное число раз. Полученные индексы будут распределены нормально. Значимость фактического индекса Морана можно оценить путем его сравнения с ожидаемым значением индекса \\(E[I]\\) и его стандартным отклонением \\(s = \\sqrt D\\) Для такой оценки используется \\(Z\\)-тест Фишера. \\(Z\\)-значение вычисляется по формуле: \\(Z = (I - E[I])/s\\) Эта величина говорит нам о том, на какое количество стандартных отклонений фактическое значение индекса Морана удалено от ожидаемого значения. Чем сильнее оно удалено — тем менее вероятно, что фактическое распределение случайно. Какова же эта вероятность? Каждому значению \\(Z\\)-score соответствует \\(p\\)-значение (p-value). P-value — это вероятность появления значений, удаленных от мат. ожидания далее чем \\(Z\\)-score. Например, при: \\(Z &lt; -1.96\\) или \\(Z &gt; +1.96\\) значение \\(p &lt; 0.05\\) \\(Z &lt; -2.58\\) или \\(Z &gt; +2.58\\) значение \\(p &lt; 0.01\\) Это означает, что вероятность того, что фактическое значение индекса Морана могло бы появиться на основе случайно распределенных данных с вероятностью \\(5\\%\\) и \\(1\\%\\) соответственно. Чем меньше \\(p\\), тем менее вероятно, что распределение случайно. Говорят, что \\(p\\) — это вероятность сделать ошибку первого рода, т.е. отвергнуть нулевую гипотезу, в то время как она на самом деле является истинной. 15.4.2 Перестановочный тест Морана Графически вышеприведенные рассуждения можно иллюстрировать с помощью перестановочного теста (permutation test). Для этого значения исследуемой нами величины перемешиваются между территориальными единицами и далее строится гистограмма распределения. Перестановочный тест выполняется с помощью функции moran.mc() с параметром nsim =, задающим число перестановок: sim&lt;-moran.mc(mun$Февраль, listw = W, nsim = 10000) sim # Построим гистограмму по вычисленным индексам: hist(sim$res, freq=TRUE, breaks=20, xlim = c(-1,1), main = &quot;Перестановочный тест Морана&quot;, xlab = &quot;Случайный индекс Морана&quot;, ylab = &quot;Частота появления&quot;, col = &quot;steelblue&quot;) # Нанесем фактическое значение abline(v = sim$statistic, col = &quot;red&quot;) 15.4.3 Диаграмма рассеяния Морана Наконец, еще одним графическим инструментом оценки пространственной автокорреляции является диаграмма рассеяния Морана. По оси \\(X\\) откладывается значение в каждой территориальной единице, в по оси \\(Y\\) — ее пространственный лаг, который представляет собой средневзвешенное значение по всем ее соседям: moran.plot(mun$Февраль, W) На диаграмме рассеяния Морана линиями отмечаются средние значения по обеим осям, а наклонной линией представляется линейная регрессия этих значений, при этом тангенс угла наклона кривой равен значению индекса Морана. Поскольку в данном случае распределение явно не случайно, можно приступать к его моделированию. 15.5 Пространственная авторегрессия В статистике моделирование данных, обладающих автокорреляцией, осуществаляется с помощью авторегрессионных моделей (AR-моделей). Авторегрессионная модель связывает значения временного ряда в данный момент с предыдущими значениями этого же ряда. В пространственной статистике используется аналогичная методика, только в роли данного момента выступает данная территориальная единица, а в роли предыдущих значений — значения в соседних территориальных единицах (см. презентацию). После того как параметры пространственной авторегрессии подобраны, можно вычислить значение в каждой единице по соседним значениям, а также ошибку полученного значения путем вычитания из реального значения. Простейшая модель пространственной авторегрессии строится как: \\[ Z = \\mu + \\sum b(z-\\mu) + \\epsilon \\] где \\(Z\\) - значение в текущей единице, \\(z\\) - значение в соседней единице, \\(\\mu\\) — среднее значение (вычисленное по всем единицам), \\(b\\) - весовой коэффициент и \\(ε\\) — случайная ошибка. Подобное уравнение может быть составлено для каждой территориальной единицы. При этом суммирование производится по всем соседним территориальным единицам а неизвестный коэффициент \\(b\\) обычно представляют в виде \\(b = \\lambda w\\), то есть как отмасштабированный на величину \\(\\lambda\\) вес связи между единицей и ее текущим соседом. Задача построения модели строится к поиску такого значения \\(\\lambda\\), который бы минимизировал сумму квадратов ошибок ε по всем территориальным единицам. Если мы знаем, что в каждой единице значение связано не только с окружением, но также с другой величиной, то это можно моделировать заменив в вышеприведенном уравнении \\(\\mu\\) на \\(a + bY\\), где \\(Y\\) — объясняющая величина, а коэффициенты \\(a\\) и \\(b\\) подбираются путем построения линейной регрессии между \\(Z\\) и \\(Y\\). Для построения модели пространственной авторегрессии используется функция spautolm(), принимающая два основных параметра — формулу и матрицу пространственных весов. Формула — это специальный объект R для обозначения статистической зависимости. Например, если в таблице tab есть столбец Z, зависящий от X и Y, то соответствующая формула будет выглядеть следующим образом: Z ~ X + Y В случае если зависимости нет, используется следующая нотация: Z ~ 1 Мы будем использовать простейший вариант пространственной авторегрессии без объясняющих факторов \\((Z = \\mu + \\sum \\lambda w(z-\\mu) + \\epsilon)\\). Следовательно, используем вариант ~1: model &lt;- spautolm(mun$Февраль ~ 1, listw=W) model ## ## Call: ## spautolm(formula = mun$Февраль ~ 1, listw = W) ## ## Coefficients: ## (Intercept) lambda ## 4146.277473 0.704957 ## ## Log likelihood: -346.2344 Расшифровываются параметры модели следующим образом: Intercept = \\(\\mu\\), lambda = \\(\\lambda\\) Извлекаем модельные значения \\(Z\\) и записываем в таблицу mun$fitted &lt;- fitted(model) # Извлекаем остатки ε и записываем в таблицу mun$residuals &lt;- residuals(model) # Сравниваем исходные данные, модельные и остатки spplot(mun, zcol=c(&quot;Февраль&quot;,&quot;fitted&quot;, &quot;residuals&quot;), names.attr = c(&quot;Фактические значения&quot;, &quot;Модель&quot;, &quot;Остатки&quot;), at = levels, col.regions = ramp(nclasses)) 15.6 Локальные показатели пространственной ассоциации (LISA) 15.7 Географически взвешенная реграссия (GWR) Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 Hubert, L. J., R. G. Golledge, and C. M. Costanza (1981). Generalized Procedures for Evaluating Spatial Autocorrelation. Geographical Analysis 13, 224–32. DOI: 10.1111/j.1538-4632.1981.tb00731.x↩ Gabriel K. R., Sokal R. R. (1969), A new statistical approach to geographic variation analysis, Systematic Zoology, Society of Systematic Biologists, 18 (3): 259–270, DOI: 10.2307/2412323↩ Toussaint G. T. (1980), The relative neighborhood graph of a finite planar set, Pattern Recognition, 12 (4): 261–268, DOI: 10.1016/0031-3203(80)90066-7↩ "],
["point-patterns.html", "Глава 16 Анализ точечных процессов", " Глава 16 Анализ точечных процессов Программный код главы Раздел посвящен анализу точечных процессов в R. [To be written…] "]
]
