[
<<<<<<< HEAD
["vector-analysis.html", "Глава 11 Пространственный анализ 1. Векторные методы 11.1 Пространственные запросы 11.2 Постановка задач и изучение данных 11.3 Анализ расстояний 11.4 Анализ взаимного положения (топологический) 11.5 Анализ абсолютных зон окружения 11.6 Анализ конкурентных зон окружения 11.7 Анализ зон транспортной доступности 11.8 Построение маршрутов и матриц времени движения 11.9 Контрольные вопросы и упражнения", " Глава 11 Пространственный анализ 1. Векторные методы Программный код главы Данный модуль посвящен пространственному анализу в R. Несмотря на то, что пространственный анализ — чрезвычайно широкая и многогранная область геоинформатики, все методы, которые объединяются под этим заголовком, базируются на ограниченном числе базовых операций, таких как вычисление расстояний, оценка плотности распределения, построение буферных зон и выполнение пространственных запросов. В настоящем модуле мы рассмотрим, как одно и то же множество пространственных объектов можно анализировать в различных контекстах, используя базовые методы пространственного анализа Пространственный анализ связан с оценкой размещения объектов и распределения величин в географическом пространстве. В геоинформатике для этих целей используется два подхода: геометрический и статистический. Эти подходы образуют две ступени пространственного анализа: как правило, данные геометрического анализа представляют собой входную информацию для анализа статистического. Геометрический подход связан с вычислением расстояний между географическими локациями, а также агрегированием объектов/интегрированием показателей в пределах заданных областей, вдоль линий или в окрестности точек. Поиск входной информации для агрегирования решается путем выполнения пространственных запросов. 11.1 Пространственные запросы Пространственные запросы связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве пространственных отношений. В свою очередь, пространственные отношения бывают трех типов: дирекционные (направления), метрические (расстояния) и топологические (взаимное размещение). Примеры пространственных запросов знакомы любому географу: Найти все объекты внутри административного района (топологические отношения) Найти все объекты не далее 100 метров от дороги (метрические отношения) Найти все объекты, расположенные к северу от точки (дирекционные отношения) Пространственные запросы могут объединять несколько условий. Можно найти объекты, удовлетворящие одновременно всем (логическое И) вышеперечисленным условиям: внутри района, не далее 100 м от дороги и к северу от выбранной точки; или хотя бы одному (логическое ИЛИ) из вышеперечисленных условий. Результат выполнения такого комплексного запроса будет являться, соотвественно, пересечением множеств объектов, полученных каждым из запросов, или их объединением. Наконец, пространственные запросы можно объединять с атрибутивными и временными. Атрибутивные запросы связаны с поиском объектов (географических локаций), удовлетворяющих условию, заданному на множестве характеристик объектов. Временные запросы определены на множестве шкалы времени. Например, можно найти все населенные пункты населением свыше 10 000 человек (атрибутивный запрос), находящиеся в пределах выбранного административного района (пространственный запрос, основанный на топологических отношениях), время движения от которых до районного центра не превышает 90 минут (временной запрос). 11.1.1 Контекстные и целевые объекты При выполнении пространственного анализа, в общем случае, имееются множества объектов двух типов: контекстные — объекты, относительно которых будет оцениваться размещение других объектов, то есть, определяющие контекст анализа целевые — объекты, размещение которых анализируется по отношению к контекстным объектам, что является целью анализа Эти множества, разумеется, могут совпадать. Скажем, мы можем проанализировать размещение магазинов относительно других магазинов. 11.1.2 Зоны окружения объектов Весьма часто в качестве контекстного множества используются не реальные пространственные объекты, а набор абстрактных геометрических объектов, каждый из которых является производным от оригинального пространственного объекта. Как правило, такие геометрии представляют из себя зоны окружения объектов, построенные по некоторому формальному признаку. Методы построения зон окружения можно разделить по двум критериям: учету взаимного размещения объектов (абсолютные и конкурентные зоны) и пространству признаков, в котором эти зоны строятся. Если зоны окружения строятся без учета взаимного размещения объектов, то есть, независимо для каждого объекта, то мы будем называть их абсолютными. Абсолютные зоны окружения строятся путем фиксации порогового расстояния либо времени движения относительно исходного объекта. Такие зоны носят название буферных зон (по расстоянию) или зон доступности (по времени). Границей абсолютной зоны окружения является изолиния, построенная по соответствующему показателю. В случае времени это будет изохрона. Примеры абсолютных зон окружения: Водоохранная зона реки 200 метров (буферная зона) Площадь городской территории, в любую точку которой вы можете доехать из дома на машине в течение 30 минут (зона доступности) Если же при построении зон окружения учитывается взаимное размещение объектов, то в данном случае зоны доступности строятся не исходя из порогового значения показателя (хотя оно может использоваться дополнительно), а исходя из того, какой объект является ближайшим. Конкурентные зоны окружения представляют собой разбиение пространства на неперекрывающиеся участки без дыр, каждый из которых является зоной окружения соответствующего пространственного объекта. При этом любая точка внутри зоны окружения объекта ближе к этому объекту по выбранному признаку (времени или расстоянию), нежели к любому другому объекту. Конкурентные зоны окружения, построенные по расстоянию, можно реализовать средствами диаграммы Вороного. 11.2 Постановка задач и изучение данных В настоящем моделе мы рассмотрим вышеперечисленные методы на примере анализа размещения пунктов общественного питания — кафе, ресторанов и т.д. Используя методы пространственного анализа в среде R, мы ответим на следующие вопросы: Какие улицы являются местами наибольшей концентрации заведений общественного питания? Как распределены заведения общественного питания по районам центра Москвы? Какие заведения общественного питания находятся вблизи метро и на берегу реки? В какие заведения общественного питания можно доехать от выбранной точки в течение 5 минут? Каков оптимальный маршрут между вашим местоположением и заведением, в котором вы хотите пообедать? В качестве источника данных используем OpenStreetMap — краудсорсинговый интернет-проект по созданию бесплатных и открытых пространственных данных глобального охвата. Данные OpenStreetMap в удобном для использования в ГИС виде доступны на портале GIS-Lab. Для решения задач настоящего модуля нам понадобятся следующие дополнительные пакеты, которые мы не использовали ранее: osrm — построение зон доступности, маршрутов и матриц корреспонденции онлайн на основе данных OpenStreetMap и OSRM API. cartography — пакет, облегчающий построение тематических карт и легенд средствами стандартной функции plot(). Начнем наше исследование с визуального анализа исходных данных library(sf) library(dplyr) library(classInt) library(osrm) # Использование онлайн-сервиса маршрутизации OSRM library(cartography) # Удобное построение тематических карт средствами plot() # Чтение данных roads = st_read(&quot;roads.gpkg&quot;) # Дороги poi = st_read(&quot;poi_point.gpkg&quot;) # Точки интереса rayons = st_read(&quot;boundary_polygon.gpkg&quot;) # Границы районов stations = st_read(&quot;metro_stations.gpkg&quot;) # Станции метро water = st_read(&quot;water_polygon.gpkg&quot;) # Водные объекты # Прочитаем текущие параметры компоновки def = par(no.readonly = TRUE) # Уберем поля, чтобы карта занимала весь экран par(mar = c(0,0,0,0)) # Получим ограничивающий прямоугольник слоя дорог в качестве общего охвата карты frame = roads %&gt;% st_bbox() %&gt;% st_as_sfc() %&gt;% st_geometry() ## ОБЗОР ИСХОДНЫХ ДАННЫХ ------------------------------------- # Визуализируем входные данные plot(frame) plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray70&quot;, add = TRUE) plot(poi %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.2, add = TRUE) Теперь приступим к изучению данных, хранящихся в слое poi (от англ. POI — Point Of Interest). Данный слой содержит все точечные маркеры OSM, которыми были отмечены на карте объекты, представляющие (по мнению создателей данных) интерес для пользователей. В POI включаются самые разнообразные объекты, такие как: объекты сферы услуг (amenity), места для отдыха (leisure), офисные здания (office), магазины и торговые центры (shop), туристические достопримечательности (tourism), спортивные объекты (sport), примечательные инженерные сооружения (man_made). В наших данных информация разнесена по соответствующим полям, каждый объект снабжен уникальным идентификатором: View(poi) Заведения общественного питания по классификатору OSM относятся к классу amenity. Поскольку данный классификатор представляет собой множество номинальных (категориальных) данных, можно начать изучение состава данных с помощью таблицы частот, которая строится средствами функции table(): stats = data.frame(table(poi$AMENITY)) View(stats) Для дальнейшего анализа отберем из всего множества объектов сферы услуг заведения, где можно поесть: рестораны, кафе, бары, пабы и заведения быстрого питания (фастфуд). В классификаторе OSM эти заведения имеют тип restaurant, bar, cafe, pub и fast_food. Для отбора нужных строк и столбцов используем dplyr: poi.food = poi %&gt;% select(NAME, AMENITY) %&gt;% filter(AMENITY %in% c(&quot;restaurant&quot;, &quot;bar&quot;, &quot;cafe&quot;, &quot;pub&quot;, &quot;fast_food&quot;)) head(poi.food) ## Simple feature collection with 6 features and 2 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 410954.9 ymin: 6178842 xmax: 411023.8 ymax: 6181896 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs ## NAME AMENITY geometry ## 1 Аршин restaurant POINT (410975.2 6181661) ## 2 Андерсон restaurant POINT (410954.9 6180118) ## 3 Holynoot fast_food POINT (410958.8 6179938) ## 4 Gayane&#39;s restaurant POINT (410958.4 6178842) ## 5 Molon Lave restaurant POINT (411013.7 6181448) ## 6 Шоколадница cafe POINT (411023.8 6181896) 11.3 Анализ расстояний Метрические отношения связывают объекты в терминах расстояний между ними. Предположим, что мы хотим определить улицы, являющиеся сосредоточением заведений питания. Один из вариантов решения состоит в том, чтобы для каждого пункта обслуживания определить ближайшую к нему улицу и далее для каждой улицы просуммировать количество раз, которое улиц оказалось ближайшей. Подробнее алгоритм решения выглядит следующим образом: Вычислить матрицу расстояний между пунктами обслуживания и улицами. Размер матрицы \\(M \\times N\\), где \\(M\\) — количество улиц (строк), \\(N\\) — количество пунктов (столбцов) Найти в каждом столбце минимальное расстояние. Получить идентификатор улицы (номер строки), соответствующий данному расстоянию. Записать идентификатор в выходной вектор. Таким образом, мы получим вектор из идентификаторов улиц, при этом каждый идентификатор будет встречаться в этом векторе столько раз, сколько раз данная улица оказалась ближайшей к какому-то объекту. Вычислим матрицу расстояний с помощью функции st_distance() из пакета sf: ## АНАЛИЗ РАССТОЯНИЙ ------------------------------------- dist.matrix = st_distance(roads, poi.food) # посмотрим, как выглядит результат на примере первых пяти объектов print(dist.matrix[1:5,1:5]) ## Units: m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 4962.292 3420.6849 3240.2066 2145.2044 4748.686 ## [2,] 2247.737 705.2923 524.9411 570.3986 2035.341 ## [3,] 2213.236 670.7904 490.4167 605.1606 2000.759 ## [4,] 2197.874 655.4285 475.0629 620.4411 1985.242 ## [5,] 3910.957 2368.5560 2188.1348 1092.5472 3698.246 Далее необходимо в каждом столбце матрицы найти номер строки с минимальным расстоянием. Для этого необходимо получить порядок сортировки элементов по возрастанию значений данного столбца и взять номер первого элемента. Операцию можно применить с помощью apply ко всем столбцам: ids = apply(dist.matrix, 2, function(X) order(X)[1]) Теперь применим уже знакомую нам функцию table(), чтобы подсчитать, сколько раз каждая улица оказалась наиболее близкой. Далее присоединим статистику к исходным улицам, однако для этого нам потребуется вынести названия строк (номеров) улиц в отдельный столбец. count.stats = as.data.frame(table(ids)) roads = roads %&gt;% mutate(id = row.names(.)) roads.poi = merge(roads, count.stats, by.x = &#39;id&#39;, by.y = &#39;ids&#39;, all.x = T) Посмотрим первые 10 улиц по количеству общепита: # Статистика по улицам в табличном представлении (первые 10) roads.poi %&gt;% select(NAME, Freq) %&gt;% arrange(desc(Freq)) %&gt;% head(10) ## Simple feature collection with 10 features and 2 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: 411105.1 ymin: 6178083 xmax: 414504.1 ymax: 6181734 ## epsg (SRID): 32637 ## proj4string: +proj=utm +zone=37 +datum=WGS84 +units=m +no_defs ## NAME Freq geometry ## 1 улица Арбат 43 MULTILINESTRING ((412157.9 ... ## 2 улица Новый Арбат 24 MULTILINESTRING ((411105.1 ... ## 3 Цветной бульвар 22 MULTILINESTRING ((413491.7 ... ## 4 Мясницкая улица 20 MULTILINESTRING ((414504.1 ... ## 5 Никольская улица 17 MULTILINESTRING ((413704.5 ... ## 6 Пятницкая улица 17 MULTILINESTRING ((413895.8 ... ## 7 Неглинная улица 14 MULTILINESTRING ((413498.2 ... ## 8 улица Рождественка 14 MULTILINESTRING ((413628.1 ... ## 9 Козицкий переулок 14 MULTILINESTRING ((412831.7 ... ## 10 улица Большая Дмитровка 14 MULTILINESTRING ((413262.7 ... Для завершения анализа осталось визуализировать результаты. Чтобы усилить наглядность визуализации, мы не будем каждую улицу утолщать пропорционально количеству привязанных объектов, а разделим это количество на 4 класса. Каждый класс покажем линией соответствующей толщины и интенсивности цвета (чем больше объектов привязано к улице, тем толще линия, темнее и насыщеннее ее цвет). Для классификации используем функцию cut(), позволяющую перекодировать интервальные данные в номинальные, то есть сопоставить каждому элементу вектора некий класс, которому он принадлежит. На выходе будем иметь вектор, который состоит из такого же количества элементов, что и исходный, но вместо исходных значений будут стоять названия классов. # Получим границы классов nclasses = 4 class.breaks = classIntervals(roads.poi$Freq, n = nclasses, style = &quot;jenks&quot;) # Извлечем граничные интервалы borders = class.breaks$brks # Названия классов — они же толщины линия от 1 до 4 line.widths = 1:nclasses # Перекодируем столбец количества присоединенных пунктов в классы sizes = cut(roads.poi$Freq, breaks = borders, labels = line.widths) Теперь присвоим каждому объекту свой цвет в соответствии с классом, который ему присвоен. Удобная функция findColours() позволяет найти цвет для каждого объекта в соответствии с полученной классификацией: base.colors = c(&quot;mistyrose&quot;, &quot;red&quot;) ramp = colorRampPalette(base.colors) colors = findColours(class.breaks, base.colors) plot(frame) plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray70&quot;, add = TRUE) plot(roads.poi %&gt;% st_geometry(), lwd = sizes, col = colors, add = TRUE) plot(poi.food %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.2, add = TRUE) # Функция legendGradLines из пакета cartography позволяет строить # легенду для карт линий градуированных размеров: legendGradLines(title.txt = &quot;Пункты питания&quot;, pos = &quot;left&quot;, title.cex = 0.8, values.cex = 0.6, breaks = borders, lwd = line.widths, col = &quot;red&quot;) 11.4 Анализ взаимного положения (топологический) Пространственные запросы, основанные на топологических отношениях, позволяют находить объекты, находящиеся внутри других объектов, соприкасающиеся с другими объектами, пересекающиеся с ними и так далее. Топологические отношения сохраняются при взаимно-однозначных и непрерывных преобразованиях плоскости. Отличия от метрических отношений легко пояснить на примере преобразования проекции. Представьте, что карту России в конической проекции с концентрическими параллелями (известную по учебникам и атласам) вы трансформировали в карту России в проекции Меркатора (такую же как на Google Maps). Изогнутые параллели превратились в прямые линии; форма регионов, площади и расстояния между населенными пунктами значительно изменились. Однако Красноярск по-прежнему находится в Красноярском крае, Ярославль — на реке Волге, Нижний Новгород — на правом берегу Волги, озеро Белое — внутри Вологодской области, а Московская область как не граничила с Тамбовской, так и не граничит после трансформации проекции. Это и есть топологические отношения. Формально топологические отношения в ГИС описываются с помощью модели девяти пересечений DE-9IM, которая была рассмотрена в предыдущей лекции. ## АНАЛИЗ ВЗАИМНОГО ПОЛОЖЕНИЯ ------------------------------------- poi.food = poi.food %&gt;% mutate(count = 1) rayons.poi = aggregate(poi.food[&#39;count&#39;], rayons, sum) # Преобразуем результат в относительный показатель # (единиц на кв.км. площади) и запишем в таблицу районов: rayons.poi$density = 1000000 * rayons.poi$count / st_area(rayons.poi) Масштабный множитель 1000000 в коде понадобился чтобы перевести площадь, храняющуюся в поле Shape_Area из квадратных метров в квадратные километры. Обратите внимание на то, что в данном случае мы не стали ограничивать фигурными скобками тело анонимной функции (table(X)[2]) внутри apply(), поскольку выполняемая операция достаточно компактна. Подготовим параметры отображения: # Настроим параметры отображения choro.pal = colorRampPalette(c(&quot;lightgoldenrodyellow&quot;, &quot;orangered&quot;)) intervals = classIntervals(rayons.poi$density, n = 5, style = &quot;quantile&quot;) Далее используем функции choroLayer() и legendChoro() из пакета cartography для построения картограмм плотности пунктов питания и соответствующей им легенды средствами обычной функции plot(): choroLayer(rayons.poi, # Исходный слой типа SpatialPolygonsDataFrame var = &quot;density&quot;, # Картографируемая переменная (столбец) breaks = intervals$brks, # Границы интервалов col = choro.pal(5), # Цвета для соответствующих интервалов legend.pos = &quot;n&quot;) # Легенду мы нарисуем позднее, поверх всех слоев plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray50&quot;, add = TRUE) plot(poi.food %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.5, add = TRUE) plot(rayons %&gt;% st_geometry(), border = &quot;black&quot;, lwd = 3, add = TRUE) text(rayons %&gt;% st_centroid() %&gt;% st_coordinates(), labels = gsub(&#39; &#39;, &#39;\\n&#39;, rayons$NAME), font = 2, cex = 0.6) # Рисуем легенду legendChoro(breaks = intervals$brks, col = choro.pal(5), pos = &quot;topleft&quot;, frame = FALSE, title.txt = &quot;Заведений на 1 кв.км&quot;) Итак, используя топологический пространственный запрос “Содержит”, мы смогли агрегировать точечные объекты внутри площадных и построить картограммы плотности распределения пунктов питания по районам центра Москвы. 11.5 Анализ абсолютных зон окружения Задача данного раздела модуля звучит следующим образом: определить, какие пункты питания находятся в радиусе 300 метров от метро “Кропоткинская”. Контекстом анализа в данном случае служит 300-метровая зона окружения станции метро. Поставленную задачу можно решить двумя способами: Рассчитать расстояния от каждого пункта питания до станции метро “Кропоткинская” и выбрать точки, для которых это расстояние меньше или равно 300 метрам. Построить буферную зону радиусом 300 метров и выбрать ею точки, используя топологическое отношение пересечения Мы будем использовать второй вариант решения. Алгоритм выглядит следующим образом: Построить буферную зону, используя функцию st_buffer() из пакета sf. Выбрать полученной зоной точки пунктов питания, используя стандартный оператор []. Визуализировать на карте полученные точки и буферную зону. Определим функцию plotBasemap(), которая будет рисовать объекты картографической основы, ее мы будем использовать далее неоднократно. ## АНАЛИЗ АБСОЛЮТНЫХ ЗОН ОКРУЖЕНИЯ ------------------------------------- # Функция отвечает за рисование базовой карты plotBasemap = function(){ plot(frame) plot(water %&gt;% st_geometry(), col = &quot;lightskyblue1&quot;, border = &quot;lightskyblue3&quot;, add = TRUE) plot(roads %&gt;% st_geometry(), col = &quot;gray70&quot;, add = TRUE) plot(poi.food %&gt;% st_geometry(), col = &quot;deepskyblue4&quot;, pch = 20, cex = 0.3, add = TRUE) plot(stations %&gt;% st_geometry(), col = &quot;slategray4&quot;, pch = 20, cex = 2, add = TRUE) text(stations %&gt;% st_centroid() %&gt;% st_coordinates(), labels = &quot;M&quot;, col = &quot;white&quot;, cex = 0.4) } Определив вспомогательные функции, можем приступать к выполнению анализа: # Выберем станцию метро и построим буферную зону krop = stations %&gt;% filter(NAME == &quot;Кропоткинская&quot;) zone = st_buffer(krop, dist = 300) # Применим разработанную функцию для отбора точек selected.poi = poi.food[zone, ] # Применим разработанную функцию для рисования картографической основы plotBasemap() # Визуализируем результаты анализа plot(krop %&gt;% st_geometry(), col = &quot;red&quot;, pch = 20, cex = 4, add = TRUE) text(krop %&gt;% st_coordinates(), labels = &quot;M&quot;, col = &quot;white&quot;, cex = 0.7, add = TRUE) plot(zone %&gt;% st_geometry(), col = adjustcolor(&quot;sienna3&quot;, alpha.f = 0.5), border = &quot;sienna3&quot;, add = TRUE) plot(selected.poi %&gt;% st_geometry(), col = &quot;sienna4&quot;, pch = 20, cex = 0.5, add = TRUE) # Найденные объекты в табличном представлении: View(selected.poi) В качестве примера аналогичного анализа отберем все пункты питания, находящиеся в пределах 100 метров от реки Москвы: river = water %&gt;% filter(NAME == &quot;Москва&quot;) zone = st_buffer(river, dist = 100) selected.poi = poi.food[zone, ] plotBasemap() plot(zone %&gt;% st_geometry(), col = adjustcolor(&quot;orange&quot;, alpha.f = 0.5), border = &quot;orange&quot;, add = TRUE) plot(river %&gt;% st_geometry(), col = adjustcolor(&quot;deepskyblue&quot;, alpha.f = 0.5), border = F, add = TRUE) plot(selected.poi %&gt;% st_geometry(), col = &quot;firebrick1&quot;, pch = 20, cex = 0.5, add = TRUE) # Найденные объекты в табличном представлении: View(selected.poi) 11.6 Анализ конкурентных зон окружения В данном разделе мы решим следующую задачу: разбить всю изучаемую территорию на зоны окружения станций метро и подсчитать количество пунктов питания, попадающих в каждую зону. Полученные зоны должны быть конкурентными: любая точка, находящаяся в зоне окружения конкретной станции метро, должна быть ближе к этой станции, чем к любой другой станции. Ранее мы говорили о том, что конкурентные зоны окружения по расстоянию можно реализовать с помощью диаграммы Вороного. Применим функцию voronoi() из пакета dismo, чтобы посмотреть, как выглядит диаграмма Вороного для точек станций метро. Нам потребуется для этого конвертировать объекты в тип Spatial, а результат преобразовать вернуть обратно в sf: ## АНАЛИЗ КОНКУРЕНТНЫХ ЗОН ОКРУЖЕНИЯ ------------------------------------- zones = stations %&gt;% as(&#39;Spatial&#39;) %&gt;% dismo::voronoi() %&gt;% st_as_sf() plot(zones %&gt;% st_geometry()) plot(stations, add = TRUE, pch = 19, col = &#39;black&#39;) Для визуализации результатов мы будем использовать метод картодиаграмм (пропорциональных символов), реализованный в функции propSymbolsLayer() пакета cartography. Размером кружка покажем количество пунктов питания, оказавшихся в каждой зоне окружения: # Агрегруем данные по каждой зоне zones.poi = aggregate(poi.food[&#39;count&#39;], zones, sum) # Визуализируем результат plotBasemap() plot(zones %&gt;% st_geometry(), col = adjustcolor(&quot;white&quot;, alpha.f = 0.5), add = TRUE) propSymbolsLayer(zones.poi, var = &quot;count&quot;, symbols = &quot;circle&quot;, col = adjustcolor(&quot;turquoise3&quot;, alpha.f = 0.5), border = F, legend.title.txt = &quot;Заведений питания&quot;) text(zones %&gt;% st_centroid() %&gt;% st_coordinates(), labels = zones.poi$count, col = &quot;turquoise4&quot;, cex = log(zones.poi$count)/4) 11.7 Анализ зон транспортной доступности Зоны транспортной доступности представляют из себя зоны окружения объектов, построенные не по евклидову расстоянию, а по расстоянию или времени движения по дорожной сети. В задачах логистики и геомаркетинга зоны транспортной доступности часто называют зонами обслуживания (service area), поскольку используются для определения территории, которую может покрыть объект, предоставляющий некоторые услуги. Например, для пожарного депо зона 10-минутной доступности показывает территорию города, в любую точку которой пожарная машина может доехать из данного депо в течение 10 минут. И наоборот, для торгового центра зона 10-минутной доступности показывает территорию города, из любой точки которой можно добраться до ТЦ в течение 10 минут. Очевидно, что продолжительность прямого и обратного маршрута неодинакова, на нее может оказывать влияние схема движения, приоритет дорог и так далее. Задача, которую мы решим в данном разделе, звучит так: определить все заведения питания, находящиеся в 7 минутах езды от Центрального детского магазина. Для построения зоны доступности мы будем использовать пакет osrm, предоставляющий интерфейс R к онлайн-библиотеке маршрутизации OSRM, работающей на основе данных OSM. Для построения зоны доступности (изохроны) нам понадобится функция osrmIsochrone() из данного пакета. Внимание: для выполнения этого раздела модуля необходимо подключение к Интернету Поскольку данные, используемые в настоящем модуле, предварительно были конвертированы в проекцию UTM и хранятся в метрах, а OSRM решает все задачи в географических координатах (широте и долготе относительно эллипсоида WGS84), нам необходимо научиться работать с проекциями данных и преобразовывать системы координат между собой. ## АНАЛИЗ ЗОН ТРАНСПОРТНОЙ ДОСТУПНОСТИ ------------------------------------- # Инициализируем систему координат WGS84, используемую в OSRM WGS84 = st_crs(4326) # Извлечем информацию о системе координат исходных точек UTM = st_crs(poi) # Выберем целевой объект psel = poi %&gt;% filter(NAME == &quot;Центральный детский магазин&quot; &amp; SHOP == &quot;toys&quot;) # Преобразуем координаты точки в WGS84 psel.wgs = st_transform(psel, WGS84) # Получаем 5-минутную зону транспортной доступности # с помощью пакета osrm service_area = osrmIsochrone(loc = psel.wgs %&gt;% st_coordinates() %&gt;% as.vector(), breaks = 7) # Преобразуем зону обратно в UTM для дальнейших операций service_area_utm = st_transform(st_as_sf(service_area), UTM) # Отбираем точки selected_poi = poi.food[service_area_utm, ] # Визуализируем результат plotBasemap() plot(service_area_utm %&gt;% st_geometry(), col = adjustcolor(&quot;violetred3&quot;, alpha.f = 0.2), border = &quot;violetred3&quot;, add = TRUE) plot(selected_poi %&gt;% st_geometry(), col = &quot;violetred3&quot;, pch = 20, cex = 0.5, add = TRUE) plot(psel %&gt;% st_geometry(), col = &quot;violetred4&quot;, pch = 20, cex = 4, add = TRUE) Итак, в данном разделе мы научились строить зоны транспортной доступности в виде полигонов, ограниченных изохроной времени движения. 11.8 Построение маршрутов и матриц времени движения В этом разделе модуля пространственного анализа мы посмотрим, каким образом можно построить оптимальный маршрут между двумя точками, а также получить матрицу времени движения между точками (на примере станций метро). Для решения этих задач используем следующие функции пакета osrm: osrmRoute(src, dest) — строит оптимальный маршрут между точками src и dest osrmTable(loc) — строит матрицу времени движения между всеми парами точек в loc Так же, как и в предвдущем разделе, нам понадобятся преобразования координат. Построим оптимальный маршрут между книжным магазином “Молодая Гвардия” на Полянке и чебуречной “Дружба” на метро Сухаревская: ## ПОСТРОЕНИЕ МАРШРУТОВ ------------------------------------- # Выбираем и проецируем начальную точку origin = poi %&gt;% filter(NAME == &#39;Молодая Гвардия&#39;) origin_wgs = st_transform(origin, WGS84) # Выбираем и проецируем конечную точку destination = poi %&gt;% filter(NAME == &#39;Чебуречная &quot;Дружба&quot;&#39;) destination_wgs = st_transform(destination, WGS84) # Строим маршрут route = osrmRoute(origin_wgs %&gt;% as(&#39;Spatial&#39;), destination_wgs %&gt;% as(&#39;Spatial&#39;), overview = &quot;full&quot;, # запретить генерализацию линий sp = TRUE) # вернуть результат в виде объекта класса Spatial # Преобразуем результат обратно в UTM route.utm = st_transform(route %&gt;% st_as_sf(), UTM) # Визуализируем результат: plotBasemap() plot(route.utm %&gt;% st_geometry(), lwd = 3, col = &quot;orange&quot;, add = TRUE) plot(origin %&gt;% st_geometry(), col = &quot;tomato3&quot;, pch = 20, cex = 3, add = TRUE) text(origin %&gt;% st_coordinates(), labels = &quot;O&quot;, col = &quot;tomato4&quot;, cex = 0.5) plot(destination %&gt;% st_geometry(), col = &quot;tomato&quot;, pch = 20, cex = 4, add = TRUE) text(destination %&gt;% st_coordinates(), labels = &quot;D&quot;, col = &quot;tomato4&quot;, cex = 0.7) 11.9 Контрольные вопросы и упражнения 11.9.1 Вопросы 11.9.2 Упражнения Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "]
=======
["thematic-mapping-new.html", "Глава 10 Тематические карты в R Предварительные условия 10.1 Введение 10.2 Способы изображения 10.3 Цветовые шкалы 10.4 Классификация 10.5 Компоновка 10.6 Фасетные карты 10.7 Анимированные карты 10.8 Анаморфозы 10.9 Интерактивные карты 10.10 Контрольные вопросы и упражнения", " Глава 10 Тематические карты в R Предварительные условия Для выполнения кода данной лекции вам понадобятся следующие пакеты: library(sf) library(tmap) library(readxl) library(raster) library(mapview) library(classInt) library(gapminder) library(tidyverse) library(googlesheets) library(rnaturalearth) 10.1 Введение Тематические карты представляют собой важный инструмент географических исследований. Таблицы и графики не дают полного представления о пространственном распределении изучаемого явления. Это знание способна дать исследователю карта. Разнообразие типов и видов карт достаточно велико. Комплексные картографические произведения, содержащие многослойный набор объектов, создаются, как правило, средствами геоинформационных пакетов. Такие карты требуют тщательной и кропотливой работы с легендой, устранения графических конфликтов между знаками, многократного редактирования входных данных, условий, фильтров и способов изображения в попытке достичь эстетичного и вместе с тем информативного результата. В то же время, гораздо большее количество создаваемых в повседневной практике карт носят простой аналитический характер. Такие карты показывают одно, максимум два явления, и могут иллюстрировать входные данные, результаты промежуточных или итоговых расчетов. Создание именно таких карт целесообразно автоматизировать средствами программирования. В этом разделе мы познакомимся с созданием тематических карт средствами пакета tmap. В качестве источника открытых данных мы будем использовать Natural Earth и WorldClim. 10.1.1 Данные Natural Earth Natural Earth — это открытые мелкомасштабные картографические данные высокого качества. Данные доступны для трех масштабов: 1:10М, 1:50М и 1:110М. Для доступа к этимм данным из среды R без загрущзки исходных файлов можно использоват пакет rnaturalearth. Пакет позволяет выгружать данные из внешнего репозитория, а также содержит три предзакачанных слоя: ne_countries() границы стран ne_states() границы единиц АТД 1 порядка ne_coastline() береговая линия Для загрузки других слоев необходимо использовать функцию ne_download(), передав ей масштаб, название слоя и его категорию: countries = ne_countries() %&gt;% st_as_sf() coast = ne_coastline() %&gt;% st_as_sf() ocean = ne_download(scale = 110, type = &#39;ocean&#39;, category = &#39;physical&#39;) %&gt;% st_as_sf() ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/private/var/folders/h1/_pw8qgdd6y7gy251_ttnq8240000gn/T/Rtmpm4j2JP&quot;, layer: &quot;ne_110m_ocean&quot; ## with 2 features ## It has 3 fields cities = ne_download(scale = 110, type = &#39;populated_places&#39;, category = &#39;cultural&#39;) %&gt;% st_as_sf() ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/private/var/folders/h1/_pw8qgdd6y7gy251_ttnq8240000gn/T/Rtmpm4j2JP&quot;, layer: &quot;ne_110m_populated_places&quot; ## with 243 features ## It has 119 fields ## Integer64 fields read as strings: wof_id ne_id rivers = ne_download(scale = 110, type = &#39;rivers_lake_centerlines&#39;, category = &#39;physical&#39;) %&gt;% st_as_sf() ## OGR data source with driver: ESRI Shapefile ## Source: &quot;/private/var/folders/h1/_pw8qgdd6y7gy251_ttnq8240000gn/T/Rtmpm4j2JP&quot;, layer: &quot;ne_110m_rivers_lake_centerlines&quot; ## with 13 features ## It has 31 fields ## Integer64 fields read as strings: scalerank ne_id Познакомимся с загруженными данными: plot(ocean %&gt;% st_geometry(), col = &#39;lightblue&#39;) plot(countries, col = &#39;white&#39;, border = &#39;grey&#39;, add = TRUE) plot(coast, add = TRUE, col = &#39;steelblue&#39;) plot(rivers, add = TRUE, col = &#39;steelblue&#39;) plot(cities, add = TRUE, col = &#39;black&#39;, pch = 19, cex = 0.2) Перед построением карт мира данные целесообразно спроецировать. Чтобы не трансформировать каждый слой отдельно, можно объединить слои в список и воспользоваться функционалом lapply для множественного трансформирования. Для создания списка воспользуемся функцией lst() из пакета tibble, которая присваивает компонентам списка имена, соответствующие названиям входных переменных (чтобы не писать ocean = ocean): lyr = tibble::lst(ocean, coast, countries, rivers, cities) lyrp = lapply(lyr, st_transform, crs = &quot;+proj=eck3&quot;) # Псевдоцилиндрическая проекция Эккерта g = st_graticule(lyrp$ocean) %&gt;% st_geometry() # построим координатную сетку plot(lyrp$ocean %&gt;% st_geometry(), col = &#39;lightblue&#39;, border = NA) plot(lyrp$countries, col = &#39;white&#39;, border = &#39;grey&#39;, lwd = 0.5, add = TRUE) plot(lyrp$coast, add = TRUE, lwd = 0.5, col = &#39;steelblue&#39;) plot(lyrp$rivers, add = TRUE, lwd = 0.5, col = &#39;steelblue&#39;) plot(lyrp$cities, add = TRUE, col = &#39;black&#39;, pch = 19, cex = 0.1) plot(g, lty = 3, lwd = 0.5, add = TRUE) 10.1.2 Данные WorldClim WorldClim — это открытые сеточные наборы климатических характеристик с пространственным разрешением от \\(30&#39;&#39;\\) (около 1 км) до \\(10&#39;\\) (около 20 км). Данные можно выгрузить в виде файлов GeoTiff, однако эту операцию можно сделать и программным путем через пакет raster — используя функцию getData(). Выполним загрузку 10-минутного растра с суммарным количеством осадков за год: prec = getData(&quot;worldclim&quot;, var = &quot;prec&quot;, res = 10) plot(prec, nc = 2) # это 12-канальный растр Использовать программную загрузку целесообразно для небольших наборов данных. Если счет пошел на десятки мегабайт и выше, следует все-таки выкачать данные в виде файла и работать с ним. Выполним трансформирование данных в проекцию Миллера. Для того чтобы карта не обрезалась по охвату растра (он не включает данные на Антарктиду), необходимо расширить его охват на весь земной шар. Для этого используем функцию extend() из пакета raster: precm = prec %&gt;% extend(extent(-180, 180, -90, 90)) %&gt;% projectRaster(crs = &quot;+proj=mill&quot;) lyrm = lapply(lyr, st_transform, crs = &quot;+proj=mill&quot;) # Цилиндрическая проекция Миллера Визуализируем полученные данные на карте: ramp = colorRampPalette(c(&quot;white&quot;, &quot;violetred&quot;)) # Визуализируем данные на январь: plot(precm, 1, col = ramp(10), colNA = &#39;grey&#39;, main = &#39;Количество осадков в январе, мм&#39;, box = FALSE, axes = FALSE) plot(lyrm$ocean, border = &#39;steelblue&#39;, col = &#39;lightblue&#39;, add = TRUE) 10.2 Способы изображения В этом разделе изложение сосредоточено на параметрах способов изображения. Приведение легенд и компоновки карты в аккуратный вид рассматривается далее в разделе Компоновка. Пакет tmap предоставляет простой в использовании и достаточно мощный механизм формирования тематических карт. Шаблон построения карты в этом пакете напоминает ggplot и выглядит следующим образом: tm_shape(&lt;DATA&gt;) + tm_&lt;METHOD&gt;(&lt;PARAMETERS&gt;) где: DATA - объект пространственного типа (sf, sp, stars или raster) METHOD - метод визуализации этого объекта (спопоб изображения) PARAMETERS - параметры метода 10.2.1 Векторные данные Для реализации качественного и количественного фона, а также картограмм используется метод tm_polygons(). Он автоматически определяет тип переменной и строит соответствующую шкалу: tm_shape(lyrp$countries) + tm_polygons(&#39;economy&#39;) + # качественная переменная tm_shape(lyrp$ocean)+ tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) Количественный фон или картограммы получаются при картографировании числового показателя применением той же функции tm_polygons(): (&#39;1H3nzTwbn8z4lJ5gJ_WfDgCeGEXK3PVGcNjQ_U5og8eo&#39; %&gt;% # продолжительность жизни gs_key(lookup = FALSE) %&gt;% # не используем авторизацию gs_read(ws = 1) %&gt;% rename(name = 1) %&gt;% gather(year, lifexp, -name) %&gt;% filter(year == 2016) %&gt;% left_join(read_excel(&#39;gapminder.xlsx&#39;, 2)) %&gt;% mutate(geo = stringr::str_to_upper(geo)) -&gt; lifedf) # выгружаем данные по ВВП на душу населения и сохраняем в переменную lifedf ## # A tibble: 260 x 13 ## name year lifexp geo four_regions eight_regions six_regions ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Abkh… 2016 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 2 Afgh… 2016 52.7 AFG asia asia_west south_asia ## 3 Akro… 2016 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 4 Alba… 2016 78.1 ALB europe europe_east europe_cen… ## 5 Alge… 2016 76.5 DZA africa africa_north middle_eas… ## 6 Amer… 2016 73 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 7 Ando… 2016 84.8 AND europe europe_west europe_cen… ## 8 Ango… 2016 60 AGO africa africa_sub_s… sub_sahara… ## 9 Angu… 2016 NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; ## 10 Anti… 2016 76.5 ATG americas america_north america ## # ... with 250 more rows, and 6 more variables: members_oecd_g77 &lt;chr&gt;, ## # Latitude &lt;dbl&gt;, Longitude &lt;dbl&gt;, `UN member since` &lt;dttm&gt;, `World bank ## # region` &lt;chr&gt;, `World bank income group 2017` &lt;chr&gt; coun = lyrp$countries %&gt;% left_join(lifedf, by = c(&#39;adm0_a3&#39; = &#39;geo&#39;)) tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, border.col = &#39;gray20&#39;) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) Для реализации способа картодиаграмм используется геометрия tm_bubbles(). Чтобы оставить отображение границ полигонов, нам необходимо к одной геометрии применить несколько способов изображения: tm_shape(coun) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_bubbles(&#39;gdp_md_est&#39;, scale = 3, col = &#39;red&#39;, alpha = 0.5) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Аналогичным образом реализуется значковый способ применительно к объектам, локализованным по точкам. Картографируем численность населения по крупнейшим городам: tm_shape(lyrp$countries) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_shape(lyrp$cities) + tm_bubbles(&#39;POP2015&#39;, col = &#39;olivedrab&#39;, alpha = 0.8) Надписи объектов на карте размещаются с помощью функции tm_text. Данная функция содержит весьма полезные параметры remove.overlap и auto.placement, которые позволяют убрать перекрывающиеся подписи и автоматически разместить из вокруг точек так, чтобы уменьшить перекрытия с самими знаками и другими подписями. Дополним предыдущую карту названиями городов: tm_shape(lyrp$countries) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_shape(lyrp$cities) + tm_bubbles(&#39;POP2015&#39;, col = &#39;olivedrab&#39;, alpha = 0.8) + tm_text(&#39;name_ru&#39;, size = 0.5, remove.overlap = TRUE, auto.placement = TRUE) 10.2.2 Растровые данные При отображении растровых данных используется способ отображения tm_raster(). Параметр breaks определяет границы интервалов, для которых будут использованы цвета, взятые из параметра palette: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = c(10, 50, 100, 200, 500, 1000), palette = ramp(5)) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.3 Цветовые шкалы Для изменения цветовой шкалы при определении способа избражения вы можете определить параметр palette. Пакет tmap позволяет работать с цветовыми палитрами Color Brewer или задавать цвета вручную. Очень удобным инструментом подбора шкалы является функция palette_explorer() из пакета tmaptools. При вызове функции открывается интерактивное приложение, позволяющее менять настройки цветовых палитр: tmaptools::palette_explorer() Приложение Palette Explorer из пакета tmaptools Данных палитр хватат для решения большинства задач по картографической визуализации. Применим категориальную палитру Dark2: tm_shape(lyrp$countries) + tm_polygons(&#39;economy&#39;, palette = &#39;Dark2&#39;) + # качественная переменная tm_shape(lyrp$ocean)+ tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) Для количественного показателя (количество осадков) применим палитру PuBuGn: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = c(10, 50, 100, 200, 500, 1000), palette = &#39;PuBuGn&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Вы всегда можете, конечно, определить цвета вручную. В этом случае их количество должно совпадать с количеством интервалов классификации: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = c(10, 50, 100, 200, 500, 1000), palette = c(&#39;white&#39;, &#39;gray80&#39;, &#39;gray60&#39;, &#39;gray40&#39;, &#39;gray20&#39;)) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.4 Классификация 10.4.1 Методы классификации Классификация данных — важнейший этап картографирования, который во многом определяет, как данные будут представлены на карте и какие географические выводы читатель сделает на ее основе. Существует множество методов классификации числовых рядов. Классифицировать данные автоматически можно с помощью функции classIntervals() из пакета classInt. Наберите в консоли ?classInt чтобы прочитать справку о методах классификации. Посмотрим несколько методов классификации. Первый параметр функции classInt — это числовой ряд. Число классов следует передать в параметр n =, метод классификации указывается в параметре style =. Для начала попробуем метод равных интервалов, который просто делит размах вариации (диапазон от минимума до максимум) на \\(n\\) равных интервалов. Функция plot() применительно к созданной классификации рисует замечательный график, на котором показаны границы классов и эмпирическая функция распределения показателя. В параметр pal можно передать цветовую палитру: # Запишем число классов в переменную nclasses = 5 intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;equal&quot;) # извлечь полученные границы можно через $brks intervals$brks ## [1] 48.860 55.748 62.636 69.524 76.412 83.300 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Равные интервалы MIN/MAX&quot;) Cозданные интервалы хоть и равны, но не аккуратны. Зато метод классификации &quot;pretty&quot; создает также равные интервалы, но может слегка расширить диапазон или добавить 1 класс, чтобы получить границы интервалов, округленные до целых чисел: intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;pretty&quot;) intervals$brks ## [1] 45 50 55 60 65 70 75 80 85 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Округленные равные интервалы&quot;) Квантили — равноколичественные интервалы. В каждом классе содержится одинаковое число объектов: intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;quantile&quot;) intervals$brks ## [1] 48.860 64.488 71.300 75.440 79.360 83.300 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Квантили (равноколичественные)&quot;) Метод “естественных интервалов”, или метод Фишера-Дженкса позволяет найти классы, максимально однородные внутри и при этом максимально отличающиеся друг от друга: intervals = classIntervals(coun$lifexp, n = nclasses, style = &quot;jenks&quot;) intervals$brks ## [1] 48.86 55.90 63.70 70.40 77.10 83.30 plot(intervals, pal = ramp(nclasses), cex=0.5, main = &quot;Естественные интервалы&quot;) 10.4.2 Применение на картах Чтобы использовать заранее вычисленные интервалы классификации, их необходимо подать в параметр breaks при построении карты: brks = classIntervals(coun$lifexp, n = 4, style = &quot;pretty&quot;)$brks tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, border.col = &#39;gray20&#39;, palette = &#39;YlGn&#39;, breaks = brks) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) Аналогичным путем работают шкалы для растровых данных: tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = classIntervals(values(precm), n = 5, style = &quot;quantile&quot;)$brks, palette = &#39;PuBuGn&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) Учтите, что метод естественных интервалов — ресурсоемкий в вычислительном плане. Поэтому если вы хотите с его помощью классифицировать растровые данные, целесообразно сделать выборку не более чем из нескольких тысяч пикселов. Иначе придется долго ждать. Для классификации естественными интервалами сделаем выборку в 2 000 значений с растра c помощью функции sampleRandom() из пакета raster: smpl = sampleRandom(precm$prec1, size = 2000) tm_shape(precm) + tm_raster(&#39;prec1&#39;, breaks = classIntervals(smpl, n = 5, style = &quot;jenks&quot;)$brks, palette = &#39;PuBuGn&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.4.3 Классификация при отображении Пакет tmap позволяет выполнять классификацию данных непосредственно при отображении. Это бывает удобно, когда одну и ту же классификацию не надо использовать несолько раз, и когда нет необходимости делать выборку значений (как в случае метода естественных интервалов). Для этого функции способов изображения предлагают несколько параметров: n — количество классов style — метод классификации (так же как и в classIntervals()) breaks — значения границ интервалов (необходимы, если style == fixed) interval.closure — замыкание интервала (по умолчанию стоит left, что означает, что в интервал включается нижняя граница, за исключением последнего интервала, включающего и нижнюю и верхнюю границу) midpoint — нейтральное значение, которое используется для сопоставления с центральным цветом в расходящихся цветовых палитрах Построим карту продолжительности жизни, используя классификацию при отображении: tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, palette = &#39;YlGn&#39;, n = 5, style = &#39;fisher&#39;, border.col = &#39;gray20&#39;) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) Установка средней точки при классификации оказывается очень полезной в тех случаях, когда данные являются биполярными. Покажем это на примерее данных WorldClim по температуре: temp = getData(&quot;worldclim&quot;, var = &quot;tmean&quot;, res = 10) %&gt;% extend(extent(-180, 180, -90, 90)) %&gt;% projectRaster(crs = &quot;+proj=mill&quot;) / 10 # не забываем поделить результат на 10, # так как данные хранятся в виде цедых чисел! Визуализируем данные по температуре, используя классическую красно-бело-синюю палитру RdBu и нейтральную точку 0 градусов по Цельсию. По умолчанию в данной палитре красный цвет соответствует малым значениям. пакет tmap позволяет инвертировать цвета палитры, добавив знак минус перед ее названием. Помимо этого, для размещения положительных значений наверху выполним обратную сортировку элементов легенды, используя параметр legend.reverse = TRUE: tm_shape(temp) + tm_raster(&#39;tmean1&#39;, n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.4.4 Пропущенные данные Весьма важно отметить на карте области, для которых данные отсутствуют. Вы могли обратить внимание, что для способов изображения, применимых к векторным данным, tmap автоматически добавляет класс легенды, который отвечает за пропуски. Для растров, однако, он это не делает. Чтобы принудительно вывести в легенду и на карту символ, отвечающий за пропущенные значения, необходимо определить параметр colorNA. Обычно, в зависимости от цветовой палитры легенды, для этого используют серый или белый цвет: tm_shape(temp) + tm_raster(&#39;tmean1&#39;, colorNA = &#39;grey&#39;, # определяем цвет для пропущенных значений n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) 10.5 Компоновка Пакет tmap предоставляет широкий набор настроек компоновки картографического изображения, который включает настройку легенды, заголовка карты и ряда других важных параметров. Большинство настроек компоновки осуществляется через функцию tm_layout(), однако часть из них, специфичная для конкретного слоя, определяется непосредственно при настройке способа изображения. В примере ниже показано, как: добавить заголовок карты (main.title), разместить олегенду в нижнем левом углу (legend.position = c('left', 'bottom')) поместить ее легенду в полупрозрачный прямоугольник (параметры legend&lt;...&gt;), убрать заголовок легенды (title), заменить стандартный шрифт на OpenSans (fontfamily): tm_shape(lyrp$countries) + tm_polygons(&#39;economy&#39;, title = &#39;&#39;) + # убираем заголовок легенды tm_shape(lyrp$ocean)+ tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), fontfamily = &#39;OpenSans&#39;, # шрифт main.title.size = 1.2, # масштаб шрифта в заголовке main.title = &#39;Тип экономики&#39;, # заголовок legend.frame = TRUE, # рамка вокруг легенды legend.frame.lwd = 0.2, # толщина рамки вокруг легенды legend.bg.alpha = 0.8, # прозрачность фона в легенде legend.bg.color = &#39;white&#39;) # цвет фона легенды Для того чтобы определить заголовок легенды размера значка или диаграммы, необходимо задать параметр title.size. Помимо этого, легенду можно пристыковать непосредственно к рамке карты, если задать значения параметра legend.position в верхнем регистре: tm_shape(coun) + tm_fill(col = &#39;white&#39;) + tm_borders(col = &#39;grey&#39;) + tm_bubbles(&#39;gdp_md_est&#39;, scale = 2.5, col = &#39;red&#39;, alpha = 0.5, title.size = &#39;$ млн&#39;) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;lightblue&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;LEFT&#39;, &#39;BOTTOM&#39;), # верхний регистр — легенда встык fontfamily = &#39;OpenSans&#39;, # шрифт main.title.size = 1.2, # масштаб шрифта в заголовке main.title = &#39;Валовый внутренний продукт стран мира&#39;, # заголовок frame.lwd = 2, legend.frame = TRUE, # рамка вокруг легенды legend.frame.lwd = 0.5, # толщина рамки вокруг легенды legend.bg.color = &#39;white&#39;) # цвет фона легенды По умолчанию tmap размещает легенду внутри фрейма картографического изображения. Однако ее можно вынести и наружу, используя параметр legend.outside функции tm_layout(). В примере ниже показано также, как можно задать текст легенды для отсутствующих данных (textNA), отформатировать разделитель в легенде с интервалами значений (legend.format), убрать рамку карты (frame), сдвинуть заголовок вдоль строки, выровняв его с центром карты (main.title.position): tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, border.col = &#39;gray20&#39;, palette = &#39;YlGn&#39;, n = 4, style = &#39;jenks&#39;, title = &#39;Лет&#39;, colorNA = &#39;lightgray&#39;, textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;)) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) + tm_layout(frame = FALSE, main.title.position = 0.15, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Продолжительность жизни&#39;, legend.bg.color = &#39;white&#39;) Для отображения координатной сетки вы можете использовать функцию tm_grid(). По умолчанию она строит координатную сетку в единицах измерения проекции. Однако если требуется градусная сетка, то ее можно определить, используя параметр projection = &quot;longlat&quot;: tm_shape(temp) + tm_raster(&#39;tmean1&#39;, title = &#39;°C&#39;, colorNA = &#39;grey&#39;, # определяем цвет для пропущенных значений textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;), n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;left&#39;, &#39;bottom&#39;), fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Средняя температура января&#39;, legend.frame = TRUE, legend.frame.lwd = 0.2, legend.bg.alpha = 0.5, legend.bg.color = &#39;white&#39;) + tm_grid(x = seq(-180, 180, by = 30), y = seq(-90, 90, by = 30), lwd = 0.2, col = &quot;black&quot;, projection = &quot;longlat&quot;, labels.inside.frame = FALSE) Если вам необходимо обеспечить значки градуса, вы можете сделать это, используя параметр labels.format, определив в нем анонимную функцию, добавляющую значок градуса в переданный ей вектор подписей. Помимо этого, вам может понадобиться увеличить поля вокруг карты, чтобы освободить пространство для размещения меток (на предыдущей карте они не влезли). Это делается через параметр outer.margins, который ожидает получить вектор из четырех значений (по умолчанию все они равны 0.02, т.е. 2% от размера окна). tm_shape(temp) + tm_raster(&#39;tmean1&#39;, title = &#39;°C&#39;, colorNA = &#39;grey&#39;, # определяем цвет для пропущенных значений textNA = &#39;Нет данных&#39;, legend.format = list(text.separator = &#39;—&#39;), n = 11, midpoint = 0, style = &#39;pretty&#39;, legend.reverse = TRUE, palette = &#39;-RdBu&#39;) + tm_shape(lyrm$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue&#39;) + tm_layout(legend.position = c(&#39;LEFT&#39;, &#39;BOTTOM&#39;), fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Средняя температура января&#39;, legend.frame = TRUE, legend.frame.lwd = 0.2, legend.bg.alpha = 0.8, legend.bg.color = &#39;white&#39;, outer.margins = c(0.05, 0.02, 0.02, 0.02), inner.margins = c(0, 0, 0, 0)) + tm_grid(x = seq(-180, 180, by = 30), y = seq(-90, 90, by = 30), lwd = 0.2, col = &quot;black&quot;, projection = &quot;longlat&quot;, labels.inside.frame = FALSE, labels.format = list(fun = function(X) paste0(X, &#39;°&#39;))) Подписи сетки координат можно добавить и для более сложных проекций, однако располагаться они будут по-прежнему вдоль осей X и Y. В примере ниже также показано как можно увеличить расстояние между заголовком и картой, определив более крупный отступ от верхней стороны в параметре inner.margins: tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, palette = &#39;YlGn&#39;, n = 4, style = &#39;jenks&#39;, border.col = &#39;gray20&#39;, title = &#39;Лет&#39;, colorNA = &#39;lightgray&#39;, textNA = &#39;Нет данных&#39;, legend.reverse = TRUE, legend.format = list(text.separator = &#39;—&#39;)) + # количественная переменная tm_shape(lyrp$ocean) + tm_fill(col = &#39;azure&#39;) + tm_borders(col = &#39;steelblue4&#39;) + tm_layout(frame = FALSE, main.title.position = 0.15, legend.outside = TRUE, legend.outside.position = &#39;right&#39;, fontfamily = &#39;OpenSans&#39;, main.title.size = 1.2, main.title = &#39;Продолжительность жизни&#39;, legend.bg.color = &#39;white&#39;, outer.margins = c(0.02, 0.05, 0.02, 0.02), inner.margins = c(0.02, 0.02, 0.07, 0.02)) + tm_grid(x = seq(-180, 180, by = 60), y = seq(-90, 90, by = 30), lwd = 0.2, col = &quot;black&quot;, projection = &quot;longlat&quot;, labels.inside.frame = FALSE, labels.format = list(fun = function(X) paste0(X, &#39;°&#39;))) 10.6 Фасетные карты 10.7 Анимированные карты 10.8 Анаморфозы 10.9 Интерактивные карты Любую карту tmap можно превести в интерактивный режим с помощью функции tmap_mode() с параметром 'view': tmap_mode(&#39;view&#39;) tm_shape(coun) + tm_polygons(&#39;lifexp&#39;) # количественная переменная Чтобы добавить карту-подложку, необходимо предварительно вызвать функцию tm_basemap(), передав ей название картографического сервиса: tm_basemap(&quot;OpenStreetMap&quot;) + tm_shape(coun) + tm_polygons(&#39;lifexp&#39;, alpha = 0.5) # количественная переменная 10.10 Контрольные вопросы и упражнения 10.10.1 Вопросы 10.10.2 Упражнения Используя возможности пакетов rnaturalearth и tmap, создпайте карту мира, в которой страны раскрашены в соответствии с континентом (переменная continent). Визуализируйте ее в статичном и интерактивном режиме. Выполните выборку стран на Европейский континент. Трансформируйте данные о странах в коническую равнопромежуточную проекцию. Визуализируйте численность населения по странам (переменная pop_est) способом картодиаграмм. Добавьте на карту реки, озера и города, используя возможности ne_download(). Самсонов Т.Е. Визуализация и анализ географических данных на языке R. М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911 "]
>>>>>>> parent of 918f318... add map series
]
