# Работа с таблицами {#tables}

[Программный код главы](https://github.com/tsamsonov/r-geo-course/blob/master/code/04-TablesDataReading.R)

__Необходимые пакеты:__ `openxlsx, dplyr`

Таблица представляет собой один из способов структурирования данных. Большинство научных данных представляется именно в виде таблиц. В настоящем модуле рассмотрены базовые процедуры обработки таблиц, такие как чтение, сортировка, фильтрация, отбор столбцов (переменных), добавление и вычисление новых строк и столбцов, поиск и исправление ошибок в данных, запись таблиц в файл. Показано, как одни и те же процедуры могут быть реализованы стандартными средствами __R__ и с помощью пакета `dplyr`.

Напомним, что для представления таблиц в __R__ используются фреймы данных. В рамках данной главы мы будем использовать оба понятия как взаимозаменяемые, предполагая, что речь идет о таблице, представленной в виде фрейма данных.



## Чтение таблиц {#reading_tables}

Существует множество файловых форматов представления табличных данных. Мы рассмотрим одни из наиболее распространенных --- __CSV__ и __Microsoft Excel__.

### Таблицы CSV {#reading_csv}

__CSV (Comma-separated value)__ --- общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу:

1. Каждая строка в файле соответствует строке в таблице
2. Ячейки отделяются друг от друга символом-разделителем.
3. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов.

Стандартным разделителем ячеек является запятая (`,`), а десятичным разделителем --- точка (`.`). Однако это не является строгим правилом.

Например, вот так выглядит таблица в формате CSV, с которой мы дальше будем работать:
```
Год;Всего;Балтийское;Черное;Азовское;Каспийское;Карское;Белое;Прочие
1993;27,2;2,5;0,4;4,3;12,1;5,3;1,0;1,6
1994;24,6;2,3;0,4;3,2;11,0;5,0;0,9;1,8
1995;24,5;2,3;0,4;3,5;10,4;5,2;0,9;1,8
1996;22,4;2,2;0,3;3,1;9,8;4,7;0,8;1,5
1997;23,0;2,2;0,3;3,8;9,8;4,4;0,8;1,7
```

Видно, что первая строка в файле занята заголовками столбцов. Формат CSV этот момент не обговаривает, поэтому при чтении таблицы нужно явным образом указывать, что данные начинаются со второй строки, а первую строку следует интерепретировать как заголовочную.

Также следует отметить, что в данном файле в качестве символа-разделителя ячеек используется точка с запятой (`;`), поскольку в русской локали запятая (`,`) зарезервирована под десятичный разделитель. Разделитель ячеек и десятичный разделитель также должны быть указаны при открытии файла, если они не соответствуют стандартным.

Таблицы в формате __CSV__ (Comma-Separated Values) можно прочесть с помощью универсальной функции `read.table()`. Ее основные параметры следующие:

- `file` --- название файла
- `sep` --- разделитель ячеек
- `dec` --- десятичный разделитель
- `header` --- содержится ли в первой строке заголовок
— `encoding` --- кодировка символов, в которой сохранен файл (чаще всего `UTF-8` или `CP1251`)

> __Стандартной кодировкой для представления текста__ в UNIX-подобных системах (_Ubuntu_, _macOS_ и т.д.) является __UTF-8 (Unicode)__, в русскоязычных версиях _Windows_ --- __CP1251 (Windows-1251)__. Текстовый файл __CSV__, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в __R__ вы видите вместо текста нечитаемые символы --- _кракозябры_ --- то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Попробуйте поменять `UTF-8` на `CP1251` или наоборот. Если вы не знаете, что такое кодировка и Юникод, то вам [сюда](https://ru.wikipedia.org/wiki/Набор_символов).

Прочтем таблицу с данными Росстата по объему сброса сточных вод в бассейны некоторых морей России (в млн. м$^3$):

```r
tab <- read.table("oxr_vod.csv",
                  sep = ';',
                  dec = ',',
                  header = TRUE,
                  encoding = 'UTF-8')
str(tab) # Посмотрим на структуру таблицы
## 'data.frame':	22 obs. of  9 variables:
##  $ Год       : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Всего     : num  27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ...
##  $ Балтийское: num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Черное    : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Азовское  : num  4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ...
##  $ Каспийское: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Карское   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ Белое     : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
##  $ Прочие    : num  1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ...
```

Существуют также специальные функции для чтения таблиц __CSV__: `read.csv()` и `read.csv2()`. По сути они являются "обертками" (_wrappers_) функции `read.table()` и выполняют ее вызов с автоматической подстановкой параметров `sep`, `dec` и `header`. Обе функции по умолчанию предполагают, что в файле имеется заголовок. `read.csv()` удобна для чтения таблиц с десятичной точкой и запятой-разделителем, а `read.csv2()` --- для таблиц с десятичной запятой и точкой-с-запятой в качестве разделителя.

Используем для чтения `read.csv2()`:

```r
tab <- read.csv2("oxr_vod.csv", encoding = 'UTF-8')
str(tab) # Посмотрим на структуру таблицы
## 'data.frame':	22 obs. of  9 variables:
##  $ Год       : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Всего     : num  27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ...
##  $ Балтийское: num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Черное    : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Азовское  : num  4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ...
##  $ Каспийское: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Карское   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ Белое     : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
##  $ Прочие    : num  1.6 1.8 1.8 1.5 1.7 1.8 1.7 1.5 1.5 1.5 ...
```

Данная таблица не отличается от предыдущей, но ее чтение с помощью функции `read.csv2()` более компактно.

### Таблицы Microsoft Excel {#excel_reading}

Чтение таблиц __Microsoft Excel__ не входит в возможности стандартной библиотеки R. В то же время, для этих целей существует ряд пакетов, таких как `xlsx`, `readxl` и `openxlsx`. Мы будем пользоваться пакетом `openxlsx` [@R-openxlsx]. Подключим его:

```r
library(openxlsx)
```

Для чтения таблицы воспользуемся функцией `read.xlsx()` из этого пакета. В качестве обязательных параметров она принимает следующие аргументы:

- `xlsxFile` — название файла
- `sheet` — номер листа

Откроем таблицу с данными Росстата по сбросу загрязненных сточных вод в поверхностные водные объекты (млн м$^3$).

```r
sewage <- read.xlsx("sewage.xlsx", 1) # Читаем таблицу из первого листа
str(sewage) # Посмотрим на структуру таблицы
## 'data.frame':	97 obs. of  6 variables:
##  $ X1  : chr  "Российская Федерация" "Центральный федеральный округ " "Белгородская область" "Брянская область" ...
##  $ 2005: num  17727 4341 11 89 155 ...
##  $ 2010: num  16516 3761 77 78 129 ...
##  $ 2011: num  15966 3613 72 75 126 ...
##  $ 2012: num  15678 3651 71 71 124 ...
##  $ 2013: num  15189 3570 71 68 120 ...
```

## Просмотр таблицы {#view_table}

Для просмотра фрейма данных в консоли RStudio вы можете использовать несколько опций. Пусть наш фрейм данных называется `tab`. Тогда:

1. `print(tab)` --- выводит фрейм в консоль целиком (можно написать просто `tab` в консоли).
2. `head(tab, n)` --- отбирает первые $n$ строк фрейма 
3. `tail(tab, n)` --- отбирает последние $n$ строк фрейма

По умолчанию для функций `head()` и `tail()` $n=6$. Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли `head(tab)` или `tail(tab)`, то для выбранных строк будет вызвана функция `print()`, аналогично выводу всего фрейма:

```r
print(tab)
##     Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие
## 1  1993  27.2        2.5    0.4      4.3       12.1     5.3   1.0    1.6
## 2  1994  24.6        2.3    0.4      3.2       11.0     5.0   0.9    1.8
## 3  1995  24.5        2.3    0.4      3.5       10.4     5.2   0.9    1.8
## 4  1996  22.4        2.2    0.3      3.1        9.8     4.7   0.8    1.5
## 5  1997  23.0        2.2    0.3      3.8        9.8     4.4   0.8    1.7
## 6  1998  22.0        2.2    0.3      3.2        9.5     4.2   0.8    1.8
## 7  1999  20.7        2.2    0.3      2.5        9.1     4.1   0.8    1.7
## 8  2000  20.3        2.2    0.3      2.0        9.2     4.2   0.9    1.5
## 9  2001  19.8        2.1    0.3      1.9        8.9     4.2   0.9    1.5
## 10 2002  19.8        2.0    0.2      2.0        9.2     4.1   0.8    1.5
## 11 2003  19.0        2.0    0.2      2.1        8.4     4.0   0.8    1.5
## 12 2004  18.5        2.0    0.2      2.1        8.3     3.8   0.8    1.3
## 13 2005  17.7        2.0    0.2      1.6        8.0     3.8   0.8    1.3
## 14 2006  17.5        1.9    0.2      1.7        7.8     3.8   0.8    1.3
## 15 2007  17.2        1.9    0.2      1.7        7.4     3.8   0.8    1.4
## 16 2008  17.1        1.9    0.2      1.6        7.5     3.9   0.8    1.2
## 17 2009  15.9        1.8    0.2      1.5        6.8     3.5   0.7    1.4
## 18 2010  16.5        2.0    0.2      1.6        7.3     3.3   0.7    1.4
## 19 2011  16.0        1.9    0.2      1.6        7.1     3.2   0.7    1.3
## 20 2012  15.7        1.8    0.2      1.6        7.0     3.0   0.7    1.4
## 21 2013  15.2        1.8    0.2      1.6        6.9     3.0   0.6    1.1
## 22 2014  14.8        1.7    0.2      1.5        6.4     3.2   0.6    1.2
head(tab)
##    Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие
## 1 1993  27.2        2.5    0.4      4.3       12.1     5.3   1.0    1.6
## 2 1994  24.6        2.3    0.4      3.2       11.0     5.0   0.9    1.8
## 3 1995  24.5        2.3    0.4      3.5       10.4     5.2   0.9    1.8
## 4 1996  22.4        2.2    0.3      3.1        9.8     4.7   0.8    1.5
## 5 1997  23.0        2.2    0.3      3.8        9.8     4.4   0.8    1.7
## 6 1998  22.0        2.2    0.3      3.2        9.5     4.2   0.8    1.8
tail(tab)
##     Год Всего Балтийское Черное Азовское Каспийское Карское Белое Прочие
## 17 2009  15.9        1.8    0.2      1.5        6.8     3.5   0.7    1.4
## 18 2010  16.5        2.0    0.2      1.6        7.3     3.3   0.7    1.4
## 19 2011  16.0        1.9    0.2      1.6        7.1     3.2   0.7    1.3
## 20 2012  15.7        1.8    0.2      1.6        7.0     3.0   0.7    1.4
## 21 2013  15.2        1.8    0.2      1.6        6.9     3.0   0.6    1.1
## 22 2014  14.8        1.7    0.2      1.5        6.4     3.2   0.6    1.2
```

`RStudio`, разумеется, имеет "человеческий" интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать. Чтобы его активировать, надо вызвать функцию `View()`:

```r
View(tab)
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-6-1.png)<!-- -->

Поскольку функции `head()` и `tail()` возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции `View()`:


```r
View(head(sewage, 3))
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-8-1.png)<!-- -->

> __Как правило, не следует оставлять вызовы функции `View()` в тексте законченной программы.__ Это приведет к тому, что при запуске будут открываться новые вкладки с просмотром таблиц, что может раздражать пользователя (в том числе и вас самих). Используйте `View()` для вывода окончательного результата в конце программы или при отладке программы. Все вызовы `View()` в программе  можно легко закомментировать или раскомментировать, выполнив поиск с заменой `'View('` на `'# View('` и наоборот.

## Работа со столбцами {#working_with_columns}

### Названия столбцов {#colnames}

Для просмотра и изменения названий столбцов фрейма данных следует использовать функцию `colnames()`:

```r
# Просмотрим текущие названия
colnames(sewage)
## [1] "X1"   "2005" "2010" "2011" "2012" "2013"
colnames(tab)
## [1] "Год"        "Всего"      "Балтийское" "Черное"     "Азовское"  
## [6] "Каспийское" "Карское"    "Белое"      "Прочие"

# Заменим их на новые
colnames(sewage) <- c("Region", "Year05", "Year10", "Year11", "Year12", "Year13")
colnames(tab) <- c("Year", "Total", "Baltic", "Black", "Azov", "Caspian", "Kara", "White", "Other")

# Проверим результат
colnames(sewage)
## [1] "Region" "Year05" "Year10" "Year11" "Year12" "Year13"
colnames(tab)
## [1] "Year"    "Total"   "Baltic"  "Black"   "Azov"    "Caspian" "Kara"   
## [8] "White"   "Other"
```

### Обращение к столбцам {#col_calling}

К столбцу можно обращаться по номеру и названию (с помощью оператора `$` или в кавычках внутри скобок). Если вы указываете в квадратных скобках номер без запятой, он трактуется именно как номер столбца, а не строки. Тип возвращаемого значения зависит от синтаксиса:

- обращение через `$` возвращает вектор;
- обращение в скобках с запятой к одному столбцу возвращает вектор;
- обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных;
- обращение в скобках без запятой возвращает фрейм данных.

Несколько примеров:

```r
a <- head(sewage)

# Один столбец - результат зависит от запятой
a$Year05      # столбец в виде вектора
## [1] 17727  4341    11    89   155   169
a[, "Year05"] # столбец в виде вектора
## [1] 17727  4341    11    89   155   169
a[, 2]        # столбец в виде вектора
## [1] 17727  4341    11    89   155   169

a["Year05"] # столбец в виде фрейма данных
##   Year05
## 1  17727
## 2   4341
## 3     11
## 4     89
## 5    155
## 6    169
a[2]        # столбец в виде фрейма данных
##   Year05
## 1  17727
## 2   4341
## 3     11
## 4     89
## 5    155
## 6    169

# Несколько столбцов - всегда фрейм данных
a[, c(1, 4)]              # столбцы в виде фрейма данных
##                           Region Year11
## 1           Российская Федерация  15966
## 2 Центральный федеральный округ    3613
## 3           Белгородская область     72
## 4               Брянская область     75
## 5           Владимирская область    126
## 6            Воронежская область    135
a[, c("Region", "Year11")]# столбцы в виде фрейма данных
##                           Region Year11
## 1           Российская Федерация  15966
## 2 Центральный федеральный округ    3613
## 3           Белгородская область     72
## 4               Брянская область     75
## 5           Владимирская область    126
## 6            Воронежская область    135
a[c("Region", "Year11")]  # столбцы в виде фрейма данных
##                           Region Year11
## 1           Российская Федерация  15966
## 2 Центральный федеральный округ    3613
## 3           Белгородская область     72
## 4               Брянская область     75
## 5           Владимирская область    126
## 6            Воронежская область    135
a[c(1, 4)]                # столбцы в виде фрейма данных
##                           Region Year11
## 1           Российская Федерация  15966
## 2 Центральный федеральный округ    3613
## 3           Белгородская область     72
## 4               Брянская область     75
## 5           Владимирская область    126
## 6            Воронежская область    135
```

Использование необходимой формы зависит от контекста и ваших целей.

### Выбор и исключение столбцов {#col_select}

Можно создать новую таблицу, выбрав необходимые столбцы, как это показано выше:

```r
# Создадим новый фрейм данных из трех необходимых столбцов:
caspian <- tab[c("Year", "Total", "Caspian")]
str(caspian)
## 'data.frame':	22 obs. of  3 variables:
##  $ Year   : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Total  : num  27.2 24.6 24.5 22.4 23 22 20.7 20.3 19.8 19.8 ...
##  $ Caspian: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
```

Иногда проще создать новый фрейм данных, исключив из оригинала ненужные столбцы. Исключение делается с помощью знака '-', который ставится перед номером столбца. Например, вот так можно исключить из таблицы `tab` столбцы `Total` (2-й) и `Other` (9-й):

```r
cleaned <- tab[c(-2, -9)]
str(cleaned)
## 'data.frame':	22 obs. of  7 variables:
##  $ Year   : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Baltic : num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Black  : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Azov   : num  4.3 3.2 3.5 3.1 3.8 3.2 2.5 2 1.9 2 ...
##  $ Caspian: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Kara   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ White  : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
```

Есть также способ _удалить столбец целиком_ (им пользуются довольно редко). Для этого необходимо записать в него значение `NULL`:

```r
cleaned$Azov <- NULL
str(cleaned)
## 'data.frame':	22 obs. of  6 variables:
##  $ Year   : int  1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 ...
##  $ Baltic : num  2.5 2.3 2.3 2.2 2.2 2.2 2.2 2.2 2.1 2 ...
##  $ Black  : num  0.4 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.3 0.2 ...
##  $ Caspian: num  12.1 11 10.4 9.8 9.8 9.5 9.1 9.2 8.9 9.2 ...
##  $ Kara   : num  5.3 5 5.2 4.7 4.4 4.2 4.1 4.2 4.2 4.1 ...
##  $ White  : num  1 0.9 0.9 0.8 0.8 0.8 0.8 0.9 0.9 0.8 ...
```

### Добавление и вычисление столбцов {col_add}

Существует простой способ создать новый столбец в таблице --- достаточно указать его название после значка `$`. Если среда R не обнаруживает столбец с таким названием, она его создаст:

```r
caspian$CaspianRatio <- round(caspian$Caspian / caspian$Total, 3)
```

```r
View(caspian)
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-16-1.png)<!-- -->

_Тем не менее, такой метод добавления столбцов нельзя считать правильным_. Главный его недостаток --- из формы записи неочевидно, что мы добавляем новый столбец, а не перевычисляем уже существующий. Пакет `dplyr`, который мы рассмотрим в конце настоящей главы, решает эту и многие другие стилистические проблемы работы с фреймами данных.

Помимо того что вы можете вычислять столбцы традиционным способом как функцию от других столбцов, есть удобные функции-агрегаторы, позволяющие сделать вычисления по всем столбцам. Это `rowSums()` (сумма всех столбцов в строке) и `rowMeans()` (среднее по всем столбцам в строке). На тот случай, когда в ячейках есть пропущенные значения, в функциях предусмотрен параметр `na.rm = TRUE`.

```r
years <- sewage[c(-1, -2)] # оставим данные с 2010 по 2013 гг

colSums(years)  # сколько всего было сброшено в каждом регионе за эти года
## Year10 Year11 Year12 Year13 
##     NA     NA     NA     NA
rowMeans(years) # сколько было сброшено в среднем за каждый год
##         1         2         3         4         5         6         7 
## 15837.250  3648.750    72.750    73.000   124.750   132.250    96.500 
##         8         9        10        11        12        13        14 
##    89.250    45.250    37.000    84.000  1234.500    52.750    86.000 
##        15        16        17        18        19        20        21 
##    67.500    25.800    93.000   188.750   224.750   922.000  2906.750 
##        22        23        24        25        26        27        28 
##   190.500   118.000   374.000        NA     0.175   373.750   152.750 
##        29        30        31        32        33        34        35 
##    96.000   260.000   345.750    87.250    44.000  1239.250  1399.250 
##        36        37        38        39        40        41        42 
##    27.750    27.250   878.500    62.000   155.250   248.500   389.000 
##        43        44        45        46        47        48        49 
##    77.750     3.825    31.000    47.000    93.250     0.000  2860.750 
##        50        51        52        53        54        55        56 
##   319.500    55.750    40.500   483.750   115.250    29.250   381.750 
##        57        58        59        60        61        62        63 
##   180.250   477.250   125.250   106.000   376.250    59.500   110.250 
##        64        65        66        67        68        69        70 
##  1745.750    44.750   733.000   184.000        NA    53.250    35.500 
##        71        72        73        74        75        76        77 
##    95.250   784.500  2094.500     0.275    29.000     8.375    34.500 
##        78        79        80        81        82        83        84 
##    10.775    73.500   427.250   582.250   632.750   107.250   166.000 
##        85        86        87        88        89        90        91 
##    22.750   792.250    82.500    36.250   327.500   183.250    79.000 
##        92        93        94        95        96        97 
##    21.500    42.250    15.000     4.975        NA        NA
```

Существуют также аналогичные им функции `colSums()` и `colMeans()`, осуществляющие агрегирование данных по столбцам, а не по строкам.

Перечисленные функции являются укороченной версией универсальных функций семейства `apply`, с которыми мы познакомимся далее.

## Сортировка и фильтрация {#filtering_sorting}

### Сортировка {#table_sorting}

Распространенные операции с таблицами — это упорядочение по определенному столбцу и фильтрация по значениям. Мы уже знаем что из вектора, матрицы или таблицы можно извлекать элементы: `tab[V, ]`, где `tab` --- имя таблицы, `V` --- это вектор из номеров элементов. Например, извлечь 5, 2 и 4 строку таблицы можно так:

```r
tab[c(5,2,4), ]
##   Year Total Baltic Black Azov Caspian Kara White Other
## 5 1997  23.0    2.2   0.3  3.8     9.8  4.4   0.8   1.7
## 2 1994  24.6    2.3   0.4  3.2    11.0  5.0   0.9   1.8
## 4 1996  22.4    2.2   0.3  3.1     9.8  4.7   0.8   1.5
```

Логично предположить, что таким же образом можно извлечь элементы таблицы в порядке, обеспечивающем возрастание или убывание значений в каком-то столбце. Для этого нужно правильным образом расставить индексы в векторе `c(...)`. Существует специальная функция `order()`, которая позволяет это сделать. Например, отсортируем таблицу по возрастанию сбросов в Каспийское море:

```r
indexes<-order(tab$Caspian)
head(tab[indexes, ])
##    Year Total Baltic Black Azov Caspian Kara White Other
## 22 2014  14.8    1.7   0.2  1.5     6.4  3.2   0.6   1.2
## 17 2009  15.9    1.8   0.2  1.5     6.8  3.5   0.7   1.4
## 21 2013  15.2    1.8   0.2  1.6     6.9  3.0   0.6   1.1
## 20 2012  15.7    1.8   0.2  1.6     7.0  3.0   0.7   1.4
## 19 2011  16.0    1.9   0.2  1.6     7.1  3.2   0.7   1.3
## 18 2010  16.5    2.0   0.2  1.6     7.3  3.3   0.7   1.4
```

Если упорядочение несложное, программист его скорее всего вставит непосредственно в инструкцию обращения к таблице:

```r
head(tab[order(tab$Caspian), ])
##    Year Total Baltic Black Azov Caspian Kara White Other
## 22 2014  14.8    1.7   0.2  1.5     6.4  3.2   0.6   1.2
## 17 2009  15.9    1.8   0.2  1.5     6.8  3.5   0.7   1.4
## 21 2013  15.2    1.8   0.2  1.6     6.9  3.0   0.6   1.1
## 20 2012  15.7    1.8   0.2  1.6     7.0  3.0   0.7   1.4
## 19 2011  16.0    1.9   0.2  1.6     7.1  3.2   0.7   1.3
## 18 2010  16.5    2.0   0.2  1.6     7.3  3.3   0.7   1.4
```

### Фильтрация {#table_filtering}

Схожим образом реализована _фильтрация данных_ по значению. Например, вы хотите извлечь из таблицы только те года, в которых объем сбросов в Каспийское море составил более 10 млн м$^3$. Здесь используется еще одна возможность извлечения элементов таблицы — с помощью вектора логических значений `TRUE/FALSE`. Число элементов в этом векторе должно быть равно числу элементов в индексируемом векторе, а значение указывает на то, нужно ли извлекать (`TRUE`) или нет (`FALSE`) элемент с текущим индексом. Вектор логических значений получается естественным путем с помощью операции сравнения:

```r
condition <- tab$Caspian > 10
condition  # посмотрим что получилось
##  [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
tab[condition, ] # используем его для фильтрации строк таблицы:
##   Year Total Baltic Black Azov Caspian Kara White Other
## 1 1993  27.2    2.5   0.4  4.3    12.1  5.3   1.0   1.6
## 2 1994  24.6    2.3   0.4  3.2    11.0  5.0   0.9   1.8
## 3 1995  24.5    2.3   0.4  3.5    10.4  5.2   0.9   1.8
```

Опять же, весьма часто используется запись одним выражением:

```r
tab[tab$Caspian > 10, ]
##   Year Total Baltic Black Azov Caspian Kara White Other
## 1 1993  27.2    2.5   0.4  4.3    12.1  5.3   1.0   1.6
## 2 1994  24.6    2.3   0.4  3.2    11.0  5.0   0.9   1.8
## 3 1995  24.5    2.3   0.4  3.5    10.4  5.2   0.9   1.8
```

Часто бывает необходимо отобрать данные из таблицы, содержащей разнородные данные. В частности, в нашей таблице смешаны данные по субъектам и федеральным округам. Предположим, необходимо выгрузить в отдельную таблицу данные по федеральным округам. Для этого нужно найти строки, в которых столбец `Region` содержит фразу `"федеральный округ"`. Для поиска по текстовым эталонам импользуется функция `grep()`, выдающая номера элементов, или ее разновидность `grepl()`, выдающая список логических констант

```r
# Первый параметр - искомое выражение, второй параметр - где искть
rows <- grep("федеральный округ",sewage$Region)
rows  # посмотрим, какие элементы столбца Region ему соответствуют
## [1]  2 21 35 42 49 64 73 86
okruga <- sewage[rows,] # отфильтруем найденные строки
```

```r
View(okruga)
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-25-1.png)<!-- -->

Наоборот --- для __исключения__ найденных объектов удобнее воспользоваться разновидностью `grepl()`, которая возвращает вектор из логических значений:

```r
rows2 <- grepl("федеральный округ", sewage$Region)
rows2 # вот так выглядит результат grepl
##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
## [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [45] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [67] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
## [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE

neokruga <- sewage[!rows2, ]
```

```r
View(neokruga)
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-28-1.png)<!-- -->

Обратите внимание на восклицательный знак перед `rows2`. Он меняет все значения `TRUE` на `FALSE` и наоборот, что позволяет исключить найденные объекты

В полученной таблице все еще содержится текстовая шелуха типа `"в том числе"`, `"Данные за..."`, а также строка `"Российская Федерация"`. К счастью, функция `grep()` достаточо умна и возволяет искать сразу по нескольким образцам строк. Для этого их нужно разделить вертикальной чертой — _пайпом_ (`|`):

```r
rows2 <- grepl("федеральный|числе|Российская|за|ѕ", sewage$Region)
rows2
##  [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
## [23] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [45] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [67] FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
## [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE
neokruga <- sewage[!rows2, ] # обратите внимание на восклицательный знак перед rows2
```

```r
View(neokruga)
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-31-1.png)<!-- -->

## Пропущенные значения {#missed_values}

Можно ли осуществлять обработку таблицы `sewage`? Попробуем в качестве примера найти минимум сбросов за 2012 год:

```r
max(sewage$Year12)
## [1] NA
```

Результат имеет тип `NA`, потому что в данном столбце имеются пропуски. В некоторых статистических задачах это недопустимо. Если вы хотите проигнорировать значения пропусков, следует в вызываемой статистической функции указать дополнительный параметр `na.rm = TRUE`:

```r
max(sewage$Year12, na.rm = TRUE)
## [1] 15678
```

Еще один вариант --- исключить из таблицы те строки, в которых имеются пропущенные значения (хотя бы одно!). Для этого существует функция `complete.cases()`, возвращающая вектор логических значений:

```r
filter<-complete.cases(sewage)
filter  # посмотрим что получилось. Там где видим FALSE - есть пропуски в строках
##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [12]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [23]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [34]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [45]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [56]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [67]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [78]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [89]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE

sewage.complete <- sewage[filter, ] # отфильтруем полные строки
```

```r
View(sewage.complete)
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-36-1.png)<!-- -->

## Преобразование типов и поиск ошибок {#data_conversion}

Достаточно часто при работе с реальными данными возникает необходимость преобразования их типов. Например, вам необходимо перевести строки в даты, чтобы оперировать ими соответствующим образом. Или принудительным образом указать, что столбец со строками не хранит номинальную переменную (фактор), а его нужно интерпретировать именно как строковый столбец (обычно это полезно, когда столбец содержит какую-то текстовую информацию в виде комментариев по каждому измерению). Наконец, в данных могут быть ошибки, опечатки и так далее, которые могут препятствовать правильному их чтению.

В этом разделе мы рассмотрим, как можно:

1. Найти и исправить множественные варианты одного названия с опечатками
2. Исправить ошибки в числовых данных
3. Преобразовать факторы в строки и наоборот
4. Преобразовать строки в числа и наоборот

Рассмотрим возможные манипуляции с данными на примере таблицы о землепользовании на территории Сатинского учебного полигоны Географического факультета МГУ:

```r
tab <- read.csv2("SatinoLanduse.csv", encoding = 'UTF-8')
str(tab) # посмотрим, какова структура данных
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : Factor w/ 35 levels "","АО \"Родина\"",..: 30 1 1 1 1 1 1 3 2 1 ...
##  $ Perimeter     : Factor w/ 160 levels "1014.155593894044800",..: 67 155 51 104 78 153 17 19 108 57 ...
##  $ Area          : Factor w/ 160 levels "0.238070145845919",..: 73 49 121 100 63 72 88 128 99 24 ...
```

```r
View(tab)
```
![](03-TablesDataReading_files/figure-epub3/unnamed-chunk-39-1.png)<!-- -->

Видно, что все столбцы, кроме двух, хранящих идентификаторы, были прочитаны как строки и преобразованы в факторы (номинальные переменные). Это означает, что мы не сможем работать привычным образом со столбцами периметра и площади, а столбец комментариев теперь также является номинальной переменной, что противоречит здравому смыслу (он вообще переменной не является).

Когда вы отображаете таблицу в консоли или графическом интерфейсе, факторы выглядят и ведут себя как обычные строки. Подвох заключается в том, что хранятся они в виде пар "ключ — значение" (об этом мы говорили выше) и все операции преобразования осуществляются __над ключами__, а не значениями. Рассмотрим, как следует правильно преобразовывать номинальные переменные в __R__.

Чтобы привести столбцы к нужному типу, необходимо использовать преобразования типов. Для этого можно воспользоваться функциями семейства `as`, описанными в Главе 1.

Для начала преобразуем столбец `Comment` к обычному символьному представлению:

```r
tab$Comment <- as.character(tab$Comment)
str(tab)
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : chr  "Село Беницы" "" "" "" ...
##  $ Perimeter     : Factor w/ 160 levels "1014.155593894044800",..: 67 155 51 104 78 153 17 19 108 57 ...
##  $ Area          : Factor w/ 160 levels "0.238070145845919",..: 73 49 121 100 63 72 88 128 99 24 ...
```

Посмотрим теперь, что произойдет, если мы попытаемся преобразовать столбец `Perimeter` к числовому виду:

```r
as.numeric(tab$Perimeter)
##   [1]  67 155  51 104  78 153  17  19 108  57   7   3 158 159 156  50  91
##  [18] 143   6  58   4   5 131 148 113 128 147 114   9  18 118 132  84 134
##  [35]  81  40 130  98  83 157  42  95  71 141   8 100  34   1  87  77 160
##  [52]  93 119  90  74  35 125 150 101 136  31 109 110 103  75  14  32  63
##  [69] 145  56 102  25  65  88  72  53  92  30 117  73  43  54 121  44  52
##  [86]  27 115 149 120  45  26  41   2  60  36 123  29 151 144 106 127  12
## [103] 116  94  82 146 142  69  21  48 139 105 154 124  47  61  33  80  97
## [120]  64  10  76 111  11 112  89  28 129  68  39  49  86  96  59  24 137
## [137]  46 152  55  15  99  85  22 126  16 122  79  66 133  23 107  38 138
## [154]  13 135  37 140  70  20  62
```

Вместо значений перметра мы получили загадочные числа, которых в таблице нет. Это и есть ключи факторов. Чтобы получить их значения, необходимо использовать функцию `levels()` (для краткости выведем первые 10 значений):

```r
levels(tab$Perimeter)[1:10]
##  [1] "1014.155593894044800" "1019.457949256323400" "1020.278536197552200"
##  [4] "1021.109926202218700" "1041.122684298658400" "1060.678503301135200"
##  [7] "1081.964408568060900" "1094.945610298295600" "114.701418496307100" 
## [10] "1155.916232728818800"
```

Обратите внимание на то, что значения фактора отсортированы в алфавитном порядке, без учете порядка их встречаемости в исходной таблице. Для корректного преобразования факторов в числа необходимо сначала привести их к обычному строковому виду:

```r
tab$Perimeter <- as.numeric(as.character(tab$Perimeter))
str(tab)
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : chr  "Село Беницы" "" "" "" ...
##  $ Perimeter     : num  2396 922 2181 3948 279 ...
##  $ Area          : Factor w/ 160 levels "0.238070145845919",..: 73 49 121 100 63 72 88 128 99 24 ...

# Теперь попробуем преобразовать столбец Area
temp <- as.numeric(as.character(tab$Area))
## Warning: в результате преобразования созданы NA
temp[1:10]
##  [1]  286159.159   21651.964   56826.463  450293.759    2612.615
##  [6]   28608.401 3469445.793   62299.631  450291.261  147943.134
```

Все прошло вроде бы успешно, но с предупреждением, что некоторые значения были преобразованы в `NA` (_Not Available_) --- отсутствующие значения. По всей видимости, данные в соответствущих ячейках не соответствуют представлениям __R__ о том, как должно выглядеть число: ячейка или пустая, или число набрано с ошибкой/опечаткой.

Чтобы найти и исправить все неверно заданные данные, необходимо выполнить следующие действия:

1. Получить индексы всех элементов, имеющих значение `NA`.
2. Просмотреть, какие значения были в исходных данных под этими индексами
3. Исправить ошибки в этих значениях, если это поддается автоматизации
4. Повторить конвертацию в числовой тип данных

Проверку на отсутствующие данные осуществляют с помощью функции `is.na()`. Передав ей в качестве аргумента вектор значений, вы получите вектор булевых значений, в котором `TRUE` будет стоять для пустых элементов. Проверим с помощью него, какие элементы столюца `Area` привели к ошибкам конвертации данных:

```r
tab[is.na(temp), "Area"]
## [1] 89499,573298880117000 11922,638460079328000 5153,570673500797100 
## 160 Levels: 0.238070145845919 ... 9865.323033935605100
```

Видно, что __R__ не справился с преобразованием типов там, где содержится опечатка в десятичном разделителе --- вместо точки указана запятая. 

Для исправления этой ошибки мы можем воспользоваться стандартной функцией замены символа `gsub(pattern, replacement, x)`. Ее стандартные параметры означают соответственно: что искать, на что заменять, где искать:

```r
tab$Area <- gsub(',', '.', tab$Area) # заменим запятые на точки
tab$Area <- as.numeric(as.character(tab$Area)) # Теперь можно преобразовать в числа
str(tab)
## 'data.frame':	160 obs. of  6 variables:
##  $ ID            : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ Type          : Factor w/ 12 levels "Выгоны","Вырубки",..: 11 1 1 9 5 1 5 12 9 10 ...
##  $ Administration: Factor w/ 7 levels "","РФ","Совьяковская администрация",..: 5 5 5 1 1 5 1 5 5 6 ...
##  $ Comment       : chr  "Село Беницы" "" "" "" ...
##  $ Perimeter     : num  2396 922 2181 3948 279 ...
##  $ Area          : num  286159 21652 56826 450294 2613 ...
```

Теперь необходимо навести порядок в значениях факторов, убедившись, что и там нет опечаток. Выведем все уникальные значения с помощью функции `levels()`:

```r
levels(tab$Type)
##  [1] "Выгоны"                        "Вырубки"                      
##  [3] "Гидрологические объекты"       "Заболоченные земли"           
##  [5] "Леса"                          "Лесные поляны"                
##  [7] "Луга"                          "Нет данных"                   
##  [9] "Пашни"                         "Сады"                         
## [11] "Территории населенных пунктов" "Фермерские хозяйства"
levels(tab$Administration)
## [1] ""                                    
## [2] "РФ"                                  
## [3] "Совьяковская администрация"          
## [4] "Совьяковская сельскаая администрация"
## [5] "Совьяковская сельская администрация" 
## [6] "Совьяковская сельская Администрация" 
## [7] "Совьяковская сельская админитрация"
```
Видно, что если с типами все в порядке, то в данных об административном подчинении содержится 5 вариантов названия одной и той же Совьяковской сельской администрации. Помимо этого, пустые ячейки хорошо бы заменить на значение `"Прочее"`.

Чтобы найти все строчки, относящиеся к одному и тому же объекту, можно воспользоваться уже знакомой нам функцией `grep()`, передав ей подстроку, которая является для них общей. Например, `"Совьяковская"` (хотя в данном случае было бы вообще достаточно одной буквы `"с"`).

```r
filter <- grep("Совьяковская", tab$Administration) # Найдем все записи
tab[filter, "Administration"] <- "Совьяковская сельская администрация" # Заменим их одним значением
tab$Administration <- droplevels(tab$Administration) # Удаляем неиспользуемые уровни
levels(tab$Administration)
## [1] ""                                   
## [2] "РФ"                                 
## [3] "Совьяковская сельская администрация"
```

Пустые строки можно также найти c помощью `grep()`, но мы этого делать не будем, так как это требует дополнительных знаний о регулярных выражениях. Вместо этого воспользуемся тем, что пустые строки имеют длину 0. Обратите внимание ниже, что преобразование в вектор столбца `Administration` необходимо, т.к. `nchar()` не понимает объекты типа `data.frame`, которыми являются не только таблицы, но и их столбцы:

```r
filter <- nchar(as.vector(tab$Administration)) == 0 # TRUE если длина равна 0
# Пробуем заменить:
tab[filter, "Administration"] <- "Прочее"
## Warning in `[<-.factor`(`*tmp*`, iseq, value = c("Прочее", "Прочее", :
## неправильный уровень фактора, получились NA
```

Ошибка выше связана с тем, что __R__ строго следит за неизменностью набора значений фактора для того чтобы избежать всевозможных ошибок при работе с данными (опечаток и т.д.). Предыдущий раз мы заменили все значаниея одним из существующих. В данном случае необходимо ввести новое значение фактора. Чтобы это сделать, придется преобразовать данные в символьные, произвести замену срок и после этого снова конвертировать столбец в фактор:

```r
tab$Administration <- as.character(tab$Administration)
tab[filter, "Administration"] <- "Прочее"
tab$Administration <- as.factor(tab$Administration)
levels(tab$Administration)
## [1] "Прочее"                             
## [2] "РФ"                                 
## [3] "Совьяковская сельская администрация"
```

Теперь таблица готова к работе. Можно, например, подсчитать по ней сводную статистику:

```r
summary(tab)
##        ID                                    Type   
##  Min.   :  1.00   Леса                         :52  
##  1st Qu.: 40.75   Выгоны                       :27  
##  Median : 80.50   Фермерские хозяйства         :22  
##  Mean   : 80.50   Пашни                        :15  
##  3rd Qu.:120.25   Луга                         :11  
##  Max.   :160.00   Территории населенных пунктов: 8  
##                   (Other)                      :25  
##                              Administration   Comment         
##  Прочее                             :76     Length:160        
##  РФ                                 : 3     Class :character  
##  Совьяковская сельская администрация:81     Mode  :character  
##                                                               
##                                                               
##                                                               
##                                                               
##    Perimeter              Area        
##  Min.   :    3.087   Min.   :      0  
##  1st Qu.:  421.431   1st Qu.:   5087  
##  Median :  939.369   Median :  21260  
##  Mean   : 1761.654   Mean   : 125002  
##  3rd Qu.: 2135.987   3rd Qu.:  83019  
##  Max.   :23920.945   Max.   :3469446  
## 
```
Обратите внимание, что строки, интервальные и номинальные (факторы) переменные обрабатываются функцией `summary()` по-разному.

## Сохранение таблиц {#table_writing}

Одной из завершающих стадий анализа данных, помимо графиков и отчетов, часто являются новые табличные представления, которые было бы неплохо сохранить в виде файлов. К счастью, сохранение таблиц в __R__ столь же просто, как и чтение. Для текстовых файлов в формате __CSV__ можно использовать функции `write.table()`, `write.csv()` и `write.csv2()`. Для файлов __Microsoft Excel__ используйте функцию `write.xlsx()` из пакета `openxlsx` соответственно. 

> __По умолчанию функции `write.table()`, `write.csv()` и `write.csv2()` записывают в таблицы в качестве первого столбца названия (номера) строк таблиц.__ Если вы не хотите, чтобы это происходило, укажите дополнительный параметр `row.names=FALSE`.

Сохраним таблицы `okruga` и `neokruga`, раздельно хранящие статистику по объему сброса сточных в поверхностные водные объекты по федеральным округам и субъектам соответственно:

```r
write.csv2(okruga, "okruga.csv", fileEncoding = 'UTF-8') # Сохраним первую таблицу в CSV в кодировке Unicode
write.xlsx(neokruga, "neokruga.xlsx") # Сохраним вторую таблицу в XLSX без названий строк

# Проверим, все ли в порядке с сохраненными таблицами:

okruga.saved <- read.csv2("okruga.csv", encoding = 'UTF-8')
head(okruga.saved)
##    X                               Region Year05 Year10 Year11 Year12
## 1  2       Центральный федеральный округ    4341   3761   3613   3651
## 2 21   Северо-Западный федеральный округ    3192   3088   2866   2877
## 3 35             Южный федеральный округ    1409   1446   1436   1394
## 4 42 Северо-Кавказский федеральный округ     496    390    397    395
## 5 49       Приволжский федеральный округ    3162   2883   2857   2854
## 6 64         Уральский федеральный округ    1681   1860   1834   1665
##   Year13
## 1   3570
## 2   2796
## 3   1321
## 4    374
## 5   2849
## 6   1624

neokruga.saved <- read.xlsx("neokruga.xlsx",1)
head(neokruga.saved)
##                 Region Year05 Year10 Year11 Year12 Year13
## 1 Белгородская область     11     77     72     71     71
## 2     Брянская область     89     78     75     71     68
## 3 Владимирская область    155    129    126    124    120
## 4  Воронежская область    169    134    135    131    129
## 5   Ивановская область    144    102     99     97     88
## 6    Калужская область     99     92     88     84     93
```

Видно, что в файле __CSV__ присутствует также дополнительный столбец с названиями строк, а в файле __XLSX__ его нет. Если вы не задавали названия строк явным образом и они не несут какого-то смысла, всегда указывайте параметр `row.names=FALSE`

> __Вы можете дать строкам таблицы названия и извлечь их, используя функцию `row.names()`__ аналогично функции `colnames()` для столбцов.

## Обработка таблиц с помощью пакета dplyr {#table_rules}

## Правила подготовки таблиц для чтения в R {#table_rules}

С таблицами, которые мы использовали в настоящем модуле, все прошло гладко, поскольку они были подготовлены специальным образом. Несмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу:

1. В первой строке таблицы должны располагаться названия столбцов.
1. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.
1. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.
1. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: `Валовый внутренний продукт за 2015 г.`. Хорошее название столбца: `GDP2015`.
1. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в __R__.

Следование этим правилам значительно облегчит работу с табличными данными.

## Контрольные вопросы {#questions_tables}

----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----
