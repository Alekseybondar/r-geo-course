# Управление выполнением и векторизованные вычисления  {#controls}



[Программный код главы](https://github.com/tsamsonov/r-geo-course/blob/master/code/05-Controls.R)

Данный модуль посвящен введению в работу с управлением выполнением команд в R, а также методами их пакетного выполнения в виде векторизованных вычислений. Мы рассмотрим такие полезные конструкции как циклы, условия, функции, функции семейства `apply`. Вместе они представляют собой мощное средство для организации сложных технологических схем обработки данных, требующих повторения идентичных операций над каждым элементом множества входных данных, ветвления алгоритма в зависимости от значений переменных, а также структурирования программного кода на автономные блоки команд, выполняющие специализированные функции.

Мы рассмотрим управление командами на примере построения графиков. В качестве исходных данных используем знакомую нам таблицу Росстата по доходам и расходам граждан:

```r
library(openxlsx)

# col.classes<-c("character",rep("numeric",8))
t <- read.xlsx("IncomeConsumption.xlsx", 1)
filter <- grep("федеральный округ", t$Регион)
okr <- t[filter, ]

names <- sub("федеральный округ", "", okr$Регион)

filter<-grepl("федеральный округ|Федерация|числе",t$Регион)
sub <- t[!filter, ]
```

## Циклы {#cycles}

Цикл --- это разновидность управляющей конструкции, предназначенная для организации многократного исполнения набора инструкций. В R циклы наиболее часто используются для пакетной обработки данных, ввода и вывода. Типичными примерами использования циклов являются чтение множества файлов входных данных, а также построение серий графиков и карт одного типа по различным данным. При этом обработка множества строк таблиц в R обычно организуется не средствами циклов, а средствами функций семейства [`lapply`](http://stat.ethz.ch/R-manual/R-devel/library/base/html/lapply.html), о которых мы поговорим отдельно.

В R, как и во многих других языках программирования, существует несколько вариантов циклов. Первый вид циклов — это конструкция __for__ с синтаксисом `for (x in X) statement`. Она означает, что:

- переменная `x` должна пробежать по всем элементам последовательности `X`. В качестве последовательности может выступать любой вектор или список.
- каждый раз, когда `x` будет присвоено значение очередного элемента из `X`, будет выполнено выражение `statement`, которое называют _телом цикла_. Соответственно, цикл выполнится столько раз, сколько элементов содержится в последовательности `X`. 

> Выполнение тела цикла на каждом проходе называют _итерацией_.

Например, с помощью цикла можно вывести на экран числа от 1 до 10, по одному с каждой строки:

```r
for (i in 1:10) print(i)
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
```
Если тело цикла содержит более одной инструкции R, оно должно быть заключено в фигурные скобки, иначе выполнится только первое выражение, а оставшиеся будут запущены один раз после выхода из цикла:


```r
for (i in 1:10){
  a <- factorial(i) # факториал i
  b <- exp(i) # e в степени i
  print(a/b) # факториал растет быстрее экспоненты
}
## [1] 0.3678794
## [1] 0.2706706
## [1] 0.2987224
## [1] 0.4395753
## [1] 0.8085536
## [1] 1.784702
## [1] 4.595885
## [1] 13.52585
## [1] 44.78295
## [1] 164.7473
```
Другой вариант цикла организуется с помощью конструкции `while`, имеющей синтаксис `while (condition) statement`. Такая конструкция означает, что тело цикла будет выполняться, пока значение выражения `condition` (условия) равно `TRUE`. Как правило, в теле цикла обновляется некоторая переменная, которая участвует в проверке условия, и предполагается, что рано или поздно оно станет равным `FALSE`, что приведет к выходу из цикла. Например, вышеприведенный цикл, печатающий числа от 1 до 10, можно переписать на `while` следуюшим образом:

```r
i <- 0
while(i < 10) {
  i <- i+1
  print(i)
}
## [1] 1
## [1] 2
## [1] 3
## [1] 4
## [1] 5
## [1] 6
## [1] 7
## [1] 8
## [1] 9
## [1] 10
```
Обратите внимание на то, что мы внутри цикла обновляем значение переменной i.

> Увеличение значения переменной цикла называется _инкрементом_, а уменьшение --- _декрементом_

Одной из самых распространенных ошибок программистов (особенно начинающих, но и професионалы ее не избегают) является забытая инструкция инкремента (или деккремента) переменной цикла, в результате чего цикл становится бесконечным. В этом плане конструкция `for` более надежна.

Перейдем теперь от искусственных примеров к реальной практике. Например, посмотрим как можно построить столбчатые диаграммы по каждому столбцу таблицы `okr`:

```r
# Пакетное рисование графиков
for(var in colnames(okr)[-1]){
  par(mar = c(5,9,4,2))
  barplot(okr[,var], 
          names.arg = names, 
          horiz = TRUE, 
          las = 1, 
          main = var,
          col = "steelblue")
}
```

![](05-Controls_files/figure-epub3/unnamed-chunk-5-1.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-5-2.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-5-3.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-5-4.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-5-5.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-5-6.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-5-7.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-5-8.png)<!-- -->

А теперь усложним тело цикла, добавив рисование гистограммы распределения по тому же показателю, но взятому из таблицы `sub`:


```r
# Пакетное рисование графиков
par(mfrow = c(1,2))
options(scipen = 999) # запрещаем использовать экспоненциальную форму записи больших чисел

for(var in colnames(okr)[-1]){
  par(mar = c(5,9,4,3)) # устанавливаем поля для столбчатой диаграммы
  barplot(okr[,var], 
          names.arg = names, 
          horiz = TRUE, 
          las = 1, 
          main = var, 
          xlab = "По федеральным округам",
          col = "steelblue")
  par(mar = c(5,3,4,1)) # устанавливаем поля для гистограммы
  hist(sub[,var], breaks = 12, col="green", main = var, xlab = "По субъектам")
}
```

![](05-Controls_files/figure-epub3/unnamed-chunk-6-1.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-6-2.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-6-3.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-6-4.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-6-5.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-6-6.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-6-7.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-6-8.png)<!-- -->

## Условия {#ifelse}

Проверка условий позволяет осуществлять так называемое ветвление в программе. Ветвление означает, что при определенных условиях (значениях переменных) будет выполнен один программный код, а при других условиях --- другой. В R для проверки условий используется условный оператор __if --- else if --- else__ следующего вида:
```
if (condition) {
  statement1
} else if (condition) {
  statement2
} else {
  statement3
}
```

Сначала проверяется условие в выражении `if (condition)`, и если оно истинно, то выполнится вложенный в фигурные скобки программный код `statement1`, после чего оставшиеся условия не будут проверяться. Если первое условие ложно, программа перейдет к проверке следующего условия `else if (condition)`. Далее, если оно истинно, то выполнится вложенный код `statement2`, если нет --- проверка переключится на следующее условие и так далее. Заключительный код `statement3`, следующий за словом `else`, выполнится только если ложными окажутся все предыдущие условия. 

> Конструкций `else if` может быть произвольное количество, конструкции `if` и `else` могут встречаться в условном операторе только один раз, в начале и конце соответственно. При этом условный оператор может состоять только из конструкции `if`, а `else if` и `else` не являются обязательными. Операторы, состоящие из одного `if`, 

Например, используя вышеприведенный код с вычислением экспоненты и факториала, можно вывести на экран информацию о том, больше ли экспонента чем факториал на данной итерации цикла:


```r
for (i in 1:10){
  a <- factorial(i) # факториал i
  b <- exp(i) # e в степени i
  ratio <- a/b # вычисляем отношение экспоненты и факториала
  
  if (ratio < 1){ # если экспонента больше, то...
    cat(i,'! < exp(', i, ')\n', sep = '')
  } else { # в противном случае
    cat(i,'! > exp(', i, ')\n', sep = '')
  }
}
## 1! < exp(1)
## 2! < exp(2)
## 3! < exp(3)
## 4! < exp(4)
## 5! < exp(5)
## 6! > exp(6)
## 7! > exp(7)
## 8! > exp(8)
## 9! > exp(9)
## 10! > exp(10)
```

Теперь рассмотрим более практическую задачу. В нашем распоряжении имеются данные по среднеклиматическим (за последние 50 лет) температурам на территории юга Европейской части России с разрешением $30''$ (около 1 км), полученные с портала [WorldClim](http://www.worldclim.org). Необходимо построить гистограммы распределения температур по месяцам года, раскрасив их в различные цвета соответственно среднему значению температуры:

- Если средняя температура ниже $0^\circ C$, то цвет гистограммы синий
- Если средняя температура от $0^\circ C$ до $10^\circ C$, то цвет гистограммы желтый
- Если средняя температура выше $10^\circ C$, то цвет гистограммы оранжевый



```r
# Пакетное чтение данных
library(foreign) # для чтения dbf необходима библиотека foreign

files <- list.files("dbf") # прочитаем список файлов в директории dbf

files <- files[grep(".dbf", files, fixed = TRUE)] # отфильтруем файлы с расширением .dbf

names <- sub(".dbf","",files) # получим названия месяцев, избавившись от расширений

i <- 1 # Создадим дополнительно переменную цикла, чтобы выбирать i-е название месяца

for (file in files){ # пройдемся по всем файлам
  
  temp <- read.dbf(paste("dbf/", file, sep='')) # прочитаем текущий файл
  
  tmean <- mean(temp$Temp) # вычислим среднюю температуру из столбца Temp
  
  hist.col <- "white" # иницилизируем переменную цвета за пределами условия 
  
  # Проверим наше условие
  if (tmean < 0){ 
    hist.col <- "steelblue"
  } else if (tmean < 10){
    hist.col <- "yellow"
  } else {
    hist.col <- "orange"
  }
  
  # Построим гистограмму
  hist(temp$Temp, 
       col = hist.col, 
       main = names[i]) # Вот здесь нам нужна дополнительная переменная цикла
  
  # Нанесем линию среднего значения
  abline(v = tmean, 
         lwd = 2, 
         col = "red") 
  
  # Подпишем среднюю температуру
  text(tmean, 
       1000, 
       labels = round(tmean,1), 
       pos = 4, 
       col = "red")
  
  i <- i + 1 # Не забудем сделать инкремент переменной цикла
}
```

![](05-Controls_files/figure-epub3/unnamed-chunk-8-1.png)<!-- -->![](05-Controls_files/figure-epub3/unnamed-chunk-8-2.png)<!-- -->

## Функции {#functions}

Функции в R можно использовать для структурирования кода на логически завершенные, автономные фрагменты кода, каждый из которых выполняет конкретную задачу. Чем сильнее разрастается ваш программный код, тем больше проявляется потребность в наличии функций. Функции позволяют использовать один и тот же код  разных местах программы, не повторяя его.

Синтаксис функции выглядит следующим образом:
```
functionName <- function(parameter1, parameter2, ...){
  ...
  return(result)
}
```

Функция создается c помощью ключевого слова `function`, за которым в круглых скобках заключается произвольное количество параметров (столько, сколько вам нужно: от нуля и более). С помощью этих параметров вы сможете передавать внутрь функции значения переменных. Созданной функции необходимо дать имя, используя оператор присвоения `<-`. После того как выполнится код внутри функции, результат можно вернуть, используя ключевого слово `return`.

> __R__ не поддерживает возврат множественных результатов. Если вам необходимо вернуть несколько объектов (переменных, векторов, таблиц и т.д.), создайте список (list), включите в него все возвращаемые объекты и верните из функции этот список.  

В вышеприведенном примере мы использовали проверку условия для того чтобы вычислить рекомендуемый цвет гистограммы. С одной стороны, это некая вспомогательная процедура, не имеющая непосредственного отношения к построению гистограммы. С другой стороны, это полезная процедура, которой мы захотим воспользоваться в дальнейшем --- всегда приятно, когда программа тебе с выбором стилей оформления данных^[в картографии это называется "smart mapping", что переводят как "умное картографирование", хотя это и не самый удачный вариант перевода].

Оформим выбор цвета в виде функции, которая принимает в каестве параметра число (температуру), а возвращает название цвета.


```r
# Создадим функцию, возвращающую цвет в зависимости от температуры
selectColor <- function(value){ 
  hist.col <- "white"
  if (tmean < 0){
    hist.col <- "steelblue"
  } else if (tmean < 10){
    hist.col <- "yellow"
  } else {
    hist.col <- "orange"
  }
  return(hist.col)
}

i <- 1
par(mfrow = c(2,2))
for (file in files){
  temp <-  read.dbf(file)
  tmean <-  mean(temp$Temp)
  
  # выберем цвет с помощью нашей функции
  hist.col <- selectColor(tmean)
  
  # построим гистограмму
  hist(temp$Temp, 
       col = hist.col, 
       main = names[i])
  
  # добавим линию среднего
  abline(v = tmean, 
         lwd = 2, 
         col = "red")
  # подпишем среднее
  text(tmean, 
       1000, 
       labels = round(tmean,1), 
       pos = 4, 
       col = "red")
  i <- i+1
}
```

![](05-Controls_files/figure-epub3/unnamed-chunk-9-1.png)<!-- -->

Усложним задачу, чтобы показать, как работать с несколькими аргументами функции. Например, мы хотим не одноцветные диаграммы, а чтобы цвет менялся плавным градиентом от первого столбика гистограммы до последнего. Соответственно, количество возвращаемых цветов должно быть равно количеству столбиков в гистограмме. Нашей функции не важно, столбики это или нет, но ей надо знать, сколько цветов надо вернуть. Для этого добавим в нее второй параметр `ncolors`. Это позволит пользователю при желании не задвать этот параметр, если необходим только один цвет.

```r
selectColor2 <- function(value, ncolors){ # передаем в качестве дополнительного параметра количество цветов
  hist.col <- "white"
  # генерируем ncolors цветов из соответствующей палитры
  if (tmean < 0){
    hist.col <- colorRampPalette(c("darkslateblue", "steelblue1"))(ncolors)  
  } else if (tmean < 10){
    hist.col <- colorRampPalette(c("steelblue1", "yellow"))(ncolors)
  } else {
    hist.col <- colorRampPalette(c("yellow", "red"))(ncolors)
  }
  return(hist.col)
}

i <- 1

par(mfrow = c(2,2))

ncells <- 25 # установим фиксированное количество столбцов гистограммы

for (file in files){
  temp <- read.dbf(file)
  tmean <- mean(temp$Temp)
  
  # получим для раскраски требуемое количество цветов
  hist.col <- selectColor2(tmean, ncells)
  
  # построим гистограмму
  hist(temp$Temp, 
       col = hist.col, 
       main = names[i], 
       breaks = ncells)
  
  # добавим линию среднего
  abline(v = tmean, 
         lwd = 2, 
         col = "red")
  
  # подпишем среднее
  text(tmean, 1000, 
       labels = round(tmean,1), 
       pos = 4, 
       col = "red")
  
  i <- i+1
}
```

![](05-Controls_files/figure-epub3/unnamed-chunk-10-1.png)<!-- -->

## Векторизованые вычисления {#vectorized}

## Контрольные вопросы и задачи {#questions_tasks_controls}

### Вопросы {#questions_controls}

### Задачи {#tasks_controls}

----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----
