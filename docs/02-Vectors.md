# Векторы {#vectors}

В это модуле мы познакомимся с векторами -- упорядоченными последовательностями объектов одного типа. Вектор является простейшей и одновременно базовой структурой данных в R. Понимание принципов работы с векторами необходимо для дальнейшего знакомства с более сложными структурами данных, такими как матрицы, фреймы данных, списки и массивы

## Создание вектора {#vector_creation}

Вектор представляет собой упорядоченную последовательность объектов одного типа. То есть, вектор может состоять _только_ из чисел, _только_ из строк, _только_ из дат или _только_ из логических значений. Числовой вектор легко представить себе в виде набора цифр, выстроенных в ряд и пронумерованных согласно порядку их расстановки.

Существует множество способов создания векторов. Среди них наиболее употребительны:

1. Явное перечисление элементов
2. Создание пустого вектора ("болванки"), состоящего из заданного числа элементов
3. Генерация последовательности значений 

Для создания вектора путем __перечисления__ элементов используется функция `c()`:

```r
# вектор из строк — цвета некоторых веток Московского метро
colors <- c("Красная", "Зеленая", "Синяя", "Коричневая", "Оранжевая")
colors
## [1] "Красная"    "Зеленая"    "Синяя"      "Коричневая" "Оранжевая"
```


```r
# вектор из чисел — длина веток в километрах (в той же последовательности)
lengths <- c(28, 40, 45, 19, 38)
lengths
## [1] 28 40 45 19 38
```


```r
# вектор из булевых переменных — наличие  открытых наземных участков (в той же последовательности)
opens <- c(FALSE, TRUE, TRUE, FALSE, FALSE)
opens
## [1] FALSE  TRUE  TRUE FALSE FALSE
```

> Внимание: не используйте латинскую букву 'c' в качестве названия переменной! Это приведет к конфликту названия встроенной функции c() и определенной вами переменной

Помимо этого, распространены сценарии, когда вам нужно создать вектор, но заполнять его значениями вы будете по ходу выполнения программы --- скажем, при последовательной обработке строк таблицы. В этом случае вам известно только предполагаемое количество элементов вектора и их тип. Здесь лучше всего подойдет __создание пустого вектора__, которое выполняется функцией `vector()`. Функция принимает 2 параметра:

* `mode` отвечает за тип данных и может принимать значения равные `"logical"`, `"integer"`, `"numeric"` (или `"double"`), `"complex"`, `"character"` и `"raw"`
* `length` отвечает за количество элементов

Например:

```r
# Вектор из 5 элементов, который предполагается заполнить целыми числами
intvalues <- vector(mode = "integer", length = 5)
intvalues # по умолчанию заполнен нулями
## [1] 0 0 0 0 0

# Вектор из 10 элементов, который предполагается заполнить символьными данными (строками)
charvalues <- vector("character", 10)
charvalues # по умолчанию заполнен пустыми строками
##  [1] "" "" "" "" "" "" "" "" "" ""
```

Обратите внимание на то, что в первом случае подстановка параметров произведена в виде `параметр = значение`, а во втором указаны только значения. В данном примере оба способа эквивалентны. Однако первый способ безопаснее и понятнее. Если вы указываете только значения параметров, нужно помнить, что интерпретатор будет подставлять их именно в том порядке, в котором они перечислены в описании функции. 

> Описание функции можно посмотреть, набрав ее название в консоли ее название со знаком вопроса в качестве префикса. Например, для вышеуказанной функции надо набрать `?vector`

Наконец, третий распространенный способ создания векторов --- это __генерация последовательности__. Чтобы сформировать вектор из натуральных чисел от `M` до `N`, можно воспользоваться специальной конструкцией: `M:N`:

```r
index <- 1:5 # эквивалентно c(1,2,3,4,5)
index
## [1] 1 2 3 4 5
index <- 2:4 # эквивалентно c(2,3,4)
index
## [1] 2 3 4
```

Существует и более общий способ создания последовательности --- функция `seq()`, которая позволяет генерировать вектора значений нужной длины и/или с нужным шагом:

```r
seq(from = 1, by = 2, length.out = 10) # 10 нечетных чисел, начиная с единицы
##  [1]  1  3  5  7  9 11 13 15 17 19
seq(from = 2, to = 20, by = 3) # от 2 до 20 с шагом 3 (сколько поместится)
## [1]  2  5  8 11 14 17 20
seq(length.out = 10, to = 2, by = -2) # убывающая последовательность из 10 четных чисел с последним элементом, равным 2
##  [1] 20 18 16 14 12 10  8  6  4  2
```

Как видно, параметры функции `seq()` можно комбинировать различными способами и указывать в произвольном порядке (при условии, что вы используете полную форму (`параметр = значение`). Главное, чтобы их совокупность _однозначно описывала последовательность_. Хотя, скажем, последний пример убывающей последовательности нельзя признать удачным с точки зрения наглядности.

Аналогичным образом можно создавать _последовательности дат_:

```r
seq(from = as.Date('2016/09/01'), by = 1, length.out = 7) # Даты первой недели учебного 2016/2017 года
## [1] "2016-09-01" "2016-09-02" "2016-09-03" "2016-09-04" "2016-09-05"
## [6] "2016-09-06" "2016-09-07"

seq(from = Sys.Date(), by = 7, length.out = 5) # Пять дат через неделю, начиная с сегодняшнего дня
## [1] "2017-10-05" "2017-10-12" "2017-10-19" "2017-10-26" "2017-11-02"
```

## Работа с элементами вектора {#vector_elements}

К отдельным __элементам вектора__ можно обращаться по их индексам:

```r
colors[1] # первый элемент вектора
## [1] "Красная"
colors[3] # третий элемент
## [1] "Синяя"
```

> ВНИМАНИЕ: элементы векторов и других структур данных в языке R индексируются от 1 до N, где N — это длина вектора. Это отличает R от широко распространенных Си-подобных языков программирования (C, C++, C#, Java) и Python, в которых индексы элементов начинаются с 0 и заканчиваются N-1. Например, первый элемент списка (аналог вектора в R) на языке Python извлекался бы как colors[0]. За этим нужно внимательно следить, особенно если вы программируете на нескольких языках.

__Количество элементов (длину) вектора__ можно узнать с помощью функции `length()`:

```r
length(colors)
## [1] 5
```

Последний элемент вектора можно извлечь, если мы знаем его длину:

```r
n <- length(colors)
colors[n]
## [1] "Оранжевая"
```

Последовательности удобно использовать для извлечения подвекторов. Предположим, нужно извлечь первые 4 элемента. Для этого запишем:

```r
lengths[1:4]
## [1] 28 40 45 19
```

Индексирующий вектор можно создать заранее. Это удобно, если номера могут меняться в программе:

```r
m <- 1
n <- 4
index <- m:n
lengths[index]
## [1] 28 40 45 19
```

Обратите внимание на то что по сути один вектор используется для извлечения элементов из другого вектора. Это означает, что мы можем использовать не только простые последовательности натуральных чисел, но и векторы из прозвольных индексов. Например:

```r
index <- c(1, 3, 4) # хотим извлечь 1, 3 и 4 элемент списка
lengths[index]
## [1] 28 45 19

index <- c(5, 1, 4, 2) # индексы могут располагаться в произвольном порядке
lengths[index]
## [1] 38 28 19 40
```

## Анализ и преобразования векторов {#vector_transform}

К числовым векторам можно применять множество функций. Прежде всего, нужно знать функции вычисления базовых параметров статистического ряда --- минимум, максимум, среднее, медиана, дисперсия, размах вариации, среднеквадратическое отклонение, сумма:

```r
min(lengths) # минимум
## [1] 19
max(lengths) # максимум
## [1] 45
range(lengths) # размах вариации = максимум - минимум
## [1] 19 45
mean(lengths) # среднее арифметическое
## [1] 34
median(lengths) # медиана
## [1] 38
var(lengths) # дисперсия (по английски - вариация, variation)
## [1] 108.5
sd(lengths) # среднеквадратическое отклонение (standard deviation)
## [1] 10.41633
sum(lengths) # сумма
## [1] 170
```

Одной из мощнейших особенностей R является то что он не проводит различий между числами и векторами чисел. Поскольку R является матричным языком, каждое число представляется как вектор длиной 1 (или матрица $1х1$). Это означает, что любая математическая функция, применимая к числу, будет применима и к вектору:

```r
lengths * 1000 # преобразуем длины линий в метры
## [1] 28000 40000 45000 19000 38000
sqrt(lengths) # квадратный корень из длины каждого элемента
## [1] 5.291503 6.324555 6.708204 4.358899 6.164414

stations <- c(20, 21, 22, 12, 24) # количество станций

dens <- stations / lengths # плотность станций по веткам метро = кол-во станций / длина 
dens
## [1] 0.7142857 0.5250000 0.4888889 0.6315789 0.6315789
```

## Поиск и сортировка элементов {#vector_search_sorting}

К важнейшим преобразованиям векторов относится их __сортировка__:

```r
lengths2 <- sort(lengths) # сортировка по возрастанию значений
lengths2 # отсортированный вектор
## [1] 19 28 38 40 45
lengths # сравним с исходным
## [1] 28 40 45 19 38

lengths2 <- sort(lengths, decreasing = TRUE) # сортировка по убыванию значений. Нужно задать параметр decreasing
lengths2 # отсортированный вектор
## [1] 45 40 38 28 19
lengths # сравним с исходным
## [1] 28 40 45 19 38
```

Другая распространенная задача --- это __поиск индекса__ элемента по его значению. Например, вы хотите узнать, какая ветка Московского метро (среди рассматриваемых) является самой длинной. Вы, конечно, легко найдете ее длину с помощью функции `max(lengths)`. Однако это не поможет вам узнать ее название, поскольку оно находится в другом векторе, и его индекс в массиве неизвестен. Поскольку векторы упорядочены одинаково, нам достаточно узнать, под каким индексом в массиве `lengths` располагается максимальный элемент, и затем извлечь цвет линии метро под тем же самым индексом. Дл поиска индекса элемента используется функция `match()`:

```r
l <- max(lengths) # находим максимальное значение
idx <- match(l, lengths) # находим индекс элемента, равного l, в списке lengths
color <- colors[idx] # извлекаем цвет ветки метро
color
## [1] "Синяя"
```

Здесь непохо бы лишний раз потренироваться в конкатенации строк, чтобы вывести результат красиво!

```r
s <- paste(color, "ветка Московского метро — самая длинная. Ее протяженность составляет", l, "км")
s
## [1] "Синяя ветка Московского метро — самая длинная. Ее протяженность составляет 45 км"
```

Ну и напоследок пример "матрешки"" из функций --- как найти название самой плотной линии одним выражением:

```r
colors[match(max(dens),dens)]
## [1] "Красная"
```

## Контрольные вопросы и задачи {#questions_tasks_vectors}

### Вопросы {#questions_vectors}

1. Что такое вектор в языке R?
1. Какие способы создания векторов существуют?
1. Можно ли хранить в векторе данные разных типов?
1. Как определить длину вектора?
1. Как извлечь из вектора элемент по его индексу?
1. Как извлечь из вектора множество элементов по их индексам?
1. Как извлечь из вектора последний элемент?
1. С помощью какой функции можно сгенерировать последовательность чисел или дат с заданным шагом?
1. Как сгенерировать последовательность целых чисел с шагом 1, не прибегая к функциям?
1. Можно ли применять к векторам арифметические операторы? Что будет результатом их выполнения?
1. С помощью какой функции можно отсортировать вектор? Как изменить порядок сортировки на противоположный?
1. С помощью какой функции можно найти индекс элемента вектора по его значению? Что вернет функция, если этот элемент встречается в векторе несколько раз?

### Задачи {#tasks_vectors}


----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----
