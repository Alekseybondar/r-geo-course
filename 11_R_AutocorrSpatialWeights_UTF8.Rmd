# Исследование простраственной автокорреляции 1. Анализ географического соседства {#autocorrelation_weights}

В данном модуле мы приступим к исследованию связей в географическом пространстве. Понятие пространственной автокорреляции является математическим отражением первого закона географии: все связано со всем, но близкорасположенные объекты связаны сильнее. Различные коэффициенты пространственной автокорреляции, такие как индекс Морана (Moran's I) позволяют охарактеризовать силу этой связи с точки зрения математической статистики. Однако для их вычисления необходимо формализовать понятия географической близости, или географического соседства. В настоящем модуле рассматриваются различные подходы к решению данной проблемы.

## Введение 

Анализ географического соседства --- первый этап исследования пространственной автокорреляции (ПА). Общепринятого определения ПА не существует. Одно из наиболее удачных определений гласит следующее:

> Для множества $S$, состоящего из $n$ географических единиц, пространственная автокорреляция есть соотношение между переменной, наблюдаемой в каждой из $n$ единиц и мерой географической близости, определенной для всех $n(n − 1)$ пар единиц из $S$ (Hubert et al., 1981)^[_Hubert, L. J., R. G. Golledge, and C. M. Costanza_ (1981). __Generalized Procedures for Evaluating Spatial Autocorrelation__. Geographical Analysis 13, 224–32. DOI: 10.1111/j.1538-4632.1981.tb00731.x]

Анализ ПА, как правило, осуществляется по жестко зафиксированной сетке (lattice) учетных единиц, в качестве которых могут выступать как площади, так и точки. Но, строго говоря, пространственная статистика в конечном счете любую единицу будет интерпретировать как точку.

Конечной целью исследований ПА является построение статистической модели зависимости значения показателя в каждой единице от значений в соседних единицах и (опционально) неких факторов. Наличие статистически значимой ПА говорит о влиянии процессов, обуславливающих кластеризацию значений в соседних территориальных единицах. И пока эти механизмы не установлены, модель ПА дает инструмент их статистического моделирования. Добавление известных факторов в модель может улучшить точность моделирования.

Как мы уже сказали, исследование ПА начинается с анализа географического соседства. То есть, для каждой анализируемой единицы мы должны определить соседние по отношению к ней единицы. Это не так-то просто,поскольку существует множество способов определить соседство. 

Перед выполнением анализа подключим необходимые библиотеки и визуализируем исходные данные:
```{r, message = FALSE, results = "hide", collapse=TRUE}
library(sp)
library(rgdal)
library(spdep)  # пакет spdep содержит инструменты анализа ПА
library(lattice)
library(RANN)
library(RColorBrewer)

setwd("/Volumes/Dropbox/Dropbox/R/Lectures/Scripts/RMarkdown/data/11_R_SpatialWeights")
reg <- readOGR(".", "Regions")

par(mar = c(1,1,1,1))
plot(reg, border = "gray50")
```

## Методы установления географического соседства

В целом, можно выделить три большие группы методов:

* Соседи по смежности
* Соседи по графу
* Соседи по метрике

__Соседство по смежности__ основано на топологических отношениях между объектами и применяется при анализе данных, приуроченных к площадным единицам --- например, сетке административно-территориального деления. Смежными считаются объекты, границы которых имеют общие точки. При этом возможно два варианта соседства: по правилу ферзя (QUEEN) и правилу ладьи (ROOK). В первом случае соседними будут считаться все пары территориальных единиц, имеющие хотя бы одну общую точку на границе, т.е. соприкасющиеся сторонами и/или углами. Соседство по правилу ладьи является более строгим, так как разрешает только наличие общих сторон вдоль границ, а точечные касания в расчет не берутся. Отличия правил иллюстрирует рисунок ниже.

![_Поиск географических соседей по правилу ферзя и правилу ладьи_](images/QueenRook.png)

__Соседство по графу__ основано на отношениях объектов в [триангуляции Делоне](https://ru.wikipedia.org/wiki/Триангуляция_Делоне). В эту же категорию попадают всевозможные фильтрации триангуляции Делоне, которые удаляют из нее ребра, не удовлетворяющие заданным критериям. Более подбробно о них будет сказано ниже.

__Соседство по метрике__ основано на вычислении расстояний между объектаи. Соседними по отношению к каждому объекту будут считаться либо $K$ ближайших к нему объектов (соседи по количеству), либо все объекты, удаленные на растояние не далее $D_{max}$ (соседи по расстоянию).

Результатом анализа соседства является __граф соседства__(neighborhood graph), в котором сами объекты являются вершинами, а связи между ними --- ребрами.

Анализ географического соседства на языке R можно провести с помощью пакета [spdep](https://cran.r-project.org/web/packages/spdep/index.html).

Рассмотрим суть и принципы построения графов соседства на основе различных принципов.

### Соседи по смежности

Список соседей по смежности можно получить с помощью функции `poly2nb()`.

Возвращаемый объект является классом типа `nb`. Для каждой единицы в нем содержится список номеров соседних по отношению к нему единиц. По умолчанию функция находит соседей по правилу ферзя:

```{r, message = FALSE, results = "hide", collapse=TRUE}
polynei<-poly2nb(reg) # Соседство по правилу ферзя
polynei  # посмотрим сводную информацию
class(polynei)  # проверим тип объекта
```

Для объектов типа `nb` в пакете `spdep` определена своя функция `plot()`, которая позволяет визуализировать граф соседства. Функция требует на вход координаты точек, в случае площадных единиц для этого используют центроиды площадей, которые можно получить функцией `coordinates()`:

```{r, message = FALSE, results = "hide", collapse=TRUE}
coords <- coordinates(reg)

# Теперь рисуем граф:
plot(reg, border = "gray50")
plot(polynei, coords, pch = 19, cex = 0.5, add = TRUE)
title(main="Соседи по смежности (правило ферзя)")
```

Для определения соседей по правилу ладьи необходимо вызвать функцию `poly2nb()` с аргументом `queen=FALSE`. В нашем случае, правда, это даст тот же результат, поскольку в данных отсутствуют единицы, соприкасающиеся в одной лишь точке:
```{r, message = FALSE, results = "hide", collapse=TRUE}
polynei<-poly2nb(reg, queen=FALSE) # Соседство по правилу ладьи

plot(reg, border="grey70")
plot(polynei, coords, pch = 19, cex = 0.5, add = TRUE)
title(main="Соседи по смежности (правило ладьи)")
```

Обратим внимание на то, что функция `poly2nb()` принимает на вход площадные объекты. Все помледующие методы определения соседства (по графу и по метрике) работают с точечными данными.

### Соседи по графу

Данная группа методов определения соседства основана на построении триангуляции Делоне для точек исходных данных. Далее эта триангуляция может быть оставлена в неизменном виде, или быть подвержена процедуре фильтрации, которая удалит из нее ребра, не удовлетворяющие заданному критерию.

__Соседи по триангуляции Делоне__ без фильтрации могут быть получены с помощью функции `tri2nb()`:

```{r, message = FALSE, results = "hide", collapse=TRUE}
plot(reg, border="grey70")
trinei<-tri2nb(coords)
plot(trinei, coords, pch = 19, cex = 0.5, add = TRUE)
title(main="Соседи по триангуляции Делоне")
```

__Соседи по сфере влияния__ получаются путем фильтрации триангуляции Делоне. Для каждой вершины находится расстояние до ближайшего соседа $D_{min}$ --- это расстояние называется радиусом _сферы влияния_ вершины. Остальные ребра триангуляции, инцидентные (примыкающие к) данной вершине, сохраняются только если их длина $D$ превышает радиус ее сферы влияния не более чем вдвое: $D \leq 2D_{min}$. Рассуждая геометрически, можно сказать, что сферы радиусом $D_{min}$, построенные в точке и ее соседях по триангуляции, должны пересекаться. Процесс фильтрации по сфере влияния иллюстрирует рисунок ниже.

![_Поиск географических соседей по правилу сферы влияния_](images/SphereOfInfluence.png)

Поиск соседей по сфере влияния построен по аналогии с принципом [сферы действия тяготения](https://ru.wikipedia.org/wiki/Сфера_действия_тяготения) из небесной механики. 

Построение соседей по правилу сферы влияния осуществляется в 3 шага:

* определение соседей по триангуляции (функция `tri2nb()`)
* фильтрация триангуляции по правилу сферы влияния (функция `soi.graph()`)
* преобразование полученного объекта в класс `nb`(функция `graph2nb()`)

```{r, message = FALSE, results = "hide", collapse=TRUE}
plot(reg, border="grey70")
soinei<-graph2nb(soi.graph(tri2nb(coords), coords))
plot(soinei, coords, pch = 19, cex = 0.5, add = TRUE)
title(main="Соседи по сфере влияния")
```

__Соседи по графу Гэбриела__ получаются также путем фильтрации триангуляции Делоне. В каждом треугольнике ребро сохранятся только тогда, когда построенная на нем окружность не включает третью точку треугольника (Gabriel, Sokal, 1969)^[_Gabriel K. R., Sokal R. R._ (1969), __A new statistical approach to geographic variation analysis__, Systematic Zoology, Society of Systematic Biologists, 18 (3): 259–270, DOI: 10.2307/2412323]. Данный метод проиллюстрирован рисунком ниже.

![_Поиск географических соседей по графу Гэбриела_](images/Gabriel.png)

Поиск соседей по графу Гэбриела осуществляется в 2 шага:

* построение графа Гэбриела (функция `gabrielneigh()`)
* преобразование полученного объекта в класс `nb`(функция `graph2nb()`)

```{r, message = FALSE, results = "hide", collapse=TRUE}
plot(reg, border="grey70")
gabnei<-graph2nb(gabrielneigh(coords))
plot(gabnei, coords, pch = 19, cex = 0.5, add = TRUE)
title(main="Соседи по графу Гэбриела")
```

__Относительные соседи по графу__ получаются путем фильтрации триангуляции Делоне по следующему правилу: ребро $A$, соединяющее две вершины $p$ и $q$, будет удалено, если найдется третья вершина $r$, такая что расстояния от нее до $p$ и $q$ ($B$ и $C$ соответственно) окажутся короче, чем $A$, то есть: $A > B$ __and__ $A > C$. Полученный граф носит название графа относительных соседей (relative neighborhood graph). Данный метод был предложен французским информатиком Готфридом Туассеном для выявления структуры множества точек, которая бы максимально соответствовала восприятию человеком формы этого множества (Toussaint, 1980)^[_Toussaint G. T._ (1980), __The relative neighborhood graph of a finite planar set__, Pattern Recognition, 12 (4): 261–268, DOI: 10.1016/0031-3203(80)90066-7].

Поиск соседей по графу относительных соседей осуществляется в 2 шага:

* построение графа относительных соседей (функция `relativeneigh()`)
* преобразование полученного объекта в класс `nb`(функция `graph2nb()`)

```{r, message = FALSE, results = "hide", collapse=TRUE}
plot(reg, border="grey70")
relnei<-graph2nb(relativeneigh(coords))
plot(relnei, coords, pch = 19, cex = 0.5, add = TRUE)
title(main="Относительные соседи по графу")
```

### Соседи по метрике

Поиск соседей по метрике — наиболее простой способ определения соседства. Для его использования необходимо задать метрику (как правило, расстояние между точками), а также критерий фильтрации связей: по количеству ($k$ ближайших) или по расстоянию (не ближе чем $d_1$, но и не далее чем $d_2$).

Поиск __соседей по количеству__ осуществляется в 2 шага:

* построение списка соседей (функция `knearneigh()`)
* преобразование полученного объекта в класс `nb`(функция `knn2nb()`)

Рассмотрим поиск по количеству на примере нескольких пороговых значений:
```{r, message = FALSE, collapse=TRUE}
par(mfrow = c(2,2))
for (i in 1:4){
  knearnei<-knn2nb(knearneigh(coords, k = i))
  
  plot(reg, border="grey70")
  plot(knearnei, coords, pch = 19, cex = 0.5, add = TRUE)
  title(main = paste("Ближайшие соседи (k =", i, ")", sep = ''))
}
```

Поиск __соседей по расстоянию__ осуществляется средствами функции `dnearneigh()`, которая принимает 3 аргумента: координаты точек, минимальное $d_1$ и максимальное $d_2$ расстояние. Минимальное расстояние имеет смысл использовать чтобы избежать анализа совпадающих по положению объектов, или когда известен пространственный период явления, превышающий $d_1$:

```{r, message = FALSE, results = "hide", collapse=TRUE}
par(mfrow = c(2,2))
for (d in 3:6){
  dnearnei <- dnearneigh(coords, d1 = 0, d2 = d)
  
  plot(reg, border="grey70")
  plot(dnearnei, coords, pch = 19, cex = 0.5, add = TRUE)
  title(main = paste("Ближайшие соседи (d <=", d, ")", sep = ''))
}
```

Итак, мы рассмотрели различные принципы выявления географического соседства. После того, как определен сам факт соседства, необходимо оценить силу пространственной связи между всеми парами соседних единиц. Эта оценка производится путем построения __матрицы пространственных весов__(spatial weights matrix).

## Пространственные веса

Пространственные веса характеризуют силу связи между единицами. Если единицы не являются соседними (по выбранному правилу), то пространственный вес их связи будет равен нулю. Во всех остальных случаях веса будут ненулевыми. Поскольку теоретически каждая единица может быть связана с любой другой единицей, распространена форма представления весов в виде матрицы $W$ размером $N \times N$, где $N$ -- число единиц. На пересечении $i$-й строки и $j$-го столбца матрицы располагается вес связи между $i$-й и $j$-й единицей.

Простейший вид матрицы $W$ — бинарная. Если связь есть, то ее вес равен единице (1), если нет — нулю (0). Для построения бинарной матрицы нужно использовать функцию `nb2listw()` c параметром `style="B"`:

```{r, message = FALSE, results = "hide", collapse=TRUE}
polynei<-poly2nb(reg)
Wbin<-nb2listw(polynei,style="B")
Wbin  # посмотрим, что за объект получается на выходе (listw)
```

Оказывается, что это на самом деле не матрица. Это объект с двумя слотами. В слоте weights содержатся веса, а в слоте neighbours — идентификаторы соседей:
```{r, message = FALSE, results = "hide", collapse=TRUE}
Wbin$neighbours
Wbin$weights
```

> Дело в том, что матрица весов всегда получается разреженной. То есть, в основном она содержит нули. Это логично, поскольку у каждой точки как правило есть лишь ограниченное число соседей. При этом общее количество точек может быть достаточно большим: чем больше точек мы анализируем, тем больше будет нулей в матрице. Получается, что хранить матрицу как матрицу неэкономично. Более рационально для каждого объекта возвращать список весов, которые соответствуют его соседям. Что и делает функция `nb2listw()`.

Матрицу весов как правило визуализируют, поскольку она может содержать в себе довольно интересные паттерны. Для этого полученный список весов нужно превратить в матрицу с помощью функции `listw2mat()`. Далее использовать функцию `levelplot` из пакета `lattice`, которая раскрашивает ячейки матрицы или растрового набора данных:
```{r, message = FALSE, results = "hide", collapse=TRUE}
M<-listw2mat(Wbin)
levelplot(M, main="Матрица весов (бинарная)")
```

Более интересный результат дает нормированная матрица. В ней веса всех соседей нормируются на количество соседей. То есть, если у текущей точки 2 соседа, их веса будут равны 0.5. Если 3 соседа то 0.33, 4 — 0.25 и так далее. Взвешенная матрица позволяет отразить тот факт, что одна и та же территориальная единица может оказывать неодинаковое влияние на соседние единицы:
```{r, message = FALSE, results = "hide", collapse=TRUE}
Wstand<-nb2listw(polynei, style = "W")
M<-listw2mat(Wstand)

ramp <- colorRampPalette(c("white","red"))
levels <- 1/1:10  # шкала 1, 0.5, 0.33, 0.25 ... 0.1
levelplot(M, 
          main="Матрица весов (нормированная)", 
          at = levels, 
          col.regions=ramp(10))
```

> Обратите внимание, что на этот раз цвета в матрице распределены асимметрично.

Однако есть методы определения соседства, которые приведут также и к асимметричному виду самой матрицы, а не только значений. Например, при поиске соседей по количеству соседство A и B вовсе не означает соседство B и A. Проверим это на опыте:
```{r, message = FALSE, results = "hide", collapse=TRUE}
# Ближайшие соседи (k = 1)
knearnei<-knn2nb(knearneigh(coords,k=1))

Wstand<-nb2listw(knearnei, style = "B")
M<-listw2mat(Wstand)
levelplot(M, 
          main="Матрица весов (нормированная)", 
          at = levels, 
          col.regions=ramp(10))
```

Полученная матрица весов дает искомую меру потенциальной пространственной связи (близости) между всеми парами территориальных единиц. Сопоставив эту меру со значениями показателя, зафиксированными в тех же единицах, можно получить статистическую оценку пространственной автокорреляции изучаемой величины. Этим мы и займемся в следующем модуле.
