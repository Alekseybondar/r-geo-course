# Работа с таблицами {#tables}

```{r setup, echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
library(DT)
knitr::opts_knit$set(root.dir = "data/")
```

[Программный код главы](https://github.com/tsamsonov/r-geo-course/blob/master/code/04-TablesDataReading.R)

__Необходимые пакеты:__ `openxlsx, dplyr`

Таблица представляет собой один из способов структурирования данных. Большинство научных данных представляется именно в виде таблиц. В настоящем модуле рассмотрены базовые процедуры обработки таблиц, такие как чтение, сортировка, фильтрация, отбор столбцов (переменных), добавление и вычисление новых строк и столбцов, поиск и исправление ошибок в данных, запись таблиц в файл. Показано, как одни и те же процедуры могут быть реализованы стандартными средствами __R__ и с помощью пакета `dplyr`.

Напомним, что для представления таблиц в __R__ используются фреймы данных. В рамках данной главы мы будем использовать оба понятия как взаимозаменяемые, предполагая, что речь идет о таблице, представленной в виде фрейма данных.

## Чтение таблиц {#reading_tables}

Существует множество файловых форматов представления табличных данных. Мы рассмотрим одни из наиболее распространенных --- __CSV__ и __Microsoft Excel__.

### Таблицы CSV {#reading_csv}

__CSV (Comma-separated value)__ --- общее название для формата представления таблиц в виде текстовых файлов, организованных по следующему принципу:

1. Каждая строка в файле соответствует строке в таблице
2. Ячейки отделяются друг от друга символом-разделителем.
3. Если ячейка пустая, то между соседними разделителями не должно быть никаких символов.

Стандартным разделителем ячеек является запятая (`,`), а десятичным разделителем --- точка (`.`). Однако это не является строгим правилом.

Например, вот так выглядит таблица в формате CSV, с которой мы дальше будем работать:
```
Год;Всего;Балтийское;Черное;Азовское;Каспийское;Карское;Белое;Прочие
1993;27,2;2,5;0,4;4,3;12,1;5,3;1,0;1,6
1994;24,6;2,3;0,4;3,2;11,0;5,0;0,9;1,8
1995;24,5;2,3;0,4;3,5;10,4;5,2;0,9;1,8
1996;22,4;2,2;0,3;3,1;9,8;4,7;0,8;1,5
1997;23,0;2,2;0,3;3,8;9,8;4,4;0,8;1,7
```

Видно, что первая строка в файле занята заголовками столбцов. Формат CSV этот момент не обговаривает, поэтому при чтении таблицы нужно явным образом указывать, что данные начинаются со второй строки, а первую строку следует интерепретировать как заголовочную.

Также следует отметить, что в данном файле в качестве символа-разделителя ячеек используется точка с запятой (`;`), поскольку в русской локали запятая (`,`) зарезервирована под десятичный разделитель. Разделитель ячеек и десятичный разделитель также должны быть указаны при открытии файла, если они не соответствуют стандартным.

Таблицы в формате __CSV__ (Comma-Separated Values) можно прочесть как с помощью стандартных средств языка R, так и с помощью пакета `readr`. Рассмотрим оба варианта. 

Для чтения таблиц с разделителем существует функция стандартной бибилиотеки `read.table()`. Ее основные параметры следующие:

- `file` --- название файла
- `sep` --- разделитель ячеек
- `dec` --- десятичный разделитель
- `header` --- содержится ли в первой строке заголовок
— `encoding` --- кодировка символов, в которой сохранен файл (чаще всего `UTF-8` или `CP1251`)

> __Стандартной кодировкой для представления текста__ в UNIX-подобных системах (_Ubuntu_, _macOS_ и т.д.) является __UTF-8 (Unicode)__, в русскоязычных версиях _Windows_ --- __CP1251 (Windows-1251)__. Текстовый файл __CSV__, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в __R__ вы видите вместо текста нечитаемые символы --- _кракозябры_ --- то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Попробуйте поменять `UTF-8` на `CP1251` или наоборот. Если вы не знаете, что такое кодировка и Юникод, то вам [сюда](https://ru.wikipedia.org/wiki/Набор_символов).

Прочтем таблицу с данными Росстата по объему сброса сточных вод в бассейны некоторых морей России (в млн. м$^3$):
```{r readcsv, collapse=TRUE}
tab <- read.table("oxr_vod.csv",
                  sep = ';',
                  dec = ',',
                  header = TRUE,
                  encoding = 'UTF-8')
str(tab) # Посмотрим на структуру таблицы
```

Существуют также специальные функции для чтения таблиц __CSV__: `read.csv()` и `read.csv2()`. По сути они являются "обертками" (_wrappers_) функции `read.table()` и выполняют ее вызов с автоматической подстановкой параметров `sep`, `dec` и `header`. Обе функции по умолчанию предполагают, что в файле имеется заголовок. `read.csv()` удобна для чтения таблиц с десятичной точкой и запятой-разделителем, а `read.csv2()` --- для таблиц с десятичной запятой и точкой-с-запятой в качестве разделителя.

Используем для чтения `read.csv2()`:
```{r, collapse=TRUE}
tab <- read.csv2("oxr_vod.csv", encoding = 'UTF-8')
str(tab) # Посмотрим на структуру таблицы
```

Данная таблица не отличается от предыдущей, но ее чтение с помощью функции `read.csv2()` более компактно.

Помимо стандартной библиотеки вы можете читать таблицы CSV (и другие текстовые форматы) с помощью пакета `readr`. Одним из его преимуществ является то, что он читает таблицы примерно в 10 раз быстрее стандартной библиотеки. Аналогично стандартной библиотеки можно воспользоваться функцией `read_csv2()`. Отличие заключается только в том, что данная функция возвращает объект типа `tibble`, который является расширением фрейма данных. Если рабочий процесс предполагает использование фреймов данных, небходимо преобразовать результат к данному типу:

```{r, collapse=TRUE, message=FALSE}
library(readr)
tab <- as.data.frame(read_csv2("oxr_vod.csv"))
str(tab) # Посмотрим на структуру таблицы
```

### Таблицы Microsoft Excel {#excel_reading}

Чтение таблиц __Microsoft Excel__ не входит в возможности стандартной библиотеки R. В то же время, для этих целей существует ряд пакетов, таких как `xlsx`, `openxlsx` и `readxl`. Пакет `xlsx` требует наличия установленной среды __Java__ на компьютере, что несколько усложняет его использование. В нашей работе мы будем пользоваться пакетами `openxlsx` и `readxl`.

Для чтения таблицы пакетом `openxlsx` воспользуемся функцией `read.xlsx()`. В качестве обязательных параметров она принимает следующие аргументы:

- `xlsxFile` — название файла
- `sheet` — номер листа

Откроем таблицу с данными Росстата по сбросу загрязненных сточных вод в поверхностные водные объекты (млн м$^3$).
```{r, collapse=TRUE}
library(openxlsx) # Подключаем библиотеку
sewage <- read.xlsx("sewage.xlsx", 1) # Читаем таблицу из первого листа
str(sewage) # Посмотрим на структуру таблицы
```

Аналогичный порядок действий будет и с пакетом `readxl`, за тем исключением, что данная функция возвращает объект типа `tibble`, который является расширением фрейма данных. Если рабочий процесс предполагает использование фреймов данных, небходимо преобразовать результат к данному типу:
```{r, collapse=TRUE, warning=FALSE}
library(readxl)
sewage <- as.data.frame(read_excel("sewage.xlsx", 1))
str(sewage)
```

### Типы данных столбцов {#excel_read_types}

Особого внимания при чтении таблиц заслуживает тема управления типами данных столбцов. В процессе чтения таблицы __R__ будет пытаться привести каждый столбец к одному из базовых типов, рассмотренных в первой главе. Как правило, столбцы приводятся либо к числовому (`numeric`), либо к текстовому (`character`) типу. В то же время, в таблицах часто бывают пропущенные значения (нет данных), которые выражаются в виде пустых ячеек или специальных символов (например, `-`). Также могут быть опечатки и неверно заданные разделители десятичного разряда (например, запятая вместо точки). 

В этом контексте при чтении таблиц действуют следующие правила:

- По умолчанию типы данных столбцов определяются автоматически, если не задано иное.
- По умолчанию текстовые столбцы преобразуются функциями стандартной библиотки в факторы, а функциями из пакетов `readr`, `openxlsx` и `readxl` --- остаются текстовыми столбцами.
- Если типы данных определяются автоматически, и в процессе чтения в текущем столбце обнаруживается хотя бы один нечисловой символ, столбец будет автоматически преобразован к текстовому типу. 
- Если тип данных столбца задан пользователем как числовой, и в процессе чтения в нем обнаруживается хотя бы один нечисловой символ, импорт таблицы будет прерван и вы получите сообщение об ошибке.

Управлять типами данных в фрейме данных _гораздо проще на стадии чтения таблицы_, чем уже после того, как она прочитана неправильно (см. раздел исправление ошибок в конце настоящей главы). Отсюда вытекают следующие рекомендации при чтении таблиц:

- Если вы пользуетесь стандартной библиотекой для чтения таблиц с текстовыми столбцами, запретите интерпретировать их как факторы, если это нежелательное поведение.
- Если вам известна структура таблицы, и вы не уверены в полноте и корректности ее наполнения, определите сразу при ее чтении типы столбцов, так вы поймете, все ли в порядке с данными.

В качестве примера неправильно прочитанной таблицы приведем данные о типах землепользования на Сатинском учебном полигоне географического факультета МГУ:

```{r, collapse=TRUE}
tab2 <- read.csv2("SatinoLanduse.csv", dec = '.')
str(tab2) # посмотрим, какова структура данных
```
Видно, что правильно прочитаны только три столбца: `ID`, хранящий идентификаторы, `Type`, хранящий тип землепользования, являющийся номинальной переменной, а также `Perimeter`, хранящий периметр участка. Текстовые столбцы `Administration` и `Comment` были также преобразованы в факторы, поскольку это стандартное поведение базовых функций __R__, хотя номинальными переменными по сути не являются. А последний столбец с площадью и вовсе не был прочитан правильно, так как содержит опечатки.

Запретить интерепретировать строки как факторы можно с помощью параметра `stringsAsFactors=FALSE`:
```{r, collapse=TRUE}
tab2 <- read.csv2("SatinoLanduse.csv", dec = '.', stringsAsFactors = FALSE)
str(tab2) # посмотрим, какова структура данных
```

Функции из пакета `readr` делают это по умолчанию:
```{r, collapse=TRUE, message=FALSE}
tab2 <- as.data.frame(read_csv2("SatinoLanduse.csv"))
str(tab2) # посмотрим, какова структура данных
```

_Надежны надежный способ убедиться, что все данные прочитаны с нужным типом --- определить типы данных в столбцах._ Для функций базовой библиотеки R названия типов совпадают с названиями стандартных типов данных. Необходимо сформировать вектор из названий типов (по количеству столбцов) и передать его в качестве параметра `colClasses`:
```{r, collapse = TRUE, error=TRUE}
classes <- c("integer", "character", "character", "character", "numeric", "numeric")
tab2 <- read.csv2("SatinoLanduse.csv", 
                 dec = '.', 
                 stringsAsFactors = FALSE, 
                 colClasses = classes)
```
В данном случае последний столбец вызывает ошибку, что говорит о том, что содержищиеся в нем данные надо исправлять (см. параграф "Исправление ошибок" в конце главы).

## Просмотр таблицы {#view_table}

Для просмотра фрейма данных в консоли __RStudio__ вы можете использовать несколько опций. Пусть наш фрейм данных называется `tab`. Тогда:

1. `print(tab)` --- выводит фрейм в консоль целиком (можно написать просто `tab` в консоли).
2. `head(tab, n)` --- отбирает первые $n$ строк фрейма 
3. `tail(tab, n)` --- отбирает последние $n$ строк фрейма

По умолчанию для функций `head()` и `tail()` $n=6$. Обычно этот параметр опускают, поскольку нужно просмотреть только первые несколько строк и шести вполне достаточно. Если вы напечатаете в консоли `head(tab)` или `tail(tab)`, то для выбранных строк будет вызвана функция `print()`, аналогично выводу всего фрейма:
```{r, collapse=TRUE}
print(tab)
head(tab)
tail(tab)
```

`RStudio`, разумеется, имеет "человеческий" интерфейс для просмотра таблиц, в котором таблицу можно сортировать и фильтровать. Чтобы его активировать, надо вызвать функцию `View()`:
```{r, eval = FALSE, collapse=TRUE}
View(tab)
```
```{r, echo=FALSE, purl=FALSE}
datatable(tab, options = list(pageLength = 5))
```

Поскольку функции `head()` и `tail()` возвращают строки с хвоста или начала фрейма данных, их можно и подать на вход функции `View()`:

```{r, eval = FALSE, collapse=TRUE}
View(head(sewage, 3))
```
```{r, echo = FALSE, purl=FALSE}
datatable(head(sewage,3), options = list(pageLength = 5))
```

> __Как правило, не следует оставлять вызовы функции `View()` в тексте законченной программы.__ Это приведет к тому, что при запуске будут открываться новые вкладки с просмотром таблиц, что может раздражать пользователя (в том числе и вас самих). Используйте `View()` для вывода окончательного результата в конце программы или при отладке программы. Все вызовы `View()` в программе  можно легко закомментировать или раскомментировать, выполнив поиск с заменой `'View('` на `'# View('` и наоборот.

## Работа со столбцами {#working_with_columns}

### Названия столбцов {#colnames}

Для просмотра и изменения названий столбцов фрейма данных следует использовать функцию `colnames()`:
```{r, collapse=TRUE}
# Просмотрим текущие названия
colnames(sewage)
colnames(tab)

# Заменим их на новые
colnames(sewage) <- c("Region", "Year05", "Year10", "Year11", "Year12", "Year13")
colnames(tab) <- c("Year", "Total", "Baltic", "Black", "Azov", "Caspian", "Kara", "White", "Other")

# Проверим результат
colnames(sewage)
colnames(tab)
```

### Обращение к столбцам {#col_calling}

К столбцу можно обращаться по номеру и названию (с помощью оператора `$` или в кавычках внутри скобок). Если вы указываете в квадратных скобках номер без запятой, он трактуется именно как номер столбца, а не строки. Тип возвращаемого значения зависит от синтаксиса:

- обращение через `$` возвращает вектор;
- обращение в скобках с запятой к одному столбцу возвращает вектор;
- обращение в скобках с запятой к нескольким столбцам возвращает фрейм данных;
- обращение в скобках без запятой возвращает фрейм данных.

Несколько примеров:
```{r, collapse=TRUE}
a <- head(sewage)

# Один столбец - результат зависит от запятой
a$Year05      # столбец в виде вектора
a[, "Year05"] # столбец в виде вектора
a[, 2]        # столбец в виде вектора

a["Year05"] # столбец в виде фрейма данных
a[2]        # столбец в виде фрейма данных

# Несколько столбцов - всегда фрейм данных
a[, c(1, 4)]              # столбцы в виде фрейма данных
a[, c("Region", "Year11")]# столбцы в виде фрейма данных
a[c("Region", "Year11")]  # столбцы в виде фрейма данных
a[c(1, 4)]                # столбцы в виде фрейма данных

```

Использование необходимой формы зависит от контекста и ваших целей.

### Выбор и исключение столбцов {#col_select}

Можно создать новую таблицу, выбрав необходимые столбцы, как это показано выше:
```{r, collapse=TRUE}
# Создадим новый фрейм данных из трех необходимых столбцов:
caspian <- tab[c("Year", "Total", "Caspian")]
str(caspian)
```

Иногда проще создать новый фрейм данных, исключив из оригинала ненужные столбцы. Исключение делается с помощью знака '-', который ставится перед номером столбца. Например, вот так можно исключить из таблицы `tab` столбцы `Total` (2-й) и `Other` (9-й):
```{r, collapse=TRUE}
cleaned <- tab[c(-2, -9)]
str(cleaned)
```

Есть также способ _удалить столбец целиком_ (им пользуются довольно редко). Для этого необходимо записать в него значение `NULL`:
```{r, collapse=TRUE}
cleaned$Azov <- NULL
str(cleaned)
```

### Добавление и вычисление столбцов {col_add}

Существует простой способ создать новый столбец в таблице --- достаточно указать его название после значка `$`. Если среда R не обнаруживает столбец с таким названием, она его создаст:
```{r, collapse=TRUE}
caspian$CaspianRatio <- round(caspian$Caspian / caspian$Total, 3)
```
```{r, eval = FALSE, collapse=TRUE}
View(caspian)
```
```{r, echo = FALSE, purl=FALSE}
datatable(caspian, options = list(pageLength = 5))
```

_Тем не менее, такой метод добавления столбцов нельзя считать правильным_. Главный его недостаток --- из формы записи неочевидно, что мы добавляем новый столбец, а не перевычисляем уже существующий. Пакет `dplyr`, который мы рассмотрим в конце настоящей главы, решает эту и многие другие стилистические проблемы работы с фреймами данных.

Помимо того что вы можете вычислять столбцы традиционным способом как функцию от других столбцов, есть удобные функции-агрегаторы, позволяющие сделать вычисления по всем столбцам. Это `rowSums()` (сумма всех столбцов в строке) и `rowMeans()` (среднее по всем столбцам в строке). На тот случай, когда в ячейках есть пропущенные значения, в функциях предусмотрен параметр `na.rm = TRUE`.
```{r, collapse=TRUE}
years <- sewage[c(-1, -2)] # оставим данные с 2010 по 2013 гг

colSums(years)  # сколько всего было сброшено в каждом регионе за эти года
rowMeans(years) # сколько было сброшено в среднем за каждый год
```

Существуют также аналогичные им функции `colSums()` и `colMeans()`, осуществляющие агрегирование данных по столбцам, а не по строкам.

Перечисленные функции являются укороченной версией универсальных функций семейства `apply`, с которыми мы познакомимся далее.

## Сортировка и фильтрация {#filtering_sorting}

### Сортировка {#table_sorting}

Распространенные операции с таблицами — это упорядочение по определенному столбцу и фильтрация по значениям. Мы уже знаем что из вектора, матрицы или таблицы можно извлекать элементы: `tab[V, ]`, где `tab` --- имя таблицы, `V` --- это вектор из номеров элементов. Например, извлечь 5, 2 и 4 строку таблицы можно так:
```{r, collapse=TRUE}
tab[c(5,2,4), ]
```

Логично предположить, что таким же образом можно извлечь элементы таблицы в порядке, обеспечивающем возрастание или убывание значений в каком-то столбце. Для этого нужно правильным образом расставить индексы в векторе `c(...)`. Существует специальная функция `order()`, которая позволяет это сделать. Например, отсортируем таблицу по возрастанию сбросов в Каспийское море:
```{r, collapse=TRUE}
indexes<-order(tab$Caspian)
head(tab[indexes, ])
```

Если упорядочение несложное, программист его скорее всего вставит непосредственно в инструкцию обращения к таблице:
```{r, collapse=TRUE}
head(tab[order(tab$Caspian), ])
```

### Фильтрация {#table_filtering}

Схожим образом реализована _фильтрация данных_ по значению. Например, вы хотите извлечь из таблицы только те года, в которых объем сбросов в Каспийское море составил более 10 млн м$^3$. Здесь используется еще одна возможность извлечения элементов таблицы — с помощью вектора логических значений `TRUE/FALSE`. Число элементов в этом векторе должно быть равно числу элементов в индексируемом векторе, а значение указывает на то, нужно ли извлекать (`TRUE`) или нет (`FALSE`) элемент с текущим индексом. Вектор логических значений получается естественным путем с помощью операции сравнения:
```{r, collapse=TRUE}
condition <- tab$Caspian > 10
condition  # посмотрим что получилось
tab[condition, ] # используем его для фильтрации строк таблицы:
```

Опять же, весьма часто используется запись одним выражением:
```{r, collapse=TRUE}
tab[tab$Caspian > 10, ]
```

Часто бывает необходимо отобрать данные из таблицы, содержащей разнородные данные. В частности, в нашей таблице смешаны данные по субъектам и федеральным округам. Предположим, необходимо выгрузить в отдельную таблицу данные по федеральным округам. Для этого нужно найти строки, в которых столбец `Region` содержит фразу `"федеральный округ"`. Для поиска по текстовым эталонам импользуется функция `grep()`, выдающая номера элементов, или ее разновидность `grepl()`, выдающая список логических констант
```{r, collapse=TRUE}
# Первый параметр - искомое выражение, второй параметр - где искть
rows <- grep("федеральный округ",sewage$Region)
rows  # посмотрим, какие элементы столбца Region ему соответствуют
okruga <- sewage[rows,] # отфильтруем найденные строки
```
```{r, eval = FALSE, collapse=TRUE}
View(okruga)
```
```{r, echo = FALSE, purl=FALSE}
datatable(okruga, options = list(pageLength = 5))
```

Наоборот --- для __исключения__ найденных объектов удобнее воспользоваться разновидностью `grepl()`, которая возвращает вектор из логических значений:
```{r, collapse=TRUE}
rows2 <- grepl("федеральный округ", sewage$Region)
rows2 # вот так выглядит результат grepl

neokruga <- sewage[!rows2, ]
```
```{r, eval = FALSE, collapse=TRUE}
View(neokruga)
```
```{r, echo = FALSE, purl=FALSE}
datatable(neokruga, options = list(pageLength=5))
```

Обратите внимание на восклицательный знак перед `rows2`. Он меняет все значения `TRUE` на `FALSE` и наоборот, что позволяет исключить найденные объекты

В полученной таблице все еще содержится текстовая шелуха типа `"в том числе"`, `"Данные за..."`, а также строка `"Российская Федерация"`. К счастью, функция `grep()` достаточо умна и возволяет искать сразу по нескольким образцам строк. Для этого их нужно разделить вертикальной чертой — _пайпом_ (`|`):
```{r, collapse=TRUE}
rows2 <- grepl("федеральный|числе|Российская|за|ѕ", sewage$Region)
rows2
neokruga <- sewage[!rows2, ] # обратите внимание на восклицательный знак перед rows2
```
```{r, eval = FALSE, collapse=TRUE}
View(neokruga)
```
```{r, echo = FALSE, purl=FALSE}
datatable(neokruga, options = list(pageLength=5))
```

## Пропущенные значения {#missed_values}

Можно ли осуществлять обработку таблицы `sewage`? Попробуем в качестве примера найти минимум сбросов за 2012 год:
```{r, collapse=TRUE, error = TRUE}
max(sewage$Year12)
```

Результат имеет тип `NA`, потому что в данном столбце имеются пропуски. В некоторых статистических задачах это недопустимо. Если вы хотите проигнорировать значения пропусков, следует в вызываемой статистической функции указать дополнительный параметр `na.rm = TRUE`:
```{r, collapse=TRUE}
max(sewage$Year12, na.rm = TRUE)
```

Еще один вариант --- исключить из таблицы те строки, в которых имеются пропущенные значения (хотя бы одно!). Для этого существует функция `complete.cases()`, возвращающая вектор логических значений:
```{r, collapse=TRUE}
filter<-complete.cases(sewage)
filter  # посмотрим что получилось. Там где видим FALSE - есть пропуски в строках

sewage.complete <- sewage[filter, ] # отфильтруем полные строки
```
```{r, eval = FALSE, collapse=TRUE}
View(sewage.complete)
```
```{r, echo = FALSE, purl=FALSE}
datatable(sewage.complete, options = list(pageLength = 5))
```

## Преобразование типов и поиск ошибок {#data_conversion}

Достаточно часто при работе с реальными данными возникает необходимость преобразования их типов. Например, вам необходимо перевести строки в даты, чтобы оперировать ими соответствующим образом. Или принудительным образом указать, что столбец со строками не хранит номинальную переменную (фактор), а его нужно интерпретировать именно как строковый столбец (обычно это полезно, когда столбец содержит какую-то текстовую информацию в виде комментариев по каждому измерению). Наконец, в данных могут быть ошибки, опечатки и так далее, которые могут препятствовать правильному их чтению.

В этом разделе мы рассмотрим, как можно:

1. Найти и исправить множественные варианты одного названия с опечатками
2. Исправить ошибки в числовых данных
3. Преобразовать факторы в строки и наоборот
4. Преобразовать строки в числа и наоборот

Рассмотрим возможные манипуляции с данными на примере таблицы о землепользовании на территории Сатинского учебного полигоны Географического факультета МГУ:
```{r, collapse=TRUE}
tab <- read.csv2("SatinoLanduse.csv", encoding = 'UTF-8')
str(tab) # посмотрим, какова структура данных
```
```{r, eval = FALSE, collapse=TRUE}
View(tab)
```
```{r, echo = FALSE, purl=FALSE}
datatable(tab, options = list(pageLength = 5))
```

Видно, что все столбцы, кроме двух, хранящих идентификаторы, были прочитаны как строки и преобразованы в факторы (номинальные переменные). Это означает, что мы не сможем работать привычным образом со столбцами периметра и площади, а столбец комментариев теперь также является номинальной переменной, что противоречит здравому смыслу (он вообще переменной не является).

Когда вы отображаете таблицу в консоли или графическом интерфейсе, факторы выглядят и ведут себя как обычные строки. Подвох заключается в том, что хранятся они в виде пар "ключ — значение" (об этом мы говорили выше) и все операции преобразования осуществляются __над ключами__, а не значениями. Рассмотрим, как следует правильно преобразовывать номинальные переменные в __R__.

Чтобы привести столбцы к нужному типу, необходимо использовать преобразования типов. Для этого можно воспользоваться функциями семейства `as`, описанными в Главе 1.

Для начала преобразуем столбец `Comment` к обычному символьному представлению:
```{r, collapse=TRUE}
tab$Comment <- as.character(tab$Comment)
str(tab)
```

Посмотрим теперь, что произойдет, если мы попытаемся преобразовать столбец `Perimeter` к числовому виду:
```{r, collapse=TRUE}
as.numeric(tab$Perimeter)
```

Вместо значений перметра мы получили загадочные числа, которых в таблице нет. Это и есть ключи факторов. Чтобы получить их значения, необходимо использовать функцию `levels()` (для краткости выведем первые 10 значений):
```{r, collapse=TRUE}
levels(tab$Perimeter)[1:10]
```

Обратите внимание на то, что значения фактора отсортированы в алфавитном порядке, без учете порядка их встречаемости в исходной таблице. Для корректного преобразования факторов в числа необходимо сначала привести их к обычному строковому виду:
```{r, collapse=TRUE}
tab$Perimeter <- as.numeric(as.character(tab$Perimeter))
str(tab)

# Теперь попробуем преобразовать столбец Area
temp <- as.numeric(as.character(tab$Area))
temp[1:10]
```

Все прошло вроде бы успешно, но с предупреждением, что некоторые значения были преобразованы в `NA` (_Not Available_) --- отсутствующие значения. По всей видимости, данные в соответствущих ячейках не соответствуют представлениям __R__ о том, как должно выглядеть число: ячейка или пустая, или число набрано с ошибкой/опечаткой.

Чтобы найти и исправить все неверно заданные данные, необходимо выполнить следующие действия:

1. Получить индексы всех элементов, имеющих значение `NA`.
2. Просмотреть, какие значения были в исходных данных под этими индексами
3. Исправить ошибки в этих значениях, если это поддается автоматизации
4. Повторить конвертацию в числовой тип данных

Проверку на отсутствующие данные осуществляют с помощью функции `is.na()`. Передав ей в качестве аргумента вектор значений, вы получите вектор булевых значений, в котором `TRUE` будет стоять для пустых элементов. Проверим с помощью него, какие элементы столюца `Area` привели к ошибкам конвертации данных:
```{r, collapse=TRUE}
tab[is.na(temp), "Area"]
```

Видно, что __R__ не справился с преобразованием типов там, где содержится опечатка в десятичном разделителе --- вместо точки указана запятая. 

Для исправления этой ошибки мы можем воспользоваться стандартной функцией замены символа `gsub(pattern, replacement, x)`. Ее стандартные параметры означают соответственно: что искать, на что заменять, где искать:
```{r, collapse=TRUE}
tab$Area <- gsub(',', '.', tab$Area) # заменим запятые на точки
tab$Area <- as.numeric(as.character(tab$Area)) # Теперь можно преобразовать в числа
str(tab)
```

Теперь необходимо навести порядок в значениях факторов, убедившись, что и там нет опечаток. Выведем все уникальные значения с помощью функции `levels()`:
```{r, collapse=TRUE}
levels(tab$Type)
levels(tab$Administration)
```
Видно, что если с типами все в порядке, то в данных об административном подчинении содержится 5 вариантов названия одной и той же Совьяковской сельской администрации. Помимо этого, пустые ячейки хорошо бы заменить на значение `"Прочее"`.

Чтобы найти все строчки, относящиеся к одному и тому же объекту, можно воспользоваться уже знакомой нам функцией `grep()`, передав ей подстроку, которая является для них общей. Например, `"Совьяковская"` (хотя в данном случае было бы вообще достаточно одной буквы `"с"`).
```{r, collapse=TRUE}
filter <- grep("Совьяковская", tab$Administration) # Найдем все записи
tab[filter, "Administration"] <- "Совьяковская сельская администрация" # Заменим их одним значением
tab$Administration <- droplevels(tab$Administration) # Удаляем неиспользуемые уровни
levels(tab$Administration)
```

Пустые строки можно также найти c помощью `grep()`, но мы этого делать не будем, так как это требует дополнительных знаний о регулярных выражениях. Вместо этого воспользуемся тем, что пустые строки имеют длину 0. Обратите внимание ниже, что преобразование в вектор столбца `Administration` необходимо, т.к. `nchar()` не понимает объекты типа `data.frame`, которыми являются не только таблицы, но и их столбцы:
```{r, collapse = TRUE, error=TRUE}
filter <- nchar(as.vector(tab$Administration)) == 0 # TRUE если длина равна 0
# Пробуем заменить:
tab[filter, "Administration"] <- "Прочее"
```

Ошибка выше связана с тем, что __R__ строго следит за неизменностью набора значений фактора для того чтобы избежать всевозможных ошибок при работе с данными (опечаток и т.д.). Предыдущий раз мы заменили все значаниея одним из существующих. В данном случае необходимо ввести новое значение фактора. Чтобы это сделать, придется преобразовать данные в символьные, произвести замену срок и после этого снова конвертировать столбец в фактор:
```{r, collapse=TRUE}
tab$Administration <- as.character(tab$Administration)
tab[filter, "Administration"] <- "Прочее"
tab$Administration <- as.factor(tab$Administration)
levels(tab$Administration)
```

Теперь таблица готова к работе. Можно, например, подсчитать по ней сводную статистику:
```{r, collapse=TRUE}
summary(tab)
```
Обратите внимание, что строки, интервальные и номинальные (факторы) переменные обрабатываются функцией `summary()` по-разному.

## Сохранение таблиц {#table_writing}

Одной из завершающих стадий анализа данных, помимо графиков и отчетов, часто являются новые табличные представления, которые было бы неплохо сохранить в виде файлов. К счастью, сохранение таблиц в __R__ столь же просто, как и чтение. Для текстовых файлов в формате __CSV__ можно использовать функции `write.table()`, `write.csv()` и `write.csv2()`. Для файлов __Microsoft Excel__ используйте функцию `write.xlsx()` из пакета `openxlsx` соответственно. 

> __По умолчанию функции `write.table()`, `write.csv()` и `write.csv2()` записывают в таблицы в качестве первого столбца названия (номера) строк таблиц.__ Если вы не хотите, чтобы это происходило, укажите дополнительный параметр `row.names=FALSE`.

Сохраним таблицы `okruga` и `neokruga`, раздельно хранящие статистику по объему сброса сточных в поверхностные водные объекты по федеральным округам и субъектам соответственно:
```{r, collapse=TRUE}
write.csv2(okruga, "okruga.csv", fileEncoding = 'UTF-8') # Сохраним первую таблицу в CSV в кодировке Unicode
write.xlsx(neokruga, "neokruga.xlsx") # Сохраним вторую таблицу в XLSX без названий строк

# Проверим, все ли в порядке с сохраненными таблицами:

okruga.saved <- read.csv2("okruga.csv", encoding = 'UTF-8')
head(okruga.saved)

neokruga.saved <- read.xlsx("neokruga.xlsx",1)
head(neokruga.saved)
```

Видно, что в файле __CSV__ присутствует также дополнительный столбец с названиями строк, а в файле __XLSX__ его нет. Если вы не задавали названия строк явным образом и они не несут какого-то смысла, всегда указывайте параметр `row.names=FALSE`

> __Вы можете дать строкам таблицы названия и извлечь их, используя функцию `row.names()`__ аналогично функции `colnames()` для столбцов.

## Обработка таблиц в dplyr {#table_rules}

## Правила подготовки таблиц для чтения в R {#table_rules}

С таблицами, которые мы использовали в настоящем модуле, все прошло гладко, поскольку они были подготовлены специальным образом. Несмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу:

1. В первой строке таблицы должны располагаться названия столбцов.
1. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.
1. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.
1. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: `Валовый внутренний продукт за 2015 г.`. Хорошее название столбца: `GDP2015`.
1. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в __R__.

Следование этим правилам значительно облегчит работу с табличными данными.

## Контрольные вопросы и задачи {#questions_tasks_tables}

### Вопросы {#questions_tables}

### Задачи {#tasks_tables}

----
_Самсонов Т.Е._ **Визуализация и анализ географических данных на языке R.** М.: Географический факультет МГУ, 2017. DOI: 10.5281/zenodo.901911
----