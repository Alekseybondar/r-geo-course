# Чтение и предварительная обработка таблиц из файлов {#tables}

Данный модуль посвящен введению в работу с таблицами. В модуле рассмотрены важные процедуры предварительной обработки таблиц, такие как фильтрация, исправление ошибок, преобразование типов --- необходимые для дальнейшей визуализации и анализа данных

## Установка и подключение пакетов

Наиболее распространенные форматы таблиц, с которыми приходится работать — это __CSV__ и __XLS/XLSX__. Чтение файлов __CSV__ входит в стандартный набор функций __R__. По умолчанию __RStudio__ содержит базовый набор пакетов, который позволяет осуществлять основные операции по чтению, статистическому анализу и визуализации данных.  Для работы с таблицами __Microsoft Excel__ и табличными данными в других форматах необходима установка дополнительных пакетов (библиотек). Прежде чем приступать к работе с файловыми таблицами, познакомимся с установкой и подключением пакетов.

Существует [множество](https://cran.r-project.org/web/packages/) дополнительных пакетов R (вы тоже можете написать свой) практически на все случаи жизни. Как и дистрибутив R, они доступны через [CRAN (Comprehensive R Archive Network)](https://cran.r-project.org). Одним из таких пакетов является `xlsx`, позволяющий читать и записывать файлы в форматах __Microsoft Excel__.

Существует два способа установки пакетов в __RStudio__. 

Во-первых, вы можете сделать это в графическом интерфесе, нажав кнопку _Install_ на панели _Packages_ (по умолчанию эта панель расположена в нижней правой четверти окна программы). В появившемся окне введите название пакета и нажмите _Install_:

![_Установка пакета_](images/InstallPackages.png)

Во-вторых, вы можете вызвать _из консоли_ команду `install.packages()`, передав ей в качестве параметра название пакета, заключенное в кавычки:
```{r, eval=FALSE, purl=FALSE}
install.packages("xlsx")
```

> Внимание: никогда не включайте команду `install.packages()` в тело скрипта. Это приведет к тому, что каждый раз при запуске программы среда __RStudio__ будет пытаться заново установить пакет, который уже установлен. Запускайте эту функцию _только из консоли_.

> Если по каким-то причинам вы не можете установить пакет в стандартную системную директорию __RStudio__ (например, из-за политик безопасности, запрещающих запись в каталог _Program Files_ на ОС __Windows__), то необходимо создать директорию вручную в другом месте (куда вы имеете полный доступ) и указать ее адрес в параметре `lib` функции `install.packages()`. Например: `install.packages("xlsx", lib = "C:/Rlib/")`

Подключение пакета осуществляется с помощью функции `library()`, при этом название пакета можно в кавычки не заключать:
```{r, collapse=TRUE}
library(xlsx)
```

> Если пакет установлен не в стандартный каталог, а в другое место --- например, в каталог `С:/Rlib/` (см. выше) --- то при вызове функции `library()` необходимо указать местоположение пакета в дополнительном параметре `lib.loc`: `library(xlsx, lib.loc = "C:/Rlib")`

Выполните установку и подключение пакета `xlsx`, используя вышеприведенные инструкции.

## Установка рабочей директории

Прежде чем мы начнем работать с данными, необходимо установить рабочую директорию. Это папка, в которой лежат необходимые вам таблицы. Для этого используем функцию `setwd()`. Аргумент функции нужно заменить на адрес каталога на вашем компьютере, в который вы положили присланные файлы:
```{r, collapse=TRUE}
setwd("/Volumes/Dropbox/Dropbox/R/Lectures/Scripts/RMarkdown")
```

> Внимание: если вы выполняете данный модуль на своем компьютере, замените вышеуказанный путь на путь к каталогу, в который вы положили исходные данные.

Теоретически рабочую директорию можно и не устанавливать, однако тогда при чтении файлов вам придется каждый раз указывать полный путь, что неудобно.

> Рабочая директория и местоположение скрипта могут не совпадать. Вы можете хранить их в разных местах. Однако рекомендуется держать их вместе, что облегчит передачу вашей программы вместе с данными другим пользователям.

## Чтение таблиц CSV

Таблицы в формате __CSV__ (Comma-Separated Values) можно прочесть с помощью универсальной функции `read.table()`. Следующие ее параметры важно указать:

- `file` --- название файла
- `sep` --- разделитель ячеек
- `dec` --- десятичный разделитель
- `header` --- содержится ли в первой строке заголовок
— `encoding` --- кодировка символов, в которой сохранен файл (чаще всего `UTF-8` или `CP1251`)

> Стандартной кодировкой для представления текста в UNIX-подобных системах (_Ubuntu_, _macOS_ и т.д.) является __UTF-8 (Unicode)__, в русскоязычных версиях _Windows_ --- __CP1251 (Windows-1251)__. Текстовый файл __CSV__, созданный в разных операционных системах, будет по умолчанию сохраняться в соответствующей кодировке, если вы не указали ее явным образом. Если при загрузке таблицы в __R__ вы видите вместо текста нечитаемые символы --- _кракозябры_ --- то, скорее всего, вы читаете файл не в той кодировке, в которой он был сохранен. Попробуйте поменять `UTF-8` на `CP1251` или наоборот. Если вы не знаете, что такое кодировка и Юникод, то вам [сюда](https://ru.wikipedia.org/wiki/Набор_символов).

Прочтем таблицу с данными Росстата по объему сброса сточных вод в бассейны некоторых морей России (в млн. м$^3$):
```{r, collapse=TRUE}
t<-read.table("oxr_vod.csv", 
              sep = ';', 
              dec = ',', 
              header = TRUE, 
              encoding = 'UTF-8')
```

Для просмотра таблицы в привычном виде воспользуйтесь функцией `View()`. В этом представлении вы можете фильтровать и сортировать данные:
```{r, collapse=TRUE}
View(t)
```
```{r, echo = FALSE, purl=FALSE}
datatable(t, options = list(pageLength = 5))
```
Существуют более специальные функции для чтения таблиц __CSV__: `read.csv()` и `read.csv2()`. По сути они являются "обертками" (_wrappers_) функции `read.table()` и выполняют ее вызов с автоматической подстановкой параметров `sep`, `dec` и `header`. Обе функции по умолчанию предполагают, что в файле имеется заголовок. `read.csv()` удобна для чтения таблиц с десятичной точкой и запятой-разделителем, а `read.csv2()` --- для таблиц с десятичной запятой и точкой-с-запятой в качестве разделителя.

Используем для чтения `read.csv2()`:
```{r, collapse=TRUE}
t2<-read.csv2("oxr_vod.csv", encoding = 'UTF-8')
View(t2)
```
```{r, echo = FALSE, purl=FALSE}
datatable(t2, options = list(pageLength = 5))
```
Как видно, данная таблица не отличается от предыдущей, но ее чтение более компактно.

## Фильтрация, сортировка, работа с элементами таблицы

Распространенные операции с таблицами — это упорядочение по определенному столбцу и фильтрация по значениям. Мы уже знаем что из вектора, матрицы или таблицы можно извлекать элементы: `t[V, ]`, где `t` --- имя таблицы, `V` --- это вектор из номеров элементов. Например, извлечь 5, 2 и 4 строку таблицы можно так:
```{r, collapse=TRUE}
t[c(5,2,4), ]
```
Логично предположить, что таким же образом можно извлечь элементы таблицы в порядке, обеспечивающем возрастание или убывание значений в каком-то столбце. Для этого нужно правильным образом расставить индексы в векторе `c(...)`. Существует специальная функция `order()`, которая позволяет это сделать. Например, отсортируем таблицу по возрастанию сбросов в Каспийское море:
```{r, collapse=TRUE}
indexes<-order(t$Каспийское)
head(t[indexes, ])
```

> Используйте функцию `head()`, чтобы отобразить первые несколько строк таблицы. Эта возможность особенно полезна при работе с большими таблицами

Если упорядочение несложное, программист его скорее всего вставит непосредственно в инструкцию обращения к таблице:
```{r, collapse=TRUE}
head(t[order(t$Каспийское), ])
```
Схожим образом реализована _фильтрация данных_ по значению. Например, вы хотите извлечь из таблицы только те года, в которых объем сбросов в Каспийское море составил более 10 млн м$^3$. Здесь используется еще одна возможность извлечения элементов таблицы — с помощью вектора логических значений `TRUE/FALSE`. Число элементов в этом векторе должно быть равно числу элементов в индексируемом векторе, а значение указывает на то, нужно ли извлекать (`TRUE`) или нет (`FALSE`) элемент с текущим индексом. Вектор логических значений получается естественным путем с помощью операции сравнения:
```{r, collapse=TRUE}
condition <- t$Каспийское > 10
condition  # посмотрим что получилось
t[condition, ] # используем его для фильтрации строк таблицы:
```
Опять же, весьма часто используется запись одним выражением:
```{r, collapse=TRUE}
t[t$Каспийское > 10, ]
```
Можно создать новую таблицу, выбрав необходимые столбцы:
```{r, collapse=TRUE}
caspian <- data.frame(t$Год, t$Всего, t$Каспийское)
```
Следует заметить, что не рекомендуется использовать кириллические названия столбцов (см. [Правила подготовки таблиц для чтения в R] в конце данного модуля), поэтому переименуем их:
```{r, collapse=TRUE}
colnames(caspian)<-c("Year", "Total", "Caspian")
```
Предположим, что теперь нам необходимо вычислить долю сбросов в Каспийское море в общем объеме и записать ее в новый столбец с точностью до 3 знаков после запятой. Для этого сначала произведем вычисления:
```{r, collapse=TRUE}
ratio <- caspian$Caspian / caspian$Total
ratio
```
Далее округлим результат с помощью функции `round()` с параметром `digits`, указывающим число значащих цифр в ответе:
```{r, collapse=TRUE}
ratio <- round(ratio, digits = 3)
ratio
```
Существует простой и элегантный способ создать новый столбец в таблице --- достаточно указать его название после значка `$`. Если среда R не обнаруживает столбец с таким названием, она его создаст:
```{r, collapse=TRUE}
caspian$CaspianRatio <- ratio
View(caspian)  # смотрим, что получилось
```
```{r, echo = FALSE, purl=FALSE}
datatable(caspian, options = list(pageLength = 5))
```
К столбцу таблицы можно обращаться по номеру, а не названию. Если вы указываете в квадратных скобках номер без запятой, он трактуется как номер столбца. При этом возвращаемый столбец имеет тип `data.frame`:
```{r, collapse=TRUE}
head(caspian[2])  # второй столбец (фактически — таблица из одного столбца)
head(caspian[c(1,4)])  # первый и четвертый столбец
```
В противоположность этому, более привычная форма обращения к двумерным данным через запятую приведет к тому, что столбец будет возвращен как вектор:
```{r, collapse=TRUE}
caspian[,2]
```
Использование той или иной формы зависит от контекста.

## Чтение таблиц Microsoft Excel

Чтение таблиц __Microsoft Excel__ производится с помощью функции `read.xlsx()` или `read.xlsx2()` из пакета `xlsx`. В качестве обязательных параметров они принимают следующие аргументы:

- `file` — название файла
- `sheetIndex` — номер листа

Убедитесь, что у вас установлена и подключена библиотека `xlsx`. Мы будем использовать функцию `read.xlsx2()`, поскольку она умеет работать с кириллическими данными. 

Откроем таблицу с данными Росстата по сбросу загрязненных сточных вод в поверхностные водные объекты (млн м$^3$).
```{r, collapse=TRUE}
sewage<-read.xlsx2("sewage.xlsx",1) # Читаем таблицу из первого листа
View(sewage)
```
```{r, echo = FALSE, purl=FALSE}
datatable(sewage, options = list(pageLength = 5))
```
Следует дать адекватные названия столбцам таблицы:
```{r, collapse=TRUE}
colnames(sewage) <- c("Region", "Year05", "Year10", "Year11", "Year12", "Year13")
View(sewage) # просмотрим содержание таблицы
```
```{r, echo = FALSE, purl=FALSE}
datatable(sewage, options = list(pageLength = 5))
```

## Типы данных и пропущенные значения

Можно ли осуществлять обработку таблицы `sewage`? Попробуем в качестве примера найти минимум сбросов за 2012 год:
```{r, collapse=TRUE, error = TRUE}
min(sewage$Year12)
```
Cкорее всего вы получите ошибку наподобие `"min не значимо для факторов"`. Что здесь произошло? Необходимо посмотреть развернутую информацию о таблице. Это позволяет сделать универсальная функция `str()`:
```{r, collapse=TRUE}
str(sewage)
```
Мы видим, что все данные были интерпретированы как номинальные (факторы), а их значения хранятся в виде строк. Почему это произошло? Откройте еще раз таблицу и обратите внимание на то, что в ней содержатся пустые клеточки. Пустая клетка интерпретируется как пустая строка --- `""`. Если при чтении столбца обнаружится, что он содержит хотя бы одно строковое значение (пустую клетку, знак пропуска `-` и т.п.), то столбец будет помечен как состоящий из строк и __R__ будет его считать фактором. 

Если кратко резюмировать, то при чтении таблиц __R__ без дополнительных параметров ведет себя следующим образом:

1. Если в столбце встречаются пустые ячейки или ячейки с символами, которые не могут встречаться в числовых данных (интервальных), то столбец считается состоящим из строковых значений.
2. Если столбец прочитан как строковый, он преобразуется в номинальную переменную --- фактор. При этом каждому уникальному значению присваивается свой номер и столбец хранится в виде пар `ключ = значение`, где ключ --- это присвоенный номер, а значение --- строка, хранящаяся в ячейке.

> Если вы не хотите, чтобы строковые столбцы вашей таблицы при чтении из файла преобразовывались в номинальные переменные, то при запуске функций `read.table()`, `read.csv()`, `read.xlsx()` и им подобных укажите параметр `stringsAsFactors = FALSE`. По умолчаню этот параметр равен `TRUE`, так как предполагается, что текстовая информация в статистических таблицах содержит качественные характеристики объектов, которые можно интерпретировать как номинальные переменные.

К счастью, при чтении таблицы можно явным образом указать типы столбцов, указав параметр `colClasses = `. В этом случае все данные, не соответствующие указанным типам, будут интерпретированы как пропуски (`NA`).

Cоздадим вектор из типов столбцов. Допустимые классы — `logical`, `integer`, `numeric`, `complex`, `character` и `raw`. Класс `numeric` необходимо использовать для чисел с плавающей точкой, `integer` — для целых чисел, а `character` — для строковых данных. Всего 6 столбцов, 1 строковых и 5 числовых:
```{r, collapse=TRUE}
classes <- c("character", "numeric", "numeric", "numeric", "numeric", "numeric")
```
Используем его для чтения таблицы и повторим все прочие инструкции:
```{r, collapse=TRUE}
sewage <- read.xlsx2("sewage.xlsx", 1, colClasses = classes)
colnames(sewage) <- c("Region", "Year05", "Year10", "Year11", "Year12", "Year13")
str(sewage)
View(sewage)
```
```{r, echo = FALSE, purl=FALSE}
datatable(sewage, options = list(pageLength = 5))
```
Обратите теперь внимание на то что в полученной таблице вместо пропущенных клеток появились значения `NA` — теперь система знает, что это пропуски.

Можно попробовать рассчитать статистику:
```{r, collapse=TRUE}
min(sewage$Year13)
```
Результат имеет тип `NaN`, потому что в данном столбце имеются пропуски. В некоторых статистических задачах это недопустимо. Если вы хотите проигнорировать значения пропусков, следует в вызываемой статистической функции указать дополнительный параметр `na.rm = TRUE`:
```{r, collapse=TRUE}
min(sewage$Year13, na.rm = TRUE)
```
Еще один вариант --- исключить из таблицы те строки, в которых имеются пропущенные значения (хотя бы одно!). Для этого существует функция `complete.cases()`, возвращающая вектор логических значений:
```{r, collapse=TRUE}
filter<-complete.cases(sewage)
filter  # посмотрим что получилось. Там где видим FALSE - есть пропуски в строках

sewage.complete <- sewage[filter, ] # отфильтруем полные строки
View(sewage.complete)
```
```{r, echo = FALSE, purl=FALSE}
datatable(sewage.complete, options = list(pageLength = 5))
```
Поскольку мы уже умеем фильтровать данные по значению, то легко получить не только, скажем, минимальный объем сбросов, но и субъект(ы),  которые ему соответствуют:
```{r, collapse=TRUE}
minvalue<-min(sewage.complete$Year13)
sewage.complete[sewage.complete$Year13 == minvalue, ]
```
Потренируемся в формировании информационных сообщений:
```{r, collapse=TRUE}
# Отбираем название региона
region <- sewage.complete[sewage.complete$Year13 == minvalue, ]$Region
# Заготавливаем фразу:
s <- paste("Минимальный объем сброса загрязненных сточных вод по регионам России в 2013 году составил", minvalue, "млн.куб.м. в субъекте:", region)
 # выводим все на экран:
cat(s)
```

## Фильтрация по текстовым полям

Часто бывает необходимо отобрать данные из таблицы, содержащей разнородные данные. В частности, в нашей таблице смешаны данные по субъектам и федеральным округам. Предположим, необходимо выгрузить в отдельную таблицу данные по федеральным округам. Для этого нужно найти строки, в которых столбец `Region` содержит фразу `"федеральный округ"`. Для поиска по текстовым эталонам импользуется функция `grep()`, выдающая номера элементов, или ее разновидность `grepl()`, выдающая список логических констант
```{r, collapse=TRUE}
# Первый параметр - искомое выражение, второй параметр - где искть
rows <- grep("федеральный округ",sewage$Region)
rows  # посмотрим, какие элементы столбца Region ему соответствуют
okruga <- sewage[rows,] # отфильтруем найденные строки
View(okruga)  # и - вуаля!
```
```{r, echo = FALSE, purl=FALSE}
datatable(okruga, options = list(pageLength = 5))
```
Наоборот --- для __исключения__ найденных объектов удобнее воспользоваться разновидностью `grepl()`, которая возвращает вектор из логических значений:
```{r, collapse=TRUE}
rows2 <- grepl("федеральный округ",sewage$Region)
rows2 # вот так выглядит результат grepl

neokruga <- sewage[!rows2,]
View(neokruga)
```
```{r, echo = FALSE, purl=FALSE}
datatable(neokruga, options = list(pageLength = 5))
```
Обратите внимание на восклицательный знак перед `rows2`. Он меняет все значения `TRUE` на `FALSE` и наоборот, что позволяет исключить найденные объекты

В полученной таблице все еще содержится текстовая шелуха типа `"в том числе"`, `"Данные за..."`, а также строка `"Российская Федерация"`. К счастью, функция `grep()` достаточо умна и возволяет искать сразу по нескольким образцам строк. Для этого их нужно разделить вертикальной чертой — _пайпом_ (`|`):
```{r, collapse=TRUE}
rows2 <- grepl("федеральный|числе|Российская|за|ѕ",sewage$Region)
rows2
neokruga <- sewage[!rows2,] # обратите внимание на восклицательный знак перед rows2
View(neokruga)
```
```{r, echo = FALSE, purl=FALSE}
datatable(neokruga, options = list(pageLength = 5))
```

## Преобразование типов данных и исправление ошибок

Достаточно часто при работе с реальными данными возникает необходимость преобразования их типов. Например, вам необходимо перевести строки в даты, чтобы оперировать ими соответствующим образом. Или принудительным образом указать, что столбец со строками не хранит номинальную переменную (фактор), а его нужно интерпретировать именно как строковый столбец (обычно это полезно, когда столбец содержит какую-то текстовую информацию в виде комментариев по каждому измерению). Наконец, в данных могут быть ошибки, опечатки и так далее, которые могут препятствовать правильному их чтению.

В этом разделе мы рассмотрим, как можно:

1. Найти и исправить множественные варианты одного названия с опечатками
2. Исправить ошибки в числовых данных
3. Преобразовать факторы в строки и наоборот
4. Преобразовать строки в числа и наоборот

Рассмотрим возможные манипуляции с данными на примере таблицы о землепользовании на территории Сатинского учебного полигоны Географического факультета МГУ:
```{r, collapse=TRUE}
t <- read.csv2("SatinoLanduse.csv", encoding = 'UTF-8')
str(t) # посмотрим, какова структура данных
View(t)
```
```{r, echo = FALSE, purl=FALSE}
datatable(t, options = list(pageLength = 5))
```
Видно, что все столбцы, кроме двух, хранящих идентификаторы, были прочитаны как строки и преобразованы в факторы (номинальные переменные). Это означает, что мы не сможем работать привычным образом со столбцами периметра и площади, а столбец комментариев теперь также является номинальной переменной, что противоречит здравому смыслу (он вообще переменной не является).

Когда вы отображаете таблицу в консоли или графическом интерфейсе, факторы выглядят и ведут себя как обычные строки. Подвох заключается в том, что хранятся они в виде пар "ключ — значение" (об этом мы говорили выше) и все операции преобразования осуществляются __над ключами__, а не значениями. Рассмотрим, как следует правильно преобразовывать номинальные переменные в __R__.

Чтобы привести столбцы к нужному типу, необходимо использовать преобразования типов. Для этого в __R__ существует множество функций семейства `as(object,class)`, где в качестве первого параметра `object` вы указываете преобразуемый объект, а в качестве второго параметра `class` --- тип, к которому вы хотите его привести. Например:
```{r, error=TRUE, collapse=TRUE}
s <- "5456.788"
s + 1
n <- as(s, "numeric")
n + 1
s <- as(n, "character")
s
nchar(s)
```
На практике обычно пользуются не функцией `as()`, а ее обертками (_wrappers_), которые имеют вид `as.numeric()`, `as.character()`, `as.Date()` и так далее:
```{r, collapse=TRUE}
as.numeric(s) # то же самое, что и as(s, "numeric")
```
Для начала преобразуем столбец `Comment` к обычному символьному представлению:
```{r, collapse=TRUE}
t$Comment <- as.character(t$Comment)
str(t)
```
Посмотрим теперь, что произойдет, если мы попытаемся преобразовать столбец `Perimeter` к числовому виду:
```{r, collapse=TRUE}
as.numeric(t$Perimeter)
```
Вместо значений перметра мы получили загадочные числа, которых в таблице нет. Это и есть ключи факторов. Чтобы получить их значения, необходимо использовать функцию `levels()` (для краткости выведем первые 10 значений):
```{r, collapse=TRUE}
levels(t$Perimeter)[1:10]
```
Обратите внимание на то, что значения фактора отсортированы в алфавитном порядке, без учете порядка их встречаемости в исходной таблице. Для корректного преобразования факторов в числа необходимо сначала привести их к обычному строковому виду:
```{r, collapse=TRUE}
t$Perimeter <- as.numeric(as.character(t$Perimeter))
str(t)

# Теперь попробуем преобразовать столбец Area
temp <- as.numeric(as.character(t$Area))
temp[1:10]
```
Все прошло вроде бы успешно, но с предупреждением, что некоторые значения были преобразованы в `NA` (_Not Available_) --- отсутствующие значения. По всей видимости, данные в соответствущих ячейках не соответствуют представлениям __R__ о том, как должно выглядеть число: ячейка или пустая, или число набрано с ошибкой/опечаткой.

Чтобы найти и исправить все неверно заданные данные, необходимо выполнить следующие действия:

1. Получить индексы всех элементов, имеющих значение `NA`.
2. Просмотреть, какие значения были в исходных данных под этими индексами
3. Исправить ошибки в этих значениях, если это поддается автоматизации
4. Повторить конвертацию в числовой тип данных

Проверку на отсутствующие данные осуществляют с помощью функции `is.na()`. Передав ей в качестве аргумента вектор значений, вы получите вектор булевых значений, в котором `TRUE` будет стоять для пустых элементов. Проверим с помощью него, какие элементы столюца `Area` привели к ошибкам конвертации данных:
```{r, collapse=TRUE}
t[is.na(temp), "Area"]
```
Видно, что __R__ не справился с преобразованием типов там, где содержится опечатка в десятичном разделителе --- вместо точки указана запятая. 

Для исправления этой ошибки мы можем воспользоваться стандартной функцией замены символа `gsub(pattern, replacement, x)`. Ее стандартные параметры означают соответственно: что искать, на что заменять, где искать:
```{r, collapse=TRUE}
t$Area <- gsub(',', '.', t$Area) # заменим запятые на точки
t$Area <- as.numeric(as.character(t$Area)) # Теперь можно преобразовать в числа
str(t)
```
Теперь необходимо навести порядок в значениях факторов, убедившись, что и там нет опечаток. Выведем все уникальные значения с помощью функции `levels()`:
```{r, collapse=TRUE}
levels(t$Type)
levels(t$Administration)
```
Видно, что если с типами все в порядке, то в данных об административном подчинении содержится 5 вариантов названия одной и той же Совьяковской сельской администрации. Помимо этого, пустые ячейки хорошо бы заменить на значение `"Прочее"`.

Чтобы найти все строчки, относящиеся к одному и тому же объекту, можно воспользоваться уже знакомой нам функцией `grep()`, передав ей подстроку, которая является для них общей. Например, `"Совьяковская"` (хотя в данном случае было бы вообще достаточно одной буквы `"с"`).
```{r, collapse=TRUE}
filter <- grep("Совьяковская", t$Administration) # Найдем все записи
t[filter, "Administration"] <- "Совьяковская сельская администрация" # Заменим их одним значением
t$Administration <- droplevels(t$Administration) # Удаляем неиспользуемые уровни
levels(t$Administration)
```
Пустые строки можно также найти c помощью `grep()`, но мы этого делать не будем, так как это требует дополнительных знаний о регулярных выражениях. Вместо этого воспользуемся тем, что пустые строки имеют длину 0. Обратите внимание ниже, что преобразование в вектор столбца `Administration` необходимо, т.к. `nchar()` не понимает объекты типа `data.frame`, которыми являются не только таблицы, но и их столбцы:
```{r, collapse = TRUE, error=TRUE}
filter <- nchar(as.vector(t$Administration)) == 0 # TRUE если длина равна 0
# Пробуем заменить:
t[filter, "Administration"] <- "Прочее"
```
Ошибка выше связана с тем, что __R__ строго следит за неизменностью набора значений фактора для того чтобы избежать всевозможных ошибок при работе с данными (опечаток и т.д.). Предыдущий раз мы заменили все значаниея одним из существующих. В данном случае необходимо ввести новое значение фактора. Чтобы это сделать, придется преобразовать данные в символьные, произвести замену срок и после этого снова конвертировать столбец в фактор:
```{r, collapse=TRUE}
t$Administration <- as.character(t$Administration)
t[filter, "Administration"] <- "Прочее"
t$Administration <- as.factor(t$Administration)
levels(t$Administration)
```
Теперь таблица готова к работе. Можно, например, подсчитать по ней сводную статистику:
```{r, collapse=TRUE}
summary(t)
```
Обратите внимание, что строки, интервальные и номинальные (факторы) переменные обрабатываются функцией `summary()` по-разному.

## Сохранение таблиц CSV и Microsoft Excel

Одной из завершающих стадий анализа данных, помимо графиков и отчетов, часто являются новые табличные представления, которые было бы неплохо сохранить в виде файлов. К счастью, сохранение таблиц в __R__ столь же просто, как и чтение. Для текстовых файлов в формате __CSV__ можно использовать функции `write.table()`, `write.csv()` и `write.csv2()`. Для файлов __Microsoft Excel__ используйте функции `write.xlsx()` или `write.xlsx2()` из пакета `xlsx` соответственно. 

По умолчанию эти функции записывают в таблицы в качестве первого столбца названия (номера) строк таблиц. Если вы не хотите, чтобы это происходило, укажите дополнительный параметр `row.names=FALSE`.

Сохраним таблицы `okruga` и `neokruga`, раздельно хранящие статистику по объему сброса сточных в поверхностные водные объекты по федеральным округам и субъектам соответственно:
```{r, collapse=TRUE}
write.csv2(okruga, "okruga.csv", fileEncoding = 'UTF-8') # Сохраним первую таблицу в CSV в кодировке Unicode
write.xlsx2(neokruga, "neokruga.xlsx", row.names=FALSE) # Сохраним вторую таблицу в XLSX без названий строк

# Проверим, все ли в порядке с сохраненными таблицами:

okruga.saved <- read.csv2("okruga.csv", encoding = 'UTF-8')
head(okruga.saved)

neokruga.saved <- read.xlsx2("neokruga.xlsx",1)
head(neokruga.saved)
```

Видно, что в файле __CSV__ присутствует также дополнительный столбец с названиями строк, а в файле __XLSX__ его нет. Если вы не задавали названия строк явным образом и они не несут какого-то смысла, всегда указывайте параметр `row.names=FALSE`

> Вы можете дать строкам таблицы названия и извлечь их, используя функцию `row.names()` аналогично функции `colnames()` для столбцов.

## Правила подготовки таблиц для чтения в R

С таблицами, которые мы использовали в настоящем модуле, все прошло гладко, поскольку они были подготовлены специальным образом. Несмотря на то, что каких-то четких правил подготовки таблиц для программной обработки не существует, можно дать несколько полезных рекомендаций по данному поводу:

1. В первой строке таблицы должны располагаться названия столбцов.
2. В названиях столбцов недопустимы объединенные ячейки, покрывающие несколько столбцов. Это может привести к неверному подсчету количества столбцов и, как следствие, некорректному чтению таблицы в целом.
3. Названия столбцов должны состоять из латинских букв и цифр, начинаться с буквы и не содержать пробелов. Сложносочиненные названия выделяйте прописными буквами. Плохое название столбца: `Валовый внутренний продукт за 2015 г.`. Хорошее название столбца: `GDP2015`.
4. Во второй строке таблицы должны начинаться данные. Не допускайте многострочных заголовков.
5. Некоторые ошибки данных в таблицах (такие как неверные десятичные разделители), проще найти и исправить в табличном/текстовом редакторе, нежели после загрузки в R.

Следование этим правилам значительно облегчит работу с табличными данными.